import "./chunk-PZ5AY32C.js";

// node_modules/ohash/dist/shared/ohash.D__AXeF1.mjs
function serialize(o) {
  return typeof o == "string" ? `'${o}'` : new c().serialize(o);
}
var c = (function() {
  class o {
    #t = /* @__PURE__ */ new Map();
    compare(t, r) {
      const e = typeof t, n = typeof r;
      return e === "string" && n === "string" ? t.localeCompare(r) : e === "number" && n === "number" ? t - r : String.prototype.localeCompare.call(this.serialize(t, true), this.serialize(r, true));
    }
    serialize(t, r) {
      if (t === null) return "null";
      switch (typeof t) {
        case "string":
          return r ? t : `'${t}'`;
        case "bigint":
          return `${t}n`;
        case "object":
          return this.$object(t);
        case "function":
          return this.$function(t);
      }
      return String(t);
    }
    serializeObject(t) {
      const r = Object.prototype.toString.call(t);
      if (r !== "[object Object]") return this.serializeBuiltInType(r.length < 10 ? `unknown:${r}` : r.slice(8, -1), t);
      const e = t.constructor, n = e === Object || e === void 0 ? "" : e.name;
      if (n !== "" && globalThis[n] === e) return this.serializeBuiltInType(n, t);
      if (typeof t.toJSON == "function") {
        const i = t.toJSON();
        return n + (i !== null && typeof i == "object" ? this.$object(i) : `(${this.serialize(i)})`);
      }
      return this.serializeObjectEntries(n, Object.entries(t));
    }
    serializeBuiltInType(t, r) {
      const e = this["$" + t];
      if (e) return e.call(this, r);
      if (typeof r?.entries == "function") return this.serializeObjectEntries(t, r.entries());
      throw new Error(`Cannot serialize ${t}`);
    }
    serializeObjectEntries(t, r) {
      const e = Array.from(r).sort((i, a) => this.compare(i[0], a[0]));
      let n = `${t}{`;
      for (let i = 0; i < e.length; i++) {
        const [a, l] = e[i];
        n += `${this.serialize(a, true)}:${this.serialize(l)}`, i < e.length - 1 && (n += ",");
      }
      return n + "}";
    }
    $object(t) {
      let r = this.#t.get(t);
      return r === void 0 && (this.#t.set(t, `#${this.#t.size}`), r = this.serializeObject(t), this.#t.set(t, r)), r;
    }
    $function(t) {
      const r = Function.prototype.toString.call(t);
      return r.slice(-15) === "[native code] }" ? `${t.name || ""}()[native]` : `${t.name}(${t.length})${r.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(t) {
      let r = "[";
      for (let e = 0; e < t.length; e++) r += this.serialize(t[e]), e < t.length - 1 && (r += ",");
      return r + "]";
    }
    $Date(t) {
      try {
        return `Date(${t.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(t) {
      return `ArrayBuffer[${new Uint8Array(t).join(",")}]`;
    }
    $Set(t) {
      return `Set${this.$Array(Array.from(t).sort((r, e) => this.compare(r, e)))}`;
    }
    $Map(t) {
      return this.serializeObjectEntries("Map", t.entries());
    }
  }
  for (const s of ["Error", "RegExp", "URL"]) o.prototype["$" + s] = function(t) {
    return `${s}(${t})`;
  };
  for (const s of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join(",")}]`;
  };
  for (const s of ["BigInt64Array", "BigUint64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join("n,")}${t.length > 0 ? "n" : ""}]`;
  };
  return o;
})();
function isEqual(object1, object2) {
  if (object1 === object2) {
    return true;
  }
  if (serialize(object1) === serialize(object2)) {
    return true;
  }
  return false;
}

// node_modules/reka-ui/dist/shared/arrays.js
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) return false;
  for (let index = 0; index < arrayA.length; index++) if (arrayA[index] !== arrayB[index]) return false;
  return true;
}
function findValuesBetween(array, start, end) {
  const startIndex = array.findIndex((i) => isEqual(i, start));
  const endIndex = array.findIndex((i) => isEqual(i, end));
  if (startIndex === -1 || endIndex === -1) return [];
  const [minIndex, maxIndex] = [startIndex, endIndex].sort((a, b) => a - b);
  return array.slice(minIndex, maxIndex + 1);
}

// node_modules/reka-ui/dist/shared/browser.js
var isBrowser = typeof document !== "undefined";

// node_modules/reka-ui/dist/shared/clamp.js
function clamp(value, min2 = Number.NEGATIVE_INFINITY, max2 = Number.POSITIVE_INFINITY) {
  return Math.min(max2, Math.max(min2, value));
}
function roundToStepPrecision(value, step) {
  let roundedValue = value;
  const stepString = step.toString();
  const pointIndex = stepString.indexOf(".");
  const precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;
  if (precision > 0) {
    const pow = 10 ** precision;
    roundedValue = Math.round(roundedValue * pow) / pow;
  }
  return roundedValue;
}
function snapValueToStep(value, min2, max2, step) {
  min2 = Number(min2);
  max2 = Number(max2);
  const remainder = (value - (Number.isNaN(min2) ? 0 : min2)) % step;
  let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder, step);
  if (!Number.isNaN(min2)) {
    if (snappedValue < min2) snappedValue = min2;
    else if (!Number.isNaN(max2) && snappedValue > max2) snappedValue = min2 + Math.floor(roundToStepPrecision((max2 - min2) / step, step)) * step;
  } else if (!Number.isNaN(max2) && snappedValue > max2) snappedValue = Math.floor(roundToStepPrecision(max2 / step, step)) * step;
  snappedValue = roundToStepPrecision(snappedValue, step);
  return snappedValue;
}

// node_modules/reka-ui/dist/shared/createContext.js
import { inject, provide } from "vue";
function createContext(providerComponentName, contextName) {
  const symbolDescription = typeof providerComponentName === "string" && !contextName ? `${providerComponentName}Context` : contextName;
  const injectionKey = Symbol(symbolDescription);
  const injectContext = (fallback) => {
    const context2 = inject(injectionKey, fallback);
    if (context2) return context2;
    if (context2 === null) return context2;
    throw new Error(`Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(", ")}` : `\`${providerComponentName}\``}`);
  };
  const provideContext = (contextValue) => {
    provide(injectionKey, contextValue);
    return contextValue;
  };
  return [injectContext, provideContext];
}

// node_modules/reka-ui/dist/shared/getActiveElement.js
function getActiveElement() {
  let activeElement = document.activeElement;
  if (activeElement == null) return null;
  while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) activeElement = activeElement.shadowRoot.activeElement;
  return activeElement;
}

// node_modules/reka-ui/dist/shared/handleAndDispatchCustomEvent.js
function handleAndDispatchCustomEvent(name, handler, detail) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler) target.addEventListener(name, handler, { once: true });
  target.dispatchEvent(event);
}

// node_modules/reka-ui/dist/shared/nullish.js
function isNullish(value) {
  return value === null || value === void 0;
}

// node_modules/reka-ui/dist/shared/isValueEqualOrExist.js
function isValueEqualOrExist(base, current) {
  if (isNullish(base)) return false;
  if (Array.isArray(base)) return base.some((val) => isEqual(val, current));
  else return isEqual(base, current);
}

// node_modules/reka-ui/dist/shared/renderSlotFragments.js
import { Fragment } from "vue";
function renderSlotFragments(children) {
  if (!children) return [];
  return children.flatMap((child) => {
    if (child.type === Fragment) return renderSlotFragments(child.children);
    return [child];
  });
}

// node_modules/reka-ui/dist/shared/useArrowNavigation.js
var ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options = {}) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)) return null;
  const { arrowKeyOptions = "both", attributeName = "[data-reka-collection-item]", itemsArray = [], loop = true, dir = "ltr", preventScroll = true, focus: focus2 = false } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical)) return null;
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length) return null;
  if (preventScroll) e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) item = allCollectionItems.at(0) || null;
  else if (end) item = allCollectionItems.at(-1) || null;
  if (focus2) item?.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, options, iterations = elements.length) {
  if (--iterations === 0) return null;
  const index = elements.indexOf(currentElement);
  const newIndex = options.goForward ? index + 1 : index - 1;
  if (!options.loop && (newIndex < 0 || newIndex >= elements.length)) return null;
  const adjustedNewIndex = (newIndex + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate) return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) return findNextFocusableElement(elements, candidate, options, iterations);
  return candidate;
}

// node_modules/reka-ui/dist/ConfigProvider/ConfigProvider.js
import { defineComponent, renderSlot, toRefs } from "vue";
var [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
var ConfigProvider_vue_vue_type_script_setup_true_lang_default = defineComponent({
  inheritAttrs: false,
  __name: "ConfigProvider",
  props: {
    dir: {
      type: String,
      required: false,
      default: "ltr"
    },
    locale: {
      type: String,
      required: false,
      default: "en"
    },
    scrollBody: {
      type: [Boolean, Object],
      required: false,
      default: true
    },
    nonce: {
      type: String,
      required: false,
      default: void 0
    },
    useId: {
      type: Function,
      required: false,
      default: void 0
    }
  },
  setup(__props) {
    const props2 = __props;
    const { dir, locale, scrollBody, nonce } = toRefs(props2);
    provideConfigProviderContext({
      dir,
      locale,
      scrollBody,
      nonce,
      useId: props2.useId
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
var ConfigProvider_default = ConfigProvider_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/shared/useBodyScrollLock.js
import { computed as computed3, nextTick as nextTick3, ref as ref3, watch as watch3 } from "vue";

// node_modules/reka-ui/node_modules/@vueuse/shared/index.mjs
import { shallowRef, watchEffect, readonly, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject as inject2, provide as provide2, ref, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from "vue";
function computedEager(fn, options) {
  var _a;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options,
    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : "sync"
  });
  return readonly(result);
}
function computedWithControl(source, fn) {
  let v = void 0;
  let track;
  let trigger;
  const dirty = shallowRef(true);
  const update = () => {
    dirty.value = true;
    trigger();
  };
  watch(source, update, { flush: "sync" });
  const get = typeof fn === "function" ? fn : fn.get;
  const set = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v = get(v);
          dirty.value = false;
        }
        track();
        return v;
      },
      set(v2) {
        set == null ? void 0 : set(v2);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const clear = () => {
    fns.clear();
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on,
    off,
    trigger,
    clear
  };
}
function createGlobalState(stateFactory) {
  let initialized = false;
  let state;
  const scope = effectScope(true);
  return (...args) => {
    if (!initialized) {
      state = scope.run(() => stateFactory(...args));
      initialized = true;
    }
    return state;
  };
}
function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!scope) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}
function toReactive(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_, p, receiver) {
      return unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(_, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value))
        objectRef.value[p].value = value;
      else
        objectRef.value[p] = value;
      return true;
    },
    deleteProperty(_, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(_, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
function reactiveComputed(fn) {
  return toReactive(computed(fn));
}
function reactiveOmit(obj, ...keys2) {
  const flatKeys = keys2.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue$1(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var isDef = (val) => typeof val !== "undefined";
var notNullish = (val) => val != null;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
var bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  let lastInvoker;
  const filter = (invoke) => {
    const duration = toValue$1(ms);
    const maxDuration = toValue$1(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      lastInvoker = invoke;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(lastInvoker());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function pausableFilter(extendFilter = bypassFilter, options = {}) {
  const {
    initialState = "active"
  } = options;
  const isActive = toRef(initialState === "active");
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function toRef(...args) {
  if (args.length !== 1)
    return toRef$1(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);
}
function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track, trigger) => {
    let value = toValue$1(defaultValue);
    let timer;
    const resetAfter = () => setTimeout(() => {
      value = toValue$1(defaultValue);
      trigger();
    }, toValue$1(afterMs));
    tryOnScopeDispose(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter,
    initialState = "active",
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter, { initialState });
  const stop = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function syncRef(left, right, ...[options]) {
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform: transform2 = {}
  } = options || {};
  const watchers = [];
  const transformLTR = "ltr" in transform2 && transform2.ltr || ((v) => v);
  const transformRTL = "rtl" in transform2 && transform2.rtl || ((v) => v);
  if (direction === "both" || direction === "ltr") {
    watchers.push(watchPausable(
      left,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        right.value = transformLTR(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  if (direction === "both" || direction === "rtl") {
    watchers.push(watchPausable(
      right,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        left.value = transformRTL(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  const stop = () => {
    watchers.forEach((w) => w.stop());
  };
  return stop;
}
var toValue = toValue$1;
function tryOnBeforeUnmount(fn, target) {
  const instance = getLifeCycleTarget(target);
  if (instance)
    onBeforeUnmount(fn, target);
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const isPending = shallowRef(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    if (immediateCallback)
      cb();
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue$1(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop);
  return {
    isPending: readonly(isPending),
    start,
    stop
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(
    callback != null ? callback : noop,
    interval,
    options
  );
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
function watchImmediate(source, cb, options) {
  return watch(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}
function watchOnce(source, cb, options) {
  const stop = watch(source, (...args) => {
    nextTick(() => stop());
    return cb(...args);
  }, options);
  return stop;
}

// node_modules/reka-ui/node_modules/@vueuse/core/index.mjs
import { isRef as isRef2, shallowRef as shallowRef2, ref as ref2, watchEffect as watchEffect2, computed as computed2, inject as inject3, defineComponent as defineComponent2, h, TransitionGroup, shallowReactive, Fragment as Fragment2, toValue as toValue2, unref as unref2, getCurrentInstance as getCurrentInstance2, onMounted as onMounted2, watch as watch2, customRef as customRef2, onUpdated, readonly as readonly2, reactive as reactive2, hasInjectionContext as hasInjectionContext2, toRaw, nextTick as nextTick2, markRaw, getCurrentScope as getCurrentScope2, isReadonly, onBeforeUpdate } from "vue";
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function unrefElement(elRef) {
  var _a;
  const plain = toValue2(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed2(() => {
    const test = toArray(toValue2(args[0])).filter((e) => e != null);
    return test.every((e) => typeof e !== "string") ? test : void 0;
  });
  const stopWatch = watchImmediate(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement(e))) != null ? _b : [defaultWindow].filter((e) => e != null),
        toArray(toValue2(firstParamTargets.value ? args[1] : args[0])),
        toArray(unref2(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue2(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(cleanup);
  return stop;
}
function useMounted() {
  const isMounted = shallowRef2(false);
  const instance = getCurrentInstance2();
  if (instance) {
    onMounted2(() => {
      isMounted.value = true;
    }, instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed2(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed2(() => {
    const value = toValue2(target);
    const items = toArray(value).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch2(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function onElementRemoval(target, callback, options = {}) {
  const {
    window: window2 = defaultWindow,
    document: document2 = window2 == null ? void 0 : window2.document,
    flush = "sync"
  } = options;
  if (!window2 || !document2)
    return noop;
  let stopFn;
  const cleanupAndUpdate = (fn) => {
    stopFn == null ? void 0 : stopFn();
    stopFn = fn;
  };
  const stopWatch = watchEffect2(() => {
    const el = unrefElement(target);
    if (el) {
      const { stop } = useMutationObserver(
        document2,
        (mutationsList) => {
          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));
          if (targetRemoved) {
            callback(mutationsList);
          }
        },
        {
          window: window2,
          childList: true,
          subtree: true
        }
      );
      cleanupAndUpdate(stop);
    }
  }, { flush });
  const stopHandle = () => {
    stopWatch();
    cleanupAndUpdate();
  };
  tryOnScopeDispose(stopHandle);
  return stopHandle;
}
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (e.repeat && toValue2(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target, eventName, listener, passive);
}
function useActiveElement(options = {}) {
  var _a;
  const {
    window: window2 = defaultWindow,
    deep = true,
    triggerOnRemoval = false
  } = options;
  const document2 = (_a = options.document) != null ? _a : window2 == null ? void 0 : window2.document;
  const getDeepActiveElement = () => {
    var _a2;
    let element = document2 == null ? void 0 : document2.activeElement;
    if (deep) {
      while (element == null ? void 0 : element.shadowRoot)
        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
    }
    return element;
  };
  const activeElement = shallowRef2();
  const trigger = () => {
    activeElement.value = getDeepActiveElement();
  };
  if (window2) {
    const listenerOptions = {
      capture: true,
      passive: true
    };
    useEventListener(
      window2,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        trigger();
      },
      listenerOptions
    );
    useEventListener(
      window2,
      "focus",
      trigger,
      listenerOptions
    );
  }
  if (triggerOnRemoval) {
    onElementRemoval(activeElement, trigger, { document: document2 });
  }
  trigger();
  return activeElement;
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow,
    once = false
  } = options;
  const isActive = shallowRef2(false);
  const intervalLimit = computed2(() => {
    return fpsLimit ? 1e3 / toValue2(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    if (once) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly2(isActive),
    pause,
    resume
  };
}
var ssrWidthSymbol = Symbol("vueuse-ssr-width");
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance2();
  const currentElement = computedWithControl(
    () => null,
    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el
  );
  onUpdated(currentElement.trigger);
  onMounted2(currentElement.trigger);
  return currentElement;
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed2(() => {
    const _targets = toValue2(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement(el)) : [unrefElement(_targets)];
  });
  const stopWatch = watch2(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
var EVENT_FOCUS_IN = "focusin";
var EVENT_FOCUS_OUT = "focusout";
var PSEUDO_CLASS_FOCUS_WITHIN = ":focus-within";
function useFocusWithin(target, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const targetElement = computed2(() => unrefElement(target));
  const _focused = shallowRef2(false);
  const focused = computed2(() => _focused.value);
  const activeElement = useActiveElement(options);
  if (!window2 || !activeElement.value) {
    return { focused };
  }
  const listenerOptions = { passive: true };
  useEventListener(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);
  useEventListener(targetElement, EVENT_FOCUS_OUT, () => {
    var _a, _b, _c;
    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;
  }, listenerOptions);
  return { focused };
}
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef2();
  const update = () => {
    const el = unrefElement(element);
    if (el)
      parentElement.value = el.parentElement;
  };
  tryOnMounted(update);
  watch2(() => toValue2(element), update);
  return parentElement;
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useVModel(props2, key, emit, options = {}) {
  var _a, _b, _c;
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance2();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    key = "modelValue";
  }
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
  const getValue = () => isDef(props2[key]) ? cloneFn(props2[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue();
    const proxy = ref2(initialValue);
    let isUpdating = false;
    watch2(
      () => props2[key],
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v);
          nextTick2(() => isUpdating = false);
        }
      }
    );
    watch2(
      proxy,
      (v) => {
        if (!isUpdating && (v !== props2[key] || deep))
          triggerEmit(v);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed2({
      get() {
        return getValue();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}

// node_modules/reka-ui/dist/shared/useBodyScrollLock.js
import { defu } from "defu";
var useBodyLockStackCount = createSharedComposable(() => {
  const map = ref3(/* @__PURE__ */ new Map());
  const initialOverflow = ref3();
  const locked = computed3(() => {
    for (const value of map.value.values()) if (value) return true;
    return false;
  });
  const context2 = injectConfigProviderContext({ scrollBody: ref3(true) });
  let stopTouchMoveListener = null;
  const resetBodyStyle = () => {
    document.body.style.paddingRight = "";
    document.body.style.marginRight = "";
    document.body.style.pointerEvents = "";
    document.documentElement.style.removeProperty("--scrollbar-width");
    document.body.style.overflow = initialOverflow.value ?? "";
    isIOS && stopTouchMoveListener?.();
    initialOverflow.value = void 0;
  };
  watch3(locked, (val, oldVal) => {
    if (!isClient) return;
    if (!val) {
      if (oldVal) resetBodyStyle();
      return;
    }
    if (initialOverflow.value === void 0) initialOverflow.value = document.body.style.overflow;
    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const defaultConfig = {
      padding: verticalScrollbarWidth,
      margin: 0
    };
    const config = context2.scrollBody?.value ? typeof context2.scrollBody.value === "object" ? defu({
      padding: context2.scrollBody.value.padding === true ? verticalScrollbarWidth : context2.scrollBody.value.padding,
      margin: context2.scrollBody.value.margin === true ? verticalScrollbarWidth : context2.scrollBody.value.margin
    }, defaultConfig) : defaultConfig : {
      padding: 0,
      margin: 0
    };
    if (verticalScrollbarWidth > 0) {
      document.body.style.paddingRight = typeof config.padding === "number" ? `${config.padding}px` : String(config.padding);
      document.body.style.marginRight = typeof config.margin === "number" ? `${config.margin}px` : String(config.margin);
      document.documentElement.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
      document.body.style.overflow = "hidden";
    }
    if (isIOS) stopTouchMoveListener = useEventListener(document, "touchmove", (e) => preventDefault(e), { passive: false });
    nextTick3(() => {
      document.body.style.pointerEvents = "none";
      document.body.style.overflow = "hidden";
    });
  }, {
    immediate: true,
    flush: "sync"
  });
  return map;
});
function useBodyScrollLock(initialState) {
  const id = Math.random().toString(36).substring(2, 7);
  const map = useBodyLockStackCount();
  map.value.set(id, initialState ?? false);
  const locked = computed3({
    get: () => map.value.get(id) ?? false,
    set: (value) => map.value.set(id, value)
  });
  tryOnBeforeUnmount(() => {
    map.value.delete(id);
  });
  return locked;
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) return true;
  else {
    const parent = ele.parentNode;
    if (!(parent instanceof Element) || parent.tagName === "BODY") return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (_target instanceof Element && checkOverflowScroll(_target)) return false;
  if (e.touches.length > 1) return true;
  if (e.preventDefault && e.cancelable) e.preventDefault();
  return false;
}

// node_modules/@internationalized/date/dist/utils.mjs
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

// node_modules/@internationalized/date/dist/GregorianCalendar.mjs
var $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
  year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
  let y1 = year - 1;
  let monthOffset = -2;
  if (month <= 2) monthOffset = 0;
  else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) monthOffset = -1;
  return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
  return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
  let era = "AD";
  if (year <= 0) {
    era = "BC";
    year = 1 - year;
  }
  return [
    era,
    year
  ];
}
var $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
var $3b62074eb05584b2$export$80ee6245ec4f29ec = class {
  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
    let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
    let leapAdj = 2;
    if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1)) leapAdj = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year)) leapAdj = 1;
    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
  }
  toJulianDay(date) {
    return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(date) {
    return 12;
  }
  getDaysInYear(date) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(date) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(date) {
    return date.era === "BC";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BC" ? "AD" : "BC";
      date.year = 1 - date.year;
    }
  }
  constructor() {
    this.identifier = "gregory";
  }
};

// node_modules/@internationalized/date/dist/weekStartData.mjs
var $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

// node_modules/@internationalized/date/dist/queries.mjs
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  return a.era === b.era && a.year === b.year && a.month === b.month && a.day === b.day;
}
function $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b) {
  b = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b, a.calendar);
  a = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(a);
  b = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(b);
  return a.era === b.era && a.year === b.year && a.month === b.month;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a, b) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a.calendar, b.calendar) && $14e0f24ef4ac5c92$export$ea39ec197993aef0(a, b);
}
function $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(a, b) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a.calendar, b.calendar) && $14e0f24ef4ac5c92$export$a18c89cbd24170ff(a, b);
}
function $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(a, b) {
  var _a_isEqual, _b_isEqual;
  var _a_isEqual1, _ref;
  return (_ref = (_a_isEqual1 = (_a_isEqual = a.isEqual) === null || _a_isEqual === void 0 ? void 0 : _a_isEqual.call(a, b)) !== null && _a_isEqual1 !== void 0 ? _a_isEqual1 : (_b_isEqual = b.isEqual) === null || _b_isEqual === void 0 ? void 0 : _b_isEqual.call(b, a)) !== null && _ref !== void 0 ? _ref : a.identifier === b.identifier;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
var $14e0f24ef4ac5c92$var$DAY_MAP = {
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale, firstDayOfWeek) {
  let julian = date.calendar.toJulianDay(date);
  let weekStart = firstDayOfWeek ? $14e0f24ef4ac5c92$var$DAY_MAP[firstDayOfWeek] : $14e0f24ef4ac5c92$var$getWeekStart(locale);
  let dayOfWeek = Math.ceil(julian + 1 - weekStart) % 7;
  if (dayOfWeek < 0) dayOfWeek += 7;
  return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
  return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a, b) {
  return a.calendar.toJulianDay(a) - b.calendar.toJulianDay(b);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a, b) {
  return $14e0f24ef4ac5c92$var$timeToMs(a) - $14e0f24ef4ac5c92$var$timeToMs(b);
}
function $14e0f24ef4ac5c92$var$timeToMs(a) {
  return a.hour * 36e5 + a.minute * 6e4 + a.second * 1e3 + a.millisecond;
}
var $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  if ($14e0f24ef4ac5c92$var$localTimeZone == null) $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
  return date.subtract({
    days: date.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}
var $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
var $14e0f24ef4ac5c92$var$cachedWeekInfo = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
  if (Intl.Locale) {
    let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
    if (!region) {
      region = new Intl.Locale(locale).maximize().region;
      if (region) $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
    }
    return region;
  }
  let part = locale.split("-")[1];
  return part === "u" ? void 0 : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
  let weekInfo = $14e0f24ef4ac5c92$var$cachedWeekInfo.get(locale);
  if (!weekInfo) {
    if (Intl.Locale) {
      let localeInst = new Intl.Locale(locale);
      if ("getWeekInfo" in localeInst) {
        weekInfo = localeInst.getWeekInfo();
        if (weekInfo) {
          $14e0f24ef4ac5c92$var$cachedWeekInfo.set(locale, weekInfo);
          return weekInfo.firstDay;
        }
      }
    }
    let region = $14e0f24ef4ac5c92$var$getRegion(locale);
    if (locale.includes("-fw-")) {
      let day = locale.split("-fw-")[1].split("-")[0];
      if (day === "mon") weekInfo = {
        firstDay: 1
      };
      else if (day === "tue") weekInfo = {
        firstDay: 2
      };
      else if (day === "wed") weekInfo = {
        firstDay: 3
      };
      else if (day === "thu") weekInfo = {
        firstDay: 4
      };
      else if (day === "fri") weekInfo = {
        firstDay: 5
      };
      else if (day === "sat") weekInfo = {
        firstDay: 6
      };
      else weekInfo = {
        firstDay: 0
      };
    } else if (locale.includes("-ca-iso8601")) weekInfo = {
      firstDay: 1
    };
    else weekInfo = {
      firstDay: region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0
    };
    $14e0f24ef4ac5c92$var$cachedWeekInfo.set(locale, weekInfo);
  }
  return weekInfo.firstDay;
}

// node_modules/@internationalized/date/dist/conversion.mjs
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
  date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
  return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  let date = /* @__PURE__ */ new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone) {
  if (timeZone === "UTC") return 0;
  if (ms > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)()) return new Date(ms).getTimezoneOffset() * -6e4;
  let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone);
  let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms / 1e3) * 1e3;
}
var $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms, timeZone) {
  let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
  }
  let parts = formatter.formatToParts(new Date(ms));
  let namedParts = {};
  for (let part of parts) if (part.type !== "literal") namedParts[part.type] = part.value;
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}
var $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$export$136f38efe7caf549(date, timeZone) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date);
  let earlier = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let later = ms - $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  return $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later);
}
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [
    earlier
  ] : [
    earlier,
    later
  ];
  return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
  let parts = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts.year && date.month === parts.month && date.day === parts.day && date.hour === parts.hour && date.minute === parts.minute && date.second === parts.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
  let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
  if (timeZone === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
    dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let date2 = /* @__PURE__ */ new Date();
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
    date2.setFullYear(year, dateTime.month - 1, dateTime.day);
    date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date2.getTime();
  }
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms - offsetBefore, ms - offsetAfter);
  if (valid.length === 1) return valid[0];
  if (valid.length > 1) switch (disambiguation) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return valid[0];
    case "later":
      return valid[valid.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (disambiguation) {
    case "earlier":
      return Math.min(ms - offsetBefore, ms - offsetAfter);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(ms - offsetBefore, ms - offsetAfter);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone) {
  let offset3 = $11d87f3f76e88657$export$59c99f3515d3493f(ms, timeZone);
  let date = new Date(ms + offset3);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year < 1 ? "BC" : "AD", year < 1 ? -year + 1 : year, month, day, timeZone, offset3, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
  let hour = 0, minute = 0, second = 0, millisecond = 0;
  if ("timeZone" in date) ({ hour, minute, second, millisecond } = date);
  else if ("hour" in date && !time) return date;
  if (time) ({ hour, minute, second, millisecond } = time);
  return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
  if ((0, $14e0f24ef4ac5c92$export$dbc69fd56b53d5e)(date.calendar, calendar)) return date;
  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy = date.copy();
  copy.calendar = calendar;
  copy.era = calendarDate.era;
  copy.year = calendarDate.year;
  copy.month = calendarDate.month;
  copy.day = calendarDate.day;
  (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);
  return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
  if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
    if (date.timeZone === timeZone) return date;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
  }
  let ms = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return new Date(ms);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
  let ms = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms, timeZone), date.calendar);
}

// node_modules/@internationalized/date/dist/manipulation.mjs
var $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
  let mutableDate = date.copy();
  let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
  if (mutableDate.calendar.balanceYearMonth) mutableDate.calendar.balanceYearMonth(mutableDate, date);
  mutableDate.month += duration.months || 0;
  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $735220c2d4774dd3$var$balanceDay(mutableDate);
  if (mutableDate.calendar.balanceDate) mutableDate.calendar.balanceDate(mutableDate);
  if (mutableDate.year < 1) {
    mutableDate.year = 1;
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
  if (mutableDate.year > maxYear) {
    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
    mutableDate.year = maxYear;
    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  if (mutableDate.month < 1) {
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
  if (mutableDate.month > maxMonth) {
    mutableDate.month = maxMonth;
    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
  return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
  var _date_calendar_isInverseEra, _date_calendar;
  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date)) years = -years;
  date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $735220c2d4774dd3$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }
  let monthsInYear = 0;
  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $735220c2d4774dd3$var$addYears(date, 1);
  }
}
function $735220c2d4774dd3$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $735220c2d4774dd3$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }
  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $735220c2d4774dd3$var$balanceYearMonth(date);
  }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
  if (date.calendar.constrainDate) date.calendar.constrainDate(date);
  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
  let inverseDuration = {};
  for (let key in duration) if (typeof duration[key] === "number") inverseDuration[key] = -duration[key];
  return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
  let mutableDate = date.copy();
  if (fields.era != null) mutableDate.era = fields.era;
  if (fields.year != null) mutableDate.year = fields.year;
  if (fields.month != null) mutableDate.month = fields.month;
  if (fields.day != null) mutableDate.day = fields.day;
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
  return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
  let mutableValue = value.copy();
  if (fields.hour != null) mutableValue.hour = fields.hour;
  if (fields.minute != null) mutableValue.minute = fields.minute;
  if (fields.second != null) mutableValue.second = fields.second;
  if (fields.millisecond != null) mutableValue.millisecond = fields.millisecond;
  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
  return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1e3);
  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
  time.minute += Math.floor(time.second / 60);
  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
  return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a, b) {
  let result = a % b;
  if (result < 0) result += b;
  return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(time, duration) {
  let res = time.copy();
  $735220c2d4774dd3$var$addTimeFields(res, duration);
  return res;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(time, duration) {
  return $735220c2d4774dd3$export$7ed87b6bc2506470(time, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "era": {
      let eras = value.calendar.getEras();
      let eraIndex = eras.indexOf(value.era);
      if (eraIndex < 0) throw new Error("Invalid era: " + value.era);
      eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
      mutable.era = eras[eraIndex];
      $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
      break;
    }
    case "year":
      var _mutable_calendar_isInverseEra, _mutable_calendar;
      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable)) amount = -amount;
      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
      if (mutable.year === -Infinity) mutable.year = 1;
      if (mutable.calendar.balanceYearMonth) mutable.calendar.balanceYearMonth(mutable, value);
      break;
    case "month":
      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    case "day":
      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  if (value.calendar.balanceDate) value.calendar.balanceDate(mutable);
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
  return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "hour": {
      let hours = value.hour;
      let min2 = 0;
      let max2 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = hours >= 12;
        min2 = isPM ? 12 : 0;
        max2 = isPM ? 23 : 11;
      }
      mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min2, max2, options === null || options === void 0 ? void 0 : options.round);
      break;
    }
    case "minute":
      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "second":
      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "millisecond":
      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min2, max2, round2 = false) {
  if (round2) {
    value += Math.sign(amount);
    if (value < min2) value = max2;
    let div = Math.abs(amount);
    if (amount > 0) value = Math.ceil(value / div) * div;
    else value = Math.floor(value / div) * div;
    if (value > max2) value = min2;
  } else {
    value += amount;
    if (value < min2) value = max2 - (min2 - value - 1);
    else if (value > max2) value = min2 + (value - max2 - 1);
  }
  return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
  let ms;
  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
    let res2 = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
      years: duration.years,
      months: duration.months,
      weeks: duration.weeks,
      days: duration.days
    });
    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res2, dateTime.timeZone);
  } else
    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
  ms += duration.milliseconds || 0;
  ms += (duration.seconds || 0) * 1e3;
  ms += (duration.minutes || 0) * 6e4;
  ms += (duration.hours || 0) * 36e5;
  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
  switch (field) {
    case "hour": {
      let min2 = 0;
      let max2 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = dateTime.hour >= 12;
        min2 = isPM ? 12 : 0;
        max2 = isPM ? 23 : 11;
      }
      let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
      let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: min2
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let minAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === minDate.day)[0];
      let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: max2
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let maxAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
      ].filter((ms2) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone).day === maxDate.day).pop();
      let ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
      let hours = Math.floor(ms / $735220c2d4774dd3$var$ONE_HOUR);
      let remainder = ms % $735220c2d4774dd3$var$ONE_HOUR;
      ms = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
    case "era":
    case "year":
    case "month":
    case "day": {
      let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
      let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
    }
    default:
      throw new Error("Unsupported field " + field);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
  if (res.compare(plainDateTime) === 0) return dateTime;
  let ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, dateTime.timeZone), dateTime.calendar);
}

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$DATE_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})$/;
var $fae977aafc393c5c$var$DATE_TIME_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?$/;
var $fae977aafc393c5c$var$ZONED_DATE_TIME_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:([+-]\d{2})(?::?(\d{2}))?(?::?(\d{2}))?)?\[(.*?)\]$/;
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$6b862160d295c8e(value) {
  let m = value.match($fae977aafc393c5c$var$DATE_RE);
  if (!m) throw new Error("Invalid ISO 8601 date string: " + value);
  let date = new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)($fae977aafc393c5c$var$parseNumber(m[1], 0, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1);
  date.day = $fae977aafc393c5c$var$parseNumber(m[3], 1, date.calendar.getDaysInMonth(date));
  return date;
}
function $fae977aafc393c5c$export$588937bcd60ade55(value) {
  let m = value.match($fae977aafc393c5c$var$DATE_TIME_RE);
  if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
  let year = $fae977aafc393c5c$var$parseNumber(m[1], -9999, 9999);
  let era = year < 1 ? "BC" : "AD";
  let date = new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(era, year < 1 ? -year + 1 : year, $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1e3 : 0);
  date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
  return date;
}
function $fae977aafc393c5c$export$fd7893f06e92a6a4(value, disambiguation) {
  let m = value.match($fae977aafc393c5c$var$ZONED_DATE_TIME_RE);
  if (!m) throw new Error("Invalid ISO 8601 date time string: " + value);
  let year = $fae977aafc393c5c$var$parseNumber(m[1], -9999, 9999);
  let era = year < 1 ? "BC" : "AD";
  let date = new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(era, year < 1 ? -year + 1 : year, $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1, m[11], 0, m[4] ? $fae977aafc393c5c$var$parseNumber(m[4], 0, 23) : 0, m[5] ? $fae977aafc393c5c$var$parseNumber(m[5], 0, 59) : 0, m[6] ? $fae977aafc393c5c$var$parseNumber(m[6], 0, 59) : 0, m[7] ? $fae977aafc393c5c$var$parseNumber(m[7], 0, Infinity) * 1e3 : 0);
  date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(date);
  let ms;
  if (m[8]) {
    let hourOffset = $fae977aafc393c5c$var$parseNumber(m[8], -23, 23);
    var _m_, _m_1;
    date.offset = Math.sign(hourOffset) * (Math.abs(hourOffset) * 36e5 + $fae977aafc393c5c$var$parseNumber((_m_ = m[9]) !== null && _m_ !== void 0 ? _m_ : "0", 0, 59) * 6e4 + $fae977aafc393c5c$var$parseNumber((_m_1 = m[10]) !== null && _m_1 !== void 0 ? _m_1 : "0", 0, 59) * 1e3);
    ms = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(date) - date.offset;
    let absolutes = (0, $11d87f3f76e88657$export$136f38efe7caf549)(plainDateTime, date.timeZone);
    if (!absolutes.includes(ms)) throw new Error(`Offset ${$fae977aafc393c5c$var$offsetToString(date.offset)} is invalid for ${$fae977aafc393c5c$export$4223de14708adc63(date)} in ${date.timeZone}`);
  } else
    ms = (0, $11d87f3f76e88657$export$5107c82f94518f5c)((0, $11d87f3f76e88657$export$b21e0b124e224484)(plainDateTime), date.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms, date.timeZone);
}
function $fae977aafc393c5c$var$parseNumber(value, min2, max2) {
  let val = Number(value);
  if (val < min2 || val > max2) throw new RangeError(`Value out of range: ${min2} <= ${val} <= ${max2}`);
  return val;
}
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
  return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
  let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year;
  if (gregorianDate.era === "BC") year = gregorianDate.year === 1 ? "0000" : "-" + String(Math.abs(1 - gregorianDate.year)).padStart(6, "00");
  else year = String(gregorianDate.year).padStart(4, "0");
  return `${year}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset3) {
  let sign = Math.sign(offset3) < 0 ? "-" : "+";
  offset3 = Math.abs(offset3);
  let offsetHours = Math.floor(offset3 / 36e5);
  let offsetMinutes = Math.floor(offset3 % 36e5 / 6e4);
  let offsetSeconds = Math.floor(offset3 % 36e5 % 6e4 / 1e3);
  let stringOffset = `${sign}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
  if (offsetSeconds !== 0) stringOffset += `:${String(offsetSeconds).padStart(2, "0")}`;
  return stringOffset;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@internationalized/date/dist/CalendarDate.mjs
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
  let calendar = typeof args[0] === "object" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  let era;
  if (typeof args[0] === "string") era = args.shift();
  else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }
  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [
    calendar,
    era,
    year,
    month,
    day
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$99faa760c7908e4f = class _$35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
    else return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(timeZone) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type1 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$680ea196effce5f = class _$35ea8db9cb2ccb90$export$680ea196effce5f {
  /** Returns a copy of this time. */
  copy() {
    return new _$35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$7ed87b6bc2506470)(this, duration);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$fe34d3a381cd7501)(this, duration);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$f59dee82248f5ad4)(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(b) {
    return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, b);
  }
  constructor(hour = 0, minute = 0, second = 0, millisecond = 0) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type1, {
      writable: true,
      value: void 0
    });
    this.hour = hour;
    this.minute = minute;
    this.second = second;
    this.millisecond = millisecond;
    (0, $735220c2d4774dd3$export$7555de1e070510cb)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$ca871e8dbb80966f = class _$35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    switch (field) {
      case "era":
      case "year":
      case "month":
      case "day":
        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
      default:
        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(timeZone, disambiguation) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b);
    if (res === 0) return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b));
    return res;
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$d3b7288e7994edea = class _$35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    if (this.era) return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    else return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields, disambiguation) {
    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b) {
    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b, this.timeZone).toDate().getTime();
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset3 = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset3;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};

// node_modules/@internationalized/date/dist/JapaneseCalendar.mjs
var $62225008020f0a13$var$ERA_START_DATES = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
];
var $62225008020f0a13$var$ERA_END_DATES = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
];
var $62225008020f0a13$var$ERA_ADDENDS = [
  1867,
  1911,
  1925,
  1988,
  2018
];
var $62225008020f0a13$var$ERA_NAMES = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function $62225008020f0a13$var$findEraFromGregorianDate(date) {
  const idx = $62225008020f0a13$var$ERA_START_DATES.findIndex(([year, month, day]) => {
    if (date.year < year) return true;
    if (date.year === year && date.month < month) return true;
    if (date.year === year && date.month === month && date.day < day) return true;
    return false;
  });
  if (idx === -1) return $62225008020f0a13$var$ERA_START_DATES.length - 1;
  if (idx === 0) return 0;
  return idx - 1;
}
function $62225008020f0a13$var$toGregorian(date) {
  let eraAddend = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(date.era)];
  if (!eraAddend) throw new Error("Unknown era: " + date.era);
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(date.year + eraAddend, date.month, date.day);
}
var $62225008020f0a13$export$b746ab2b60cdffbf = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    let era = $62225008020f0a13$var$findEraFromGregorianDate(date);
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, $62225008020f0a13$var$ERA_NAMES[era], date.year - $62225008020f0a13$var$ERA_ADDENDS[era], date.month, date.day);
  }
  toJulianDay(date) {
    return super.toJulianDay($62225008020f0a13$var$toGregorian(date));
  }
  balanceDate(date) {
    let gregorianDate = $62225008020f0a13$var$toGregorian(date);
    let era = $62225008020f0a13$var$findEraFromGregorianDate(gregorianDate);
    if ($62225008020f0a13$var$ERA_NAMES[era] !== date.era) {
      date.era = $62225008020f0a13$var$ERA_NAMES[era];
      date.year = gregorianDate.year - $62225008020f0a13$var$ERA_ADDENDS[era];
    }
    this.constrainDate(date);
  }
  constrainDate(date) {
    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
    let end = $62225008020f0a13$var$ERA_END_DATES[idx];
    if (end != null) {
      let [endYear, endMonth, endDay] = end;
      let maxYear = endYear - $62225008020f0a13$var$ERA_ADDENDS[idx];
      date.year = Math.max(1, Math.min(maxYear, date.year));
      if (date.year === maxYear) {
        date.month = Math.min(endMonth, date.month);
        if (date.month === endMonth) date.day = Math.min(endDay, date.day);
      }
    }
    if (date.year === 1 && idx >= 0) {
      let [, startMonth, startDay] = $62225008020f0a13$var$ERA_START_DATES[idx];
      date.month = Math.max(startMonth, date.month);
      if (date.month === startMonth) date.day = Math.max(startDay, date.day);
    }
  }
  getEras() {
    return $62225008020f0a13$var$ERA_NAMES;
  }
  getYearsInEra(date) {
    let era = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
    let cur = $62225008020f0a13$var$ERA_START_DATES[era];
    let next = $62225008020f0a13$var$ERA_START_DATES[era + 1];
    if (next == null)
      return 9999 - cur[0] + 1;
    let years = next[0] - cur[0];
    if (date.month < next[1] || date.month === next[1] && date.day < next[2]) years++;
    return years;
  }
  getDaysInMonth(date) {
    return super.getDaysInMonth($62225008020f0a13$var$toGregorian(date));
  }
  getMinimumMonthInYear(date) {
    let start = $62225008020f0a13$var$getMinimums(date);
    return start ? start[1] : 1;
  }
  getMinimumDayInMonth(date) {
    let start = $62225008020f0a13$var$getMinimums(date);
    return start && date.month === start[1] ? start[2] : 1;
  }
  constructor(...args) {
    super(...args), this.identifier = "japanese";
  }
};
function $62225008020f0a13$var$getMinimums(date) {
  if (date.year === 1) {
    let idx = $62225008020f0a13$var$ERA_NAMES.indexOf(date.era);
    return $62225008020f0a13$var$ERA_START_DATES[idx];
  }
}

// node_modules/@internationalized/date/dist/BuddhistCalendar.mjs
var $8d73d47422ca7302$var$BUDDHIST_ERA_START = -543;
var $8d73d47422ca7302$export$42d20a78301dee44 = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let gregorianDate = super.fromJulianDay(jd);
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(gregorianDate.era, gregorianDate.year);
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year - $8d73d47422ca7302$var$BUDDHIST_ERA_START, gregorianDate.month, gregorianDate.day);
  }
  toJulianDay(date) {
    return super.toJulianDay($8d73d47422ca7302$var$toGregorian(date));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(date) {
    return super.getDaysInMonth($8d73d47422ca7302$var$toGregorian(date));
  }
  balanceDate() {
  }
  constructor(...args) {
    super(...args), this.identifier = "buddhist";
  }
};
function $8d73d47422ca7302$var$toGregorian(date) {
  let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(date.year + $8d73d47422ca7302$var$BUDDHIST_ERA_START);
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);
}

// node_modules/@internationalized/date/dist/TaiwanCalendar.mjs
var $5f31bd6f0c8940b2$var$TAIWAN_ERA_START = 1911;
function $5f31bd6f0c8940b2$var$gregorianYear(date) {
  return date.era === "minguo" ? date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START : 1 - date.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
}
function $5f31bd6f0c8940b2$var$gregorianToTaiwan(year) {
  let y = year - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
  if (y > 0) return [
    "minguo",
    y
  ];
  else return [
    "before_minguo",
    1 - y
  ];
}
var $5f31bd6f0c8940b2$export$65e01080afcb0799 = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    let extendedYear = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
    let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan(extendedYear);
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, date.month, date.day);
  }
  toJulianDay(date) {
    return super.toJulianDay($5f31bd6f0c8940b2$var$toGregorian(date));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(date) {
    let [era, year] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($5f31bd6f0c8940b2$var$gregorianYear(date));
    date.era = era;
    date.year = year;
  }
  isInverseEra(date) {
    return date.era === "before_minguo";
  }
  getDaysInMonth(date) {
    return super.getDaysInMonth($5f31bd6f0c8940b2$var$toGregorian(date));
  }
  getYearsInEra(date) {
    return date.era === "before_minguo" ? 9999 : 9999 - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
  }
  constructor(...args) {
    super(...args), this.identifier = "roc";
  }
};
function $5f31bd6f0c8940b2$var$toGregorian(date) {
  let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)($5f31bd6f0c8940b2$var$gregorianYear(date));
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, date.month, date.day);
}

// node_modules/@internationalized/date/dist/PersianCalendar.mjs
var $f3ed2e4472ae7e25$var$PERSIAN_EPOCH = 1948320;
var $f3ed2e4472ae7e25$var$MONTH_START = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
var $f3ed2e4472ae7e25$export$37fccdbfd14c5939 = class {
  fromJulianDay(jd) {
    let daysSinceEpoch = jd - $f3ed2e4472ae7e25$var$PERSIAN_EPOCH;
    let year = 1 + Math.floor((33 * daysSinceEpoch + 3) / 12053);
    let farvardin1 = 365 * (year - 1) + Math.floor((8 * year + 21) / 33);
    let dayOfYear = daysSinceEpoch - farvardin1;
    let month = dayOfYear < 216 ? Math.floor(dayOfYear / 31) : Math.floor((dayOfYear - 6) / 30);
    let day = dayOfYear - $f3ed2e4472ae7e25$var$MONTH_START[month] + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month + 1, day);
  }
  toJulianDay(date) {
    let jd = $f3ed2e4472ae7e25$var$PERSIAN_EPOCH - 1 + 365 * (date.year - 1) + Math.floor((8 * date.year + 21) / 33);
    jd += $f3ed2e4472ae7e25$var$MONTH_START[date.month - 1];
    jd += date.day;
    return jd;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(date) {
    if (date.month <= 6) return 31;
    if (date.month <= 11) return 30;
    let isLeapYear = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(25 * date.year + 11, 33) < 8;
    return isLeapYear ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
};

// node_modules/@internationalized/date/dist/IndianCalendar.mjs
var $82c358003bdda0a8$var$INDIAN_ERA_START = 78;
var $82c358003bdda0a8$var$INDIAN_YEAR_START = 80;
var $82c358003bdda0a8$export$39f31c639fa15726 = class extends (0, $3b62074eb05584b2$export$80ee6245ec4f29ec) {
  fromJulianDay(jd) {
    let date = super.fromJulianDay(jd);
    let indianYear = date.year - $82c358003bdda0a8$var$INDIAN_ERA_START;
    let yDay = jd - (0, $3b62074eb05584b2$export$f297eb839006d339)(date.era, date.year, 1, 1);
    let leapMonth;
    if (yDay < $82c358003bdda0a8$var$INDIAN_YEAR_START) {
      indianYear--;
      leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year - 1) ? 31 : 30;
      yDay += leapMonth + 155 + 90 + 10;
    } else {
      leapMonth = (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year) ? 31 : 30;
      yDay -= $82c358003bdda0a8$var$INDIAN_YEAR_START;
    }
    let indianMonth;
    let indianDay;
    if (yDay < leapMonth) {
      indianMonth = 1;
      indianDay = yDay + 1;
    } else {
      let mDay = yDay - leapMonth;
      if (mDay < 155) {
        indianMonth = Math.floor(mDay / 31) + 2;
        indianDay = mDay % 31 + 1;
      } else {
        mDay -= 155;
        indianMonth = Math.floor(mDay / 30) + 7;
        indianDay = mDay % 30 + 1;
      }
    }
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, indianYear, indianMonth, indianDay);
  }
  toJulianDay(date) {
    let extendedYear = date.year + $82c358003bdda0a8$var$INDIAN_ERA_START;
    let [era, year] = (0, $3b62074eb05584b2$export$4475b7e617eb123c)(extendedYear);
    let leapMonth;
    let jd;
    if ((0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(year)) {
      leapMonth = 31;
      jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 21);
    } else {
      leapMonth = 30;
      jd = (0, $3b62074eb05584b2$export$f297eb839006d339)(era, year, 3, 22);
    }
    if (date.month === 1) return jd + date.day - 1;
    jd += leapMonth + Math.min(date.month - 2, 5) * 31;
    if (date.month >= 8) jd += (date.month - 7) * 30;
    jd += date.day - 1;
    return jd;
  }
  getDaysInMonth(date) {
    if (date.month === 1 && (0, $3b62074eb05584b2$export$553d7fa8e3805fc0)(date.year + $82c358003bdda0a8$var$INDIAN_ERA_START)) return 31;
    if (date.month >= 2 && date.month <= 6) return 31;
    return 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...args) {
    super(...args), this.identifier = "indian";
  }
};

// node_modules/@internationalized/date/dist/IslamicCalendar.mjs
var $f2f3e0e3a817edbd$var$CIVIL_EPOC = 1948440;
var $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC = 1948439;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START = 1300;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END = 1600;
var $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS = 460322;
function $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, day) {
  return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + epoch - 1;
}
function $f2f3e0e3a817edbd$var$julianDayToIslamic(calendar, epoch, jd) {
  let year = Math.floor((30 * (jd - epoch) + 10646) / 10631);
  let month = Math.min(12, Math.ceil((jd - (29 + $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, 1, 1))) / 29.5) + 1);
  let day = jd - $f2f3e0e3a817edbd$var$islamicToJulianDay(epoch, year, month, 1) + 1;
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(calendar, year, month, day);
}
function $f2f3e0e3a817edbd$var$isLeapYear(year) {
  return (14 + 11 * year) % 30 < 11;
}
var $f2f3e0e3a817edbd$export$2066795aadd37bfc = class {
  fromJulianDay(jd) {
    return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$CIVIL_EPOC, jd);
  }
  toJulianDay(date) {
    return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$CIVIL_EPOC, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    let length = 29 + date.month % 2;
    if (date.month === 12 && $f2f3e0e3a817edbd$var$isLeapYear(date.year)) length++;
    return length;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(date) {
    return $f2f3e0e3a817edbd$var$isLeapYear(date.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
};
var $f2f3e0e3a817edbd$export$37f0887f2f9d22f7 = class extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
  fromJulianDay(jd) {
    return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, jd);
  }
  toJulianDay(date) {
    return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, date.year, date.month, date.day);
  }
  constructor(...args) {
    super(...args), this.identifier = "islamic-tbla";
  }
};
var $f2f3e0e3a817edbd$var$UMALQURA_DATA = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
var $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH;
var $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE;
function $f2f3e0e3a817edbd$var$umalquraYearStart(year) {
  return $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS + $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
function $f2f3e0e3a817edbd$var$umalquraMonthLength(year, month) {
  let idx = year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START;
  let mask = 1 << 11 - (month - 1);
  if (($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH[idx] & mask) === 0) return 29;
  else return 30;
}
function $f2f3e0e3a817edbd$var$umalquraMonthStart(year, month) {
  let day = $f2f3e0e3a817edbd$var$umalquraYearStart(year);
  for (let i = 1; i < month; i++) day += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);
  return day;
}
function $f2f3e0e3a817edbd$var$umalquraYearLength(year) {
  return $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year + 1 - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
var $f2f3e0e3a817edbd$export$5baab4758c231076 = class extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
  fromJulianDay(jd) {
    let days = jd - $f2f3e0e3a817edbd$var$CIVIL_EPOC;
    let startDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_START);
    let endDays = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END);
    if (days < startDays || days > endDays) return super.fromJulianDay(jd);
    else {
      let y = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START - 1;
      let m = 1;
      let d = 1;
      while (d > 0) {
        y++;
        d = days - $f2f3e0e3a817edbd$var$umalquraYearStart(y) + 1;
        let yearLength = $f2f3e0e3a817edbd$var$umalquraYearLength(y);
        if (d === yearLength) {
          m = 12;
          break;
        } else if (d < yearLength) {
          let monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);
          m = 1;
          while (d > monthLength) {
            d -= monthLength;
            m++;
            monthLength = $f2f3e0e3a817edbd$var$umalquraMonthLength(y, m);
          }
          break;
        }
      }
      return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, y, m, days - $f2f3e0e3a817edbd$var$umalquraMonthStart(y, m) + 1);
    }
  }
  toJulianDay(date) {
    if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.toJulianDay(date);
    return $f2f3e0e3a817edbd$var$CIVIL_EPOC + $f2f3e0e3a817edbd$var$umalquraMonthStart(date.year, date.month) + (date.day - 1);
  }
  getDaysInMonth(date) {
    if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInMonth(date);
    return $f2f3e0e3a817edbd$var$umalquraMonthLength(date.year, date.month);
  }
  getDaysInYear(date) {
    if (date.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || date.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END) return super.getDaysInYear(date);
    return $f2f3e0e3a817edbd$var$umalquraYearLength(date.year);
  }
  constructor() {
    super(), this.identifier = "islamic-umalqura";
    if (!$f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH) $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($f2f3e0e3a817edbd$var$UMALQURA_DATA), (c2) => c2.charCodeAt(0)).buffer);
    if (!$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE) {
      $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START + 1);
      let yearStart = 0;
      for (let year = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START; year <= $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END; year++) {
        $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[year - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] = yearStart;
        for (let i = 1; i <= 12; i++) yearStart += $f2f3e0e3a817edbd$var$umalquraMonthLength(year, i);
      }
    }
  }
};

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HEBREW_EPOCH = 347997;
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;
function $7c5f6fbf42389787$var$isLeapYear(year) {
  return (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(year * 7 + 1, 19) < 7;
}
function $7c5f6fbf42389787$var$hebrewDelay1(year) {
  let months = Math.floor((235 * year - 234) / 19);
  let parts = 12084 + 13753 * months;
  let day = months * 29 + Math.floor(parts / 25920);
  if ((0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(3 * (day + 1), 7) < 3) day += 1;
  return day;
}
function $7c5f6fbf42389787$var$hebrewDelay2(year) {
  let last = $7c5f6fbf42389787$var$hebrewDelay1(year - 1);
  let present = $7c5f6fbf42389787$var$hebrewDelay1(year);
  let next = $7c5f6fbf42389787$var$hebrewDelay1(year + 1);
  if (next - present === 356) return 2;
  if (present - last === 382) return 1;
  return 0;
}
function $7c5f6fbf42389787$var$startOfYear(year) {
  return $7c5f6fbf42389787$var$hebrewDelay1(year) + $7c5f6fbf42389787$var$hebrewDelay2(year);
}
function $7c5f6fbf42389787$var$getDaysInYear(year) {
  return $7c5f6fbf42389787$var$startOfYear(year + 1) - $7c5f6fbf42389787$var$startOfYear(year);
}
function $7c5f6fbf42389787$var$getYearType(year) {
  let yearLength = $7c5f6fbf42389787$var$getDaysInYear(year);
  if (yearLength > 380) yearLength -= 30;
  switch (yearLength) {
    case 353:
      return 0;
    // deficient
    case 354:
      return 1;
    // normal
    case 355:
      return 2;
  }
}
function $7c5f6fbf42389787$var$getDaysInMonth(year, month) {
  if (month >= 6 && !$7c5f6fbf42389787$var$isLeapYear(year)) month++;
  if (month === 4 || month === 7 || month === 9 || month === 11 || month === 13) return 29;
  let yearType = $7c5f6fbf42389787$var$getYearType(year);
  if (month === 2) return yearType === 2 ? 30 : 29;
  if (month === 3) return yearType === 0 ? 29 : 30;
  if (month === 6) return $7c5f6fbf42389787$var$isLeapYear(year) ? 30 : 0;
  return 30;
}
var $7c5f6fbf42389787$export$ca405048b8fb5af = class {
  fromJulianDay(jd) {
    let d = jd - $7c5f6fbf42389787$var$HEBREW_EPOCH;
    let m = d * $7c5f6fbf42389787$var$DAY_PARTS / $7c5f6fbf42389787$var$MONTH_PARTS;
    let year = Math.floor((19 * m + 234) / 235) + 1;
    let ys = $7c5f6fbf42389787$var$startOfYear(year);
    let dayOfYear = Math.floor(d - ys);
    while (dayOfYear < 1) {
      year--;
      ys = $7c5f6fbf42389787$var$startOfYear(year);
      dayOfYear = Math.floor(d - ys);
    }
    let month = 1;
    let monthStart = 0;
    while (monthStart < dayOfYear) {
      monthStart += $7c5f6fbf42389787$var$getDaysInMonth(year, month);
      month++;
    }
    month--;
    monthStart -= $7c5f6fbf42389787$var$getDaysInMonth(year, month);
    let day = dayOfYear - monthStart;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, year, month, day);
  }
  toJulianDay(date) {
    let jd = $7c5f6fbf42389787$var$startOfYear(date.year);
    for (let month = 1; month < date.month; month++) jd += $7c5f6fbf42389787$var$getDaysInMonth(date.year, month);
    return jd + date.day + $7c5f6fbf42389787$var$HEBREW_EPOCH;
  }
  getDaysInMonth(date) {
    return $7c5f6fbf42389787$var$getDaysInMonth(date.year, date.month);
  }
  getMonthsInYear(date) {
    return $7c5f6fbf42389787$var$isLeapYear(date.year) ? 13 : 12;
  }
  getDaysInYear(date) {
    return $7c5f6fbf42389787$var$getDaysInYear(date.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(date, previousDate) {
    if (previousDate.year !== date.year) {
      if ($7c5f6fbf42389787$var$isLeapYear(previousDate.year) && !$7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month--;
      else if (!$7c5f6fbf42389787$var$isLeapYear(previousDate.year) && $7c5f6fbf42389787$var$isLeapYear(date.year) && previousDate.month > 6) date.month++;
    }
  }
  constructor() {
    this.identifier = "hebrew";
  }
};

// node_modules/@internationalized/date/dist/EthiopicCalendar.mjs
var $b956b2d7a6cf451f$var$ETHIOPIC_EPOCH = 1723856;
var $b956b2d7a6cf451f$var$COPTIC_EPOCH = 1824665;
var $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA = 5500;
function $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, day) {
  return epoch + 365 * year + Math.floor(year / 4) + 30 * (month - 1) + day - 1;
}
function $b956b2d7a6cf451f$var$julianDayToCE(epoch, jd) {
  let year = Math.floor(4 * (jd - epoch) / 1461);
  let month = 1 + Math.floor((jd - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, 1, 1)) / 30);
  let day = jd + 1 - $b956b2d7a6cf451f$var$ceToJulianDay(epoch, year, month, 1);
  return [
    year,
    month,
    day
  ];
}
function $b956b2d7a6cf451f$var$getLeapDay(year) {
  return Math.floor(year % 4 / 3);
}
function $b956b2d7a6cf451f$var$getDaysInMonth(year, month) {
  if (month % 13 !== 0)
    return 30;
  else
    return $b956b2d7a6cf451f$var$getLeapDay(year) + 5;
}
var $b956b2d7a6cf451f$export$26ba6eab5e20cd7d = class {
  fromJulianDay(jd) {
    let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
    let era = "AM";
    if (year <= 0) {
      era = "AA";
      year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
    }
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);
  }
  toJulianDay(date) {
    let year = date.year;
    if (date.era === "AA") year -= $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
    return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $b956b2d7a6cf451f$var$getDaysInMonth(date.year, date.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(date) {
    return 365 + $b956b2d7a6cf451f$var$getLeapDay(date.year);
  }
  getYearsInEra(date) {
    return date.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
};
var $b956b2d7a6cf451f$export$d72e0c37005a4914 = class extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
  fromJulianDay(jd) {
    let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, jd);
    year += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, "AA", year, month, day);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...args) {
    super(...args), this.identifier = "ethioaa";
  }
};
var $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1 = class extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
  fromJulianDay(jd) {
    let [year, month, day] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$COPTIC_EPOCH, jd);
    let era = "CE";
    if (year <= 0) {
      era = "BCE";
      year = 1 - year;
    }
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(this, era, year, month, day);
  }
  toJulianDay(date) {
    let year = date.year;
    if (date.era === "BCE") year = 1 - year;
    return $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$COPTIC_EPOCH, year, date.month, date.day);
  }
  getDaysInMonth(date) {
    let year = date.year;
    if (date.era === "BCE") year = 1 - year;
    return $b956b2d7a6cf451f$var$getDaysInMonth(year, date.month);
  }
  isInverseEra(date) {
    return date.era === "BCE";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BCE" ? "CE" : "BCE";
      date.year = 1 - date.year;
    }
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(date) {
    return date.era === "BCE" ? 9999 : 9715;
  }
  constructor(...args) {
    super(...args), this.identifier = "coptic";
  }
};

// node_modules/@internationalized/date/dist/createCalendar.mjs
function $64244302c3013299$export$dd0bbc9b26defe37(name) {
  switch (name) {
    case "buddhist":
      return new (0, $8d73d47422ca7302$export$42d20a78301dee44)();
    case "ethiopic":
      return new (0, $b956b2d7a6cf451f$export$26ba6eab5e20cd7d)();
    case "ethioaa":
      return new (0, $b956b2d7a6cf451f$export$d72e0c37005a4914)();
    case "coptic":
      return new (0, $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1)();
    case "hebrew":
      return new (0, $7c5f6fbf42389787$export$ca405048b8fb5af)();
    case "indian":
      return new (0, $82c358003bdda0a8$export$39f31c639fa15726)();
    case "islamic-civil":
      return new (0, $f2f3e0e3a817edbd$export$2066795aadd37bfc)();
    case "islamic-tbla":
      return new (0, $f2f3e0e3a817edbd$export$37f0887f2f9d22f7)();
    case "islamic-umalqura":
      return new (0, $f2f3e0e3a817edbd$export$5baab4758c231076)();
    case "japanese":
      return new (0, $62225008020f0a13$export$b746ab2b60cdffbf)();
    case "persian":
      return new (0, $f3ed2e4472ae7e25$export$37fccdbfd14c5939)();
    case "roc":
      return new (0, $5f31bd6f0c8940b2$export$65e01080afcb0799)();
    case "gregory":
    default:
      return new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  }
}

// node_modules/@internationalized/date/dist/DateFormatter.mjs
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(value) {
    return this.formatter.format(value);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }
  /** Formats a date range as a string. */
  formatRange(start, end) {
    if (typeof this.formatter.formatRange === "function")
      return this.formatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(start)} – ${this.formatter.format(end)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.formatter.formatRangeToParts === "function")
      return this.formatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();
    if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle) this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
    }
    if (resolvedOptions.calendar === "ethiopic-amete-alem") resolvedOptions.calendar = "ethioaa";
    return resolvedOptions;
  }
  constructor(locale, options = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }
};
var $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
  if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    options = {
      ...options
    };
    let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
    let defaultHourCycle = options.hour12 ? "h12" : "h23";
    options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
    delete options.hour12;
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey)) return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null) $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: false
  }).format(new Date(2020, 2, 3, 0)) === "24";
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null) $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: false
  }).resolvedOptions().hourCycle === "h12";
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour) return void 0;
  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
  locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
  let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
    ...options,
    timeZone: void 0
    // use local timezone
  });
  let min2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p) => p.type === "hour").value, 10);
  let max2 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p) => p.type === "hour").value, 10);
  if (min2 === 0 && max2 === 23) return "h23";
  if (min2 === 24 && max2 === 23) return "h24";
  if (min2 === 0 && max2 === 11) return "h11";
  if (min2 === 12 && max2 === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}

// node_modules/reka-ui/dist/date/comparators.js
function parseStringToDateValue(dateStr, referenceVal) {
  let dateValue;
  if (isZonedDateTime(referenceVal)) dateValue = $fae977aafc393c5c$export$fd7893f06e92a6a4(dateStr);
  else if (isCalendarDateTime(referenceVal)) dateValue = $fae977aafc393c5c$export$588937bcd60ade55(dateStr);
  else dateValue = $fae977aafc393c5c$export$6b862160d295c8e(dateStr);
  return dateValue.calendar !== referenceVal.calendar ? $11d87f3f76e88657$export$b4a036af3fc0b032(dateValue, referenceVal.calendar) : dateValue;
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  if (isZonedDateTime(dateValue)) return dateValue.toDate();
  else return dateValue.toDate(tz);
}
function isCalendarDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date) {
  if (date instanceof Date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return new Date(year, month, 0).getDate();
  } else return date.set({ day: 100 }).day;
}
function isBefore(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date, start, end) {
  return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}
function isBetween(date, start, end) {
  return isAfter(date, start) && isBefore(date, end);
}
function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  if (firstDayOfWeek > day) return date.subtract({ days: day + 7 - firstDayOfWeek });
  if (firstDayOfWeek === day) return date;
  return date.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  if (day === lastDayOfWeek) return date;
  if (day > lastDayOfWeek) return date.add({ days: 7 - day + lastDayOfWeek });
  return date.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled, isHighlightable) {
  if (isUnavailable === void 0 && isDisabled === void 0 && isHighlightable === void 0) return true;
  let dCurrent = start.add({ days: 1 });
  if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) && !isHighlightable?.(dCurrent)) return false;
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    dCurrent = dCurrent.add({ days: 1 });
    if ((isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) && !isHighlightable?.(dCurrent)) return false;
  }
  return true;
}
function getDefaultDate(props2) {
  const { defaultValue, defaultPlaceholder, granularity = "day", locale = "en" } = props2;
  if (Array.isArray(defaultValue) && defaultValue.length) return defaultValue.at(-1).copy();
  if (defaultValue && !Array.isArray(defaultValue)) return defaultValue.copy();
  if (defaultPlaceholder) return defaultPlaceholder.copy();
  const date = /* @__PURE__ */ new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const calendarDateTimeGranularities2 = [
    "hour",
    "minute",
    "second"
  ];
  const defaultFormatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale);
  const calendar = $64244302c3013299$export$dd0bbc9b26defe37(defaultFormatter.resolvedOptions().calendar);
  if (calendarDateTimeGranularities2.includes(granularity ?? "day")) return $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0), calendar);
  return $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day), calendar);
}
function getDefaultTime(props2) {
  const { defaultValue, defaultPlaceholder } = props2;
  if (defaultValue) return defaultValue.copy();
  if (defaultPlaceholder) return defaultPlaceholder.copy();
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(0, 0, 0);
}

// node_modules/reka-ui/dist/date/utils.js
import { defu as defu2 } from "defu";
function chunk(arr, size3) {
  const result = [];
  for (let i = 0; i < arr.length; i += size3) result.push(arr.slice(i, i + size3));
  return result;
}
function getOptsByGranularity(granularity, hourCycle, isTimeValue = false) {
  const opts = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: normalizeHourCycle(hourCycle),
    hour12: normalizeHour12(hourCycle)
  };
  if (isTimeValue) {
    delete opts.year;
    delete opts.month;
    delete opts.day;
  }
  if (granularity === "day") {
    delete opts.second;
    delete opts.hour;
    delete opts.minute;
    delete opts.timeZoneName;
  }
  if (granularity === "hour") {
    delete opts.minute;
    delete opts.second;
  }
  if (granularity === "minute") delete opts.second;
  return opts;
}
function normalizeDateStep(props2) {
  return defu2(props2?.step, {
    year: 1,
    month: 1,
    day: 1,
    hour: 1,
    minute: 1,
    second: 1,
    millisecond: 1
  });
}
function handleCalendarInitialFocus(calendar) {
  const selectedDay = calendar.querySelector("[data-selected]");
  if (selectedDay) return selectedDay.focus();
  const today = calendar.querySelector("[data-today]");
  if (today) return today.focus();
  const firstDay = calendar.querySelector("[data-reka-calendar-day]");
  if (firstDay) return firstDay.focus();
}
function normalizeHourCycle(hourCycle) {
  if (hourCycle === 24) return "h23";
  if (hourCycle === 12) return "h11";
  return void 0;
}
function normalizeHour12(hourCycle) {
  if (hourCycle === 24) return false;
  if (hourCycle === 12) return true;
  return void 0;
}

// node_modules/reka-ui/dist/date/calendar.js
function getDaysBetween(start, end) {
  const days = [];
  let dCurrent = start.add({ days: 1 });
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    days.push(dCurrent);
    dCurrent = dCurrent.add({ days: 1 });
  }
  return days;
}
function createMonth(props2) {
  const { dateObj, weekStartsOn, fixedWeeks, locale } = props2;
  const daysInMonth = getDaysInMonth(dateObj);
  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));
  const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
  const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
  const lastSunday = getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, locale);
  const nextSaturday = getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, locale);
  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
  if (fixedWeeks && totalDays < 42) {
    const extraDays = 42 - totalDays;
    let startFrom = nextMonthDays[nextMonthDays.length - 1];
    if (!startFrom) startFrom = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
    const extraDaysArray = Array.from({ length: extraDays }, (_, i) => {
      const incr = i + 1;
      return startFrom.add({ days: incr });
    });
    nextMonthDays.push(...extraDaysArray);
  }
  const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
  const weeks = chunk(allDays, 7);
  return {
    value: dateObj,
    cells: allDays,
    rows: weeks
  };
}
function createMonths(props2) {
  const { numberOfMonths, dateObj, ...monthProps } = props2;
  const months = [];
  if (!numberOfMonths || numberOfMonths === 1) {
    months.push(createMonth({
      ...monthProps,
      dateObj
    }));
    return months;
  }
  months.push(createMonth({
    ...monthProps,
    dateObj
  }));
  for (let i = 1; i < numberOfMonths; i++) {
    const nextMonth = dateObj.add({ months: i });
    months.push(createMonth({
      ...monthProps,
      dateObj: nextMonth
    }));
  }
  return months;
}

// node_modules/reka-ui/dist/shared/useDateFormatter.js
import { ref as ref4 } from "vue";
function useDateFormatter(initialLocale, opts = {}) {
  const locale = ref4(initialLocale);
  function getLocale() {
    return locale.value;
  }
  function setLocale(newLocale) {
    locale.value = newLocale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      ...options
    }).format(date);
  }
  function selectedDate(date, includeTime = true) {
    if (hasTime(date) && includeTime) return custom(toDate(date), {
      dateStyle: "long",
      timeStyle: "long"
    });
    else return custom(toDate(date), { dateStyle: "long" });
  }
  function fullMonthAndYear(date, options = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      month: "long",
      year: "numeric",
      ...options
    }).format(date);
  }
  function fullMonth(date, options = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      month: "long",
      ...options
    }).format(date);
  }
  function getMonths() {
    const defaultDate = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    const months = [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12
    ];
    return months.map((item) => ({
      label: fullMonth(toDate(defaultDate.set({ month: item }))),
      value: item
    }));
  }
  function fullYear(date, options = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      year: "numeric",
      ...options
    }).format(date);
  }
  function toParts(date, options) {
    if (isZonedDateTime(date)) return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      ...options,
      timeZone: date.timeZone
    }).formatToParts(toDate(date));
    else return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      ...options
    }).formatToParts(toDate(date));
  }
  function dayOfWeek(date, length = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      weekday: length
    }).format(date);
  }
  function dayPeriod(date) {
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale.value, {
      ...opts,
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(date);
    const value = parts.find((p) => p.type === "dayPeriod")?.value;
    if (value === "PM" || value === "p.m.") return "PM";
    return "AM";
  }
  const defaultPartOptions = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function part(dateObj, type, options = {}) {
    const opts$1 = {
      ...defaultPartOptions,
      ...options
    };
    const parts = toParts(dateObj, opts$1);
    const part$1 = parts.find((p) => p.type === type);
    return part$1 ? part$1.value : "";
  }
  return {
    setLocale,
    getLocale,
    fullMonth,
    fullYear,
    fullMonthAndYear,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedDate,
    dayOfWeek,
    getMonths
  };
}

// node_modules/reka-ui/dist/shared/useDirection.js
import { computed as computed4, ref as ref5 } from "vue";
function useDirection(dir) {
  const context2 = injectConfigProviderContext({ dir: ref5("ltr") });
  return computed4(() => dir?.value || context2.dir?.value || "ltr");
}

// node_modules/reka-ui/dist/shared/useEmitAsProps.js
import { camelize as camelize2, getCurrentInstance as getCurrentInstance3, toHandlerKey } from "vue";
function useEmitAsProps(emit) {
  const vm = getCurrentInstance3();
  const events = vm?.type.emits;
  const result = {};
  if (!events?.length) console.warn(`No emitted event found. Please check component: ${vm?.type.__name}`);
  events?.forEach((ev) => {
    result[toHandlerKey(camelize2(ev))] = (...arg) => emit(ev, ...arg);
  });
  return result;
}

// node_modules/reka-ui/dist/shared/useFilter.js
import { computed as computed5, unref as unref3 } from "vue";
function useFilter(options) {
  const computedOptions = computed5(() => unref3(options));
  const collator = computed5(() => new Intl.Collator("en", {
    usage: "search",
    ...computedOptions.value
  }));
  const startsWith = (string, substring) => {
    if (substring.length === 0) return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.value.compare(string.slice(0, substring.length), substring) === 0;
  };
  const endsWith = (string, substring) => {
    if (substring.length === 0) return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    return collator.value.compare(string.slice(-substring.length), substring) === 0;
  };
  const contains = (string, substring) => {
    if (substring.length === 0) return true;
    string = string.normalize("NFC");
    substring = substring.normalize("NFC");
    let scan = 0;
    const sliceLen = substring.length;
    for (; scan + sliceLen <= string.length; scan++) {
      const slice = string.slice(scan, scan + sliceLen);
      if (collator.value.compare(substring, slice) === 0) return true;
    }
    return false;
  };
  return {
    startsWith,
    endsWith,
    contains
  };
}

// node_modules/reka-ui/dist/shared/useFocusGuards.js
import { watchEffect as watchEffect3 } from "vue";
var count = 0;
function useFocusGuards() {
  watchEffect3((cleanupFn) => {
    if (!isClient) return;
    const edgeGuards = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count++;
    cleanupFn(() => {
      if (count === 1) document.querySelectorAll("[data-reka-focus-guard]").forEach((node) => node.remove());
      count--;
    });
  });
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-reka-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}

// node_modules/reka-ui/dist/shared/useFormControl.js
import { computed as computed6 } from "vue";
function useFormControl(el) {
  return computed6(() => toValue(el) ? Boolean(unrefElement(el)?.closest("form")) : true);
}

// node_modules/reka-ui/dist/shared/useForwardExpose.js
import { computed as computed7, getCurrentInstance as getCurrentInstance4, ref as ref6 } from "vue";
function useForwardExpose() {
  const instance = getCurrentInstance4();
  const currentRef = ref6();
  const currentElement = computed7(() => {
    return ["#text", "#comment"].includes(currentRef.value?.$el.nodeName) ? currentRef.value?.$el.nextElementSibling : unrefElement(currentRef);
  });
  const localExpose = Object.assign({}, instance.exposed);
  const ret = {};
  for (const key in instance.props) Object.defineProperty(ret, key, {
    enumerable: true,
    configurable: true,
    get: () => instance.props[key]
  });
  if (Object.keys(localExpose).length > 0) for (const key in localExpose) Object.defineProperty(ret, key, {
    enumerable: true,
    configurable: true,
    get: () => localExpose[key]
  });
  Object.defineProperty(ret, "$el", {
    enumerable: true,
    configurable: true,
    get: () => instance.vnode.el
  });
  instance.exposed = ret;
  function forwardRef(ref$1) {
    currentRef.value = ref$1;
    if (!ref$1) return;
    Object.defineProperty(ret, "$el", {
      enumerable: true,
      configurable: true,
      get: () => ref$1 instanceof Element ? ref$1 : ref$1.$el
    });
    instance.exposed = ret;
  }
  return {
    forwardRef,
    currentRef,
    currentElement
  };
}

// node_modules/reka-ui/dist/shared/useForwardProps.js
import { camelize as camelize3, computed as computed8, getCurrentInstance as getCurrentInstance5, toRef as toRef2 } from "vue";
function useForwardProps(props2) {
  const vm = getCurrentInstance5();
  const defaultProps = Object.keys(vm?.type.props ?? {}).reduce((prev, curr) => {
    const defaultValue = (vm?.type.props[curr]).default;
    if (defaultValue !== void 0) prev[curr] = defaultValue;
    return prev;
  }, {});
  const refProps = toRef2(props2);
  return computed8(() => {
    const preservedProps = {};
    const assignedProps = vm?.vnode.props ?? {};
    Object.keys(assignedProps).forEach((key) => {
      preservedProps[camelize3(key)] = assignedProps[key];
    });
    return Object.keys({
      ...defaultProps,
      ...preservedProps
    }).reduce((prev, curr) => {
      if (refProps.value[curr] !== void 0) prev[curr] = refProps.value[curr];
      return prev;
    }, {});
  });
}

// node_modules/reka-ui/dist/shared/useForwardPropsEmits.js
import { computed as computed9 } from "vue";
function useForwardPropsEmits(props2, emit) {
  const parsedProps = useForwardProps(props2);
  const emitsAsProps = emit ? useEmitAsProps(emit) : {};
  return computed9(() => ({
    ...parsedProps.value,
    ...emitsAsProps
  }));
}

// node_modules/reka-ui/dist/shared/useGraceArea.js
import { ref as ref7, watchEffect as watchEffect4 } from "vue";
function useGraceArea(triggerElement, containerElement) {
  const isPointerInTransit = refAutoReset(false, 300);
  const pointerGraceArea = ref7(null);
  const pointerExit = createEventHook();
  function handleRemoveGraceArea() {
    pointerGraceArea.value = null;
    isPointerInTransit.value = false;
  }
  function handleCreateGraceArea(event, hoverTarget) {
    const currentTarget = event.currentTarget;
    const exitPoint = {
      x: event.clientX,
      y: event.clientY
    };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    pointerGraceArea.value = graceArea;
    isPointerInTransit.value = true;
  }
  watchEffect4((cleanupFn) => {
    if (triggerElement.value && containerElement.value) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, containerElement.value);
      const handleContentLeave = (event) => handleCreateGraceArea(event, triggerElement.value);
      triggerElement.value.addEventListener("pointerleave", handleTriggerLeave);
      containerElement.value.addEventListener("pointerleave", handleContentLeave);
      cleanupFn(() => {
        triggerElement.value?.removeEventListener("pointerleave", handleTriggerLeave);
        containerElement.value?.removeEventListener("pointerleave", handleContentLeave);
      });
    }
  });
  watchEffect4((cleanupFn) => {
    if (pointerGraceArea.value) {
      const handleTrackPointerGrace = (event) => {
        if (!pointerGraceArea.value || !(event.target instanceof HTMLElement)) return;
        const target = event.target;
        const pointerPosition = {
          x: event.clientX,
          y: event.clientY
        };
        const hasEnteredTarget = triggerElement.value?.contains(target) || containerElement.value?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea.value);
        const isAnotherGraceAreaTrigger = !!target.closest("[data-grace-area-trigger]");
        if (hasEnteredTarget) handleRemoveGraceArea();
        else if (isPointerOutsideGraceArea || isAnotherGraceAreaTrigger) {
          handleRemoveGraceArea();
          pointerExit.trigger();
        }
      };
      triggerElement.value?.ownerDocument.addEventListener("pointermove", handleTrackPointerGrace);
      cleanupFn(() => triggerElement.value?.ownerDocument.removeEventListener("pointermove", handleTrackPointerGrace));
    }
  });
  return {
    isPointerInTransit,
    onPointerExit: pointerExit.on
  };
}
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "bottom":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      });
      break;
    case "left":
      paddedExitPoints.push({
        x: exitPoint.x + padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x + padding,
        y: exitPoint.y + padding
      });
      break;
    case "right":
      paddedExitPoints.push({
        x: exitPoint.x - padding,
        y: exitPoint.y - padding
      }, {
        x: exitPoint.x - padding,
        y: exitPoint.y + padding
      });
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    {
      x: left,
      y: top
    },
    {
      x: right,
      y: top
    },
    {
      x: right,
      y: bottom
    },
    {
      x: left,
      y: bottom
    }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) return upperHull;
  else return upperHull.concat(lowerHull);
}

// node_modules/reka-ui/dist/shared/useHideOthers.js
import { onUnmounted as onUnmounted2, watch as watch4 } from "vue";

// node_modules/aria-hidden/dist/es2015/index.js
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x) {
    return Boolean(x);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("aria-hidden: cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// node_modules/reka-ui/dist/shared/useHideOthers.js
function useHideOthers(target) {
  let undo;
  watch4(() => unrefElement(target), (el) => {
    if (el) undo = hideOthers(el);
    else if (undo) undo();
  });
  onUnmounted2(() => {
    if (undo) undo();
  });
}

// node_modules/reka-ui/dist/shared/useId.js
import * as vue from "vue";
var count2 = 0;
function useId2(deterministicId, prefix = "reka") {
  if (deterministicId) return deterministicId;
  if ("useId" in vue) return `${prefix}-${vue.useId?.()}`;
  const configProviderContext = injectConfigProviderContext({ useId: void 0 });
  if (configProviderContext.useId) return `${prefix}-${configProviderContext.useId()}`;
  return `${prefix}-${++count2}`;
}

// node_modules/reka-ui/dist/shared/useKbd.js
function useKbd() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}

// node_modules/reka-ui/dist/shared/useLocale.js
import { computed as computed10, ref as ref8 } from "vue";
function useLocale(locale) {
  const context2 = injectConfigProviderContext({ locale: ref8("en") });
  return computed10(() => locale?.value || context2.locale?.value || "en");
}

// node_modules/reka-ui/dist/shared/useSelectionBehavior.js
import { ref as ref9 } from "vue";
function useSelectionBehavior(modelValue, props2) {
  const firstValue = ref9();
  const onSelectItem = (val, condition) => {
    if (props2.multiple && Array.isArray(modelValue.value)) if (props2.selectionBehavior === "replace") {
      modelValue.value = [val];
      firstValue.value = val;
    } else {
      const index = modelValue.value.findIndex((v) => condition(v));
      if (index !== -1) modelValue.value = modelValue.value.filter((_, i) => i !== index);
      else modelValue.value = [...modelValue.value, val];
    }
    else if (props2.selectionBehavior === "replace") modelValue.value = { ...val };
    else if (!Array.isArray(modelValue.value) && condition(modelValue.value)) modelValue.value = void 0;
    else modelValue.value = { ...val };
    return modelValue.value;
  };
  function handleMultipleReplace(intent, currentElement, getItems, options) {
    if (!firstValue?.value || !props2.multiple || !Array.isArray(modelValue.value)) return;
    const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
    const lastValue = collection.find((i) => i.ref === currentElement)?.value;
    if (!lastValue) return;
    let value = null;
    switch (intent) {
      case "prev":
      case "next": {
        value = findValuesBetween(options, firstValue.value, lastValue);
        break;
      }
      case "first": {
        value = findValuesBetween(options, firstValue.value, options?.[0]);
        break;
      }
      case "last": {
        value = findValuesBetween(options, firstValue.value, options?.[options.length - 1]);
        break;
      }
    }
    modelValue.value = value;
  }
  return {
    firstValue,
    onSelectItem,
    handleMultipleReplace
  };
}

// node_modules/reka-ui/dist/shared/useSize.js
import { computed as computed11, onMounted as onMounted3, ref as ref10 } from "vue";
function useSize(element) {
  const size3 = ref10();
  const width = computed11(() => size3.value?.width ?? 0);
  const height = computed11(() => size3.value?.height ?? 0);
  onMounted3(() => {
    const el = unrefElement(element);
    if (el) {
      size3.value = {
        width: el.offsetWidth,
        height: el.offsetHeight
      };
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) return;
        if (!entries.length) return;
        const entry = entries[0];
        let width$1;
        let height$1;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry.borderBoxSize;
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width$1 = borderSize.inlineSize;
          height$1 = borderSize.blockSize;
        } else {
          width$1 = el.offsetWidth;
          height$1 = el.offsetHeight;
        }
        size3.value = {
          width: width$1,
          height: height$1
        };
      });
      resizeObserver.observe(el, { box: "border-box" });
      return () => resizeObserver.unobserve(el);
    } else size3.value = void 0;
  });
  return {
    width,
    height
  };
}

// node_modules/reka-ui/dist/shared/useStateMachine.js
import { ref as ref11 } from "vue";
function useStateMachine(initialState, machine) {
  const state = ref11(initialState);
  function reducer(event) {
    const nextState = machine[state.value][event];
    return nextState ?? state.value;
  }
  const dispatch = (event) => {
    state.value = reducer(event);
  };
  return {
    state,
    dispatch
  };
}

// node_modules/reka-ui/dist/shared/useTypeahead.js
function useTypeahead(callback) {
  const search = refAutoReset("", 1e3);
  const handleTypeaheadSearch = (key, items) => {
    search.value = search.value + key;
    if (callback) callback(key);
    else {
      const currentItem = getActiveElement();
      const itemsWithTextValue = items.map((item) => ({
        ...item,
        textValue: item.value?.textValue ?? item.ref.textContent?.trim() ?? ""
      }));
      const currentMatch = itemsWithTextValue.find((item) => item.ref === currentItem);
      const values = itemsWithTextValue.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search.value, currentMatch?.textValue);
      const newItem = itemsWithTextValue.find((item) => item.textValue === nextMatch);
      if (newItem) newItem.ref.focus();
      return newItem?.ref;
    }
  };
  const resetTypeahead = () => {
    search.value = "";
  };
  return {
    search,
    handleTypeaheadSearch,
    resetTypeahead
  };
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
  return nextMatch !== currentMatch ? nextMatch : void 0;
}

// node_modules/reka-ui/dist/shared/withDefault.js
import { h as h2, mergeProps } from "vue";
function withDefault(WrappedComponent, options) {
  return {
    inheritAttrs: false,
    name: `${WrappedComponent.__name ?? ""}Wrapper`,
    setup(_, ctx) {
      return () => {
        const optionProps = typeof options?.props === "function" ? options?.props(ctx.attrs) : options?.props;
        const { forwardRef } = useForwardExpose();
        const mergedProps = mergeProps(optionProps, ctx.attrs);
        return h2(WrappedComponent, {
          ...mergedProps,
          ref: forwardRef
        }, ctx.slots);
      };
    }
  };
}

// node_modules/reka-ui/dist/Presence/usePresence.js
import { computed as computed12, nextTick as nextTick4, onUnmounted as onUnmounted3, ref as ref12, watch as watch5 } from "vue";
function usePresence(present, node) {
  const stylesRef = ref12({});
  const prevAnimationNameRef = ref12("none");
  const prevPresentRef = ref12(present);
  const initialState = present.value ? "mounted" : "unmounted";
  let timeoutId;
  const ownerWindow = node.value?.ownerDocument.defaultView ?? defaultWindow;
  const { state, dispatch } = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  });
  const dispatchCustomEvent = (name) => {
    if (isClient) {
      const customEvent = new CustomEvent(name, {
        bubbles: false,
        cancelable: false
      });
      node.value?.dispatchEvent(customEvent);
    }
  };
  watch5(present, async (currentPresent, prevPresent) => {
    const hasPresentChanged = prevPresent !== currentPresent;
    await nextTick4();
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.value;
      const currentAnimationName = getAnimationName(node.value);
      if (currentPresent) {
        dispatch("MOUNT");
        dispatchCustomEvent("enter");
        if (currentAnimationName === "none") dispatchCustomEvent("after-enter");
      } else if (currentAnimationName === "none" || currentAnimationName === "undefined" || stylesRef.value?.display === "none") {
        dispatch("UNMOUNT");
        dispatchCustomEvent("leave");
        dispatchCustomEvent("after-leave");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (prevPresent && isAnimating) {
          dispatch("ANIMATION_OUT");
          dispatchCustomEvent("leave");
        } else {
          dispatch("UNMOUNT");
          dispatchCustomEvent("after-leave");
        }
      }
    }
  }, { immediate: true });
  const handleAnimationEnd = (event) => {
    const currentAnimationName = getAnimationName(node.value);
    const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
    const directionName = state.value === "mounted" ? "enter" : "leave";
    if (event.target === node.value && isCurrentAnimation) {
      dispatchCustomEvent(`after-${directionName}`);
      dispatch("ANIMATION_END");
      if (!prevPresentRef.value) {
        const currentFillMode = node.value.style.animationFillMode;
        node.value.style.animationFillMode = "forwards";
        timeoutId = ownerWindow?.setTimeout(() => {
          if (node.value?.style.animationFillMode === "forwards") node.value.style.animationFillMode = currentFillMode;
        });
      }
    }
    if (event.target === node.value && currentAnimationName === "none") dispatch("ANIMATION_END");
  };
  const handleAnimationStart = (event) => {
    if (event.target === node.value) prevAnimationNameRef.value = getAnimationName(node.value);
  };
  const watcher = watch5(node, (newNode, oldNode) => {
    if (newNode) {
      stylesRef.value = getComputedStyle(newNode);
      newNode.addEventListener("animationstart", handleAnimationStart);
      newNode.addEventListener("animationcancel", handleAnimationEnd);
      newNode.addEventListener("animationend", handleAnimationEnd);
    } else {
      dispatch("ANIMATION_END");
      if (timeoutId !== void 0) ownerWindow?.clearTimeout(timeoutId);
      oldNode?.removeEventListener("animationstart", handleAnimationStart);
      oldNode?.removeEventListener("animationcancel", handleAnimationEnd);
      oldNode?.removeEventListener("animationend", handleAnimationEnd);
    }
  }, { immediate: true });
  const stateWatcher = watch5(state, () => {
    const currentAnimationName = getAnimationName(node.value);
    prevAnimationNameRef.value = state.value === "mounted" ? currentAnimationName : "none";
  });
  onUnmounted3(() => {
    watcher();
    stateWatcher();
  });
  const isPresent = computed12(() => ["mounted", "unmountSuspended"].includes(state.value));
  return { isPresent };
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}

// node_modules/reka-ui/dist/Presence/Presence.js
import { defineComponent as defineComponent3, getCurrentInstance as getCurrentInstance6, h as h3, ref as ref13, toRefs as toRefs3 } from "vue";
var Presence_default = defineComponent3({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: true
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(props2, { slots, expose }) {
    const { present, forceMount } = toRefs3(props2);
    const node = ref13();
    const { isPresent } = usePresence(present, node);
    expose({ present: isPresent });
    let children = slots.default({ present: isPresent.value });
    children = renderSlotFragments(children || []);
    const instance = getCurrentInstance6();
    if (children && children?.length > 1) {
      const componentName = instance?.parent?.type.name ? `<${instance.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((line) => `  - ${line}`).join("\n")
      ].join("\n"));
    }
    return () => {
      if (forceMount.value || present.value || isPresent.value) return h3(slots.default({ present: isPresent.value })[0], { ref: (v) => {
        const el = unrefElement(v);
        if (typeof el?.hasAttribute === "undefined") return el;
        if (el?.hasAttribute("data-reka-popper-content-wrapper")) node.value = el.firstElementChild;
        else node.value = el;
        return el;
      } });
      else return null;
    };
  }
});

// node_modules/reka-ui/dist/Primitive/Slot.js
import { Comment, cloneVNode, defineComponent as defineComponent4, mergeProps as mergeProps2 } from "vue";
var Slot = defineComponent4({
  name: "PrimitiveSlot",
  inheritAttrs: false,
  setup(_, { attrs, slots }) {
    return () => {
      if (!slots.default) return null;
      const children = renderSlotFragments(slots.default());
      const firstNonCommentChildrenIndex = children.findIndex((child) => child.type !== Comment);
      if (firstNonCommentChildrenIndex === -1) return children;
      const firstNonCommentChildren = children[firstNonCommentChildrenIndex];
      delete firstNonCommentChildren.props?.ref;
      const mergedProps = firstNonCommentChildren.props ? mergeProps2(attrs, firstNonCommentChildren.props) : attrs;
      const cloned = cloneVNode({
        ...firstNonCommentChildren,
        props: {}
      }, mergedProps);
      if (children.length === 1) return cloned;
      children[firstNonCommentChildrenIndex] = cloned;
      return children;
    };
  }
});

// node_modules/reka-ui/dist/Primitive/Primitive.js
import { defineComponent as defineComponent5, h as h4 } from "vue";
var SELF_CLOSING_TAGS = [
  "area",
  "img",
  "input"
];
var Primitive = defineComponent5({
  name: "Primitive",
  inheritAttrs: false,
  props: {
    asChild: {
      type: Boolean,
      default: false
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(props2, { attrs, slots }) {
    const asTag = props2.asChild ? "template" : props2.as;
    if (typeof asTag === "string" && SELF_CLOSING_TAGS.includes(asTag)) return () => h4(asTag, attrs);
    if (asTag !== "template") return () => h4(props2.as, attrs, { default: slots.default });
    return () => h4(Slot, attrs, { default: slots.default });
  }
});

// node_modules/reka-ui/dist/Primitive/usePrimitiveElement.js
import { computed as computed13, ref as ref14 } from "vue";
function usePrimitiveElement() {
  const primitiveElement = ref14();
  const currentElement = computed13(() => ["#text", "#comment"].includes(primitiveElement.value?.$el.nodeName) ? primitiveElement.value?.$el.nextElementSibling : unrefElement(primitiveElement));
  return {
    primitiveElement,
    currentElement
  };
}

// node_modules/reka-ui/dist/Collapsible/CollapsibleRoot.js
import { createBlock, defineComponent as defineComponent6, openBlock, renderSlot as renderSlot2, toRefs as toRefs4, unref as unref4, withCtx } from "vue";
var [injectCollapsibleRootContext, provideCollapsibleRootContext] = createContext("CollapsibleRoot");
var CollapsibleRoot_vue_vue_type_script_setup_true_lang_default = defineComponent6({
  __name: "CollapsibleRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false,
      default: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: false
    },
    unmountOnHide: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:open"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const { disabled, unmountOnHide } = toRefs4(props2);
    provideCollapsibleRootContext({
      contentId: "",
      disabled,
      open,
      unmountOnHide,
      onOpenToggle: () => {
        if (disabled.value) return;
        open.value = !open.value;
      }
    });
    __expose({ open });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref4(Primitive), {
        as: _ctx.as,
        "as-child": props2.asChild,
        "data-state": unref4(open) ? "open" : "closed",
        "data-disabled": unref4(disabled) ? "" : void 0
      }, {
        default: withCtx(() => [renderSlot2(_ctx.$slots, "default", { open: unref4(open) })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state",
        "data-disabled"
      ]);
    };
  }
});
var CollapsibleRoot_default = CollapsibleRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Collapsible/CollapsibleContent.js
import { computed as computed14, createBlock as createBlock2, createCommentVNode, createVNode, defineComponent as defineComponent7, mergeProps as mergeProps3, nextTick as nextTick5, onMounted as onMounted4, openBlock as openBlock2, ref as ref15, renderSlot as renderSlot3, unref as unref5, watch as watch6, withCtx as withCtx2 } from "vue";
var CollapsibleContent_vue_vue_type_script_setup_true_lang_default = defineComponent7({
  inheritAttrs: false,
  __name: "CollapsibleContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["contentFound"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectCollapsibleRootContext();
    rootContext.contentId ||= useId2(void 0, "reka-collapsible-content");
    const presentRef = ref15();
    const { forwardRef, currentElement } = useForwardExpose();
    const width = ref15(0);
    const height = ref15(0);
    const isOpen = computed14(() => rootContext.open.value);
    const isMountAnimationPrevented = ref15(isOpen.value);
    const currentStyle = ref15();
    watch6(() => [isOpen.value, presentRef.value?.present], async () => {
      await nextTick5();
      const node = currentElement.value;
      if (!node) return;
      currentStyle.value = currentStyle.value || {
        transitionDuration: node.style.transitionDuration,
        animationName: node.style.animationName
      };
      node.style.transitionDuration = "0s";
      node.style.animationName = "none";
      const rect = node.getBoundingClientRect();
      height.value = rect.height;
      width.value = rect.width;
      if (!isMountAnimationPrevented.value) {
        node.style.transitionDuration = currentStyle.value.transitionDuration;
        node.style.animationName = currentStyle.value.animationName;
      }
    }, { immediate: true });
    const skipAnimation = computed14(() => isMountAnimationPrevented.value && rootContext.open.value);
    onMounted4(() => {
      requestAnimationFrame(() => {
        isMountAnimationPrevented.value = false;
      });
    });
    useEventListener(currentElement, "beforematch", (ev) => {
      requestAnimationFrame(() => {
        rootContext.onOpenToggle();
        emits("contentFound");
      });
    });
    return (_ctx, _cache) => {
      return openBlock2(), createBlock2(unref5(Presence_default), {
        ref_key: "presentRef",
        ref: presentRef,
        present: _ctx.forceMount || unref5(rootContext).open.value,
        "force-mount": true
      }, {
        default: withCtx2(({ present }) => [createVNode(unref5(Primitive), mergeProps3(_ctx.$attrs, {
          id: unref5(rootContext).contentId,
          ref: unref5(forwardRef),
          "as-child": props2.asChild,
          as: _ctx.as,
          hidden: !present ? unref5(rootContext).unmountOnHide.value ? "" : "until-found" : void 0,
          "data-state": skipAnimation.value ? void 0 : unref5(rootContext).open.value ? "open" : "closed",
          "data-disabled": unref5(rootContext).disabled?.value ? "" : void 0,
          style: {
            [`--reka-collapsible-content-height`]: `${height.value}px`,
            [`--reka-collapsible-content-width`]: `${width.value}px`
          }
        }), {
          default: withCtx2(() => [(unref5(rootContext).unmountOnHide.value ? present : true) ? renderSlot3(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)]),
          _: 2
        }, 1040, [
          "id",
          "as-child",
          "as",
          "hidden",
          "data-state",
          "data-disabled",
          "style"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var CollapsibleContent_default = CollapsibleContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Collapsible/CollapsibleTrigger.js
import { createBlock as createBlock3, defineComponent as defineComponent8, openBlock as openBlock3, renderSlot as renderSlot4, unref as unref6, withCtx as withCtx3 } from "vue";
var CollapsibleTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent8({
  __name: "CollapsibleTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectCollapsibleRootContext();
    return (_ctx, _cache) => {
      return openBlock3(), createBlock3(unref6(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props2.asChild,
        "aria-controls": unref6(rootContext).contentId,
        "aria-expanded": unref6(rootContext).open.value,
        "data-state": unref6(rootContext).open.value ? "open" : "closed",
        "data-disabled": unref6(rootContext).disabled?.value ? "" : void 0,
        disabled: unref6(rootContext).disabled?.value,
        onClick: unref6(rootContext).onOpenToggle
      }, {
        default: withCtx3(() => [renderSlot4(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "as",
        "as-child",
        "aria-controls",
        "aria-expanded",
        "data-state",
        "data-disabled",
        "disabled",
        "onClick"
      ]);
    };
  }
});
var CollapsibleTrigger_default = CollapsibleTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/shared/useSingleOrMultipleValue.js
import { computed as computed15 } from "vue";
function validateProps({ type, defaultValue, modelValue }) {
  const value = modelValue || defaultValue;
  const canTypeBeInferred = modelValue !== void 0 || defaultValue !== void 0;
  if (canTypeBeInferred) return Array.isArray(value) ? "multiple" : "single";
  else return type ?? "single";
}
function getDefaultType({ type, defaultValue, modelValue }) {
  if (type) return type;
  return validateProps({
    type,
    defaultValue,
    modelValue
  });
}
function getDefaultValue({ type, defaultValue }) {
  if (defaultValue !== void 0) return defaultValue;
  return type === "single" ? void 0 : [];
}
function useSingleOrMultipleValue(props2, emits) {
  const type = computed15(() => getDefaultType(props2));
  const modelValue = useVModel(props2, "modelValue", emits, {
    defaultValue: getDefaultValue(props2),
    passive: props2.modelValue === void 0,
    deep: true
  });
  function changeModelValue(value) {
    if (type.value === "single") modelValue.value = isEqual(value, modelValue.value) ? void 0 : value;
    else {
      const modelValueArray = Array.isArray(modelValue.value) ? [...modelValue.value || []] : [modelValue.value].filter(Boolean);
      if (isValueEqualOrExist(modelValueArray, value)) {
        const index = modelValueArray.findIndex((i) => isEqual(i, value));
        modelValueArray.splice(index, 1);
      } else modelValueArray.push(value);
      modelValue.value = modelValueArray;
    }
  }
  const isSingle = computed15(() => type.value === "single");
  return {
    modelValue,
    changeModelValue,
    isSingle
  };
}

// node_modules/reka-ui/dist/Accordion/AccordionRoot.js
import { createBlock as createBlock4, defineComponent as defineComponent9, openBlock as openBlock4, renderSlot as renderSlot5, toRefs as toRefs5, unref as unref7, withCtx as withCtx4 } from "vue";
var [injectAccordionRootContext, provideAccordionRootContext] = createContext("AccordionRoot");
var AccordionRoot_vue_vue_type_script_setup_true_lang_default = defineComponent9({
  __name: "AccordionRoot",
  props: {
    collapsible: {
      type: Boolean,
      required: false,
      default: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    dir: {
      type: String,
      required: false
    },
    orientation: {
      type: String,
      required: false,
      default: "vertical"
    },
    unmountOnHide: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    type: {
      type: String,
      required: false
    },
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { dir, disabled, unmountOnHide } = toRefs5(props2);
    const direction = useDirection(dir);
    const { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props2, emits);
    const { forwardRef, currentElement: parentElement } = useForwardExpose();
    provideAccordionRootContext({
      disabled,
      direction,
      orientation: props2.orientation,
      parentElement,
      isSingle,
      collapsible: props2.collapsible,
      modelValue,
      changeModelValue,
      unmountOnHide
    });
    return (_ctx, _cache) => {
      return openBlock4(), createBlock4(unref7(Primitive), {
        ref: unref7(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx4(() => [renderSlot5(_ctx.$slots, "default", { modelValue: unref7(modelValue) })]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
var AccordionRoot_default = AccordionRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Accordion/AccordionItem.js
import { computed as computed16, createBlock as createBlock5, defineComponent as defineComponent10, openBlock as openBlock5, renderSlot as renderSlot6, unref as unref8, withCtx as withCtx5, withKeys } from "vue";
var AccordionItemState = (function(AccordionItemState$1) {
  AccordionItemState$1["Open"] = "open";
  AccordionItemState$1["Closed"] = "closed";
  return AccordionItemState$1;
})(AccordionItemState || {});
var [injectAccordionItemContext, provideAccordionItemContext] = createContext("AccordionItem");
var AccordionItem_vue_vue_type_script_setup_true_lang_default = defineComponent10({
  __name: "AccordionItem",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    value: {
      type: String,
      required: true
    },
    unmountOnHide: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props, { expose: __expose }) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const open = computed16(() => rootContext.isSingle.value ? props2.value === rootContext.modelValue.value : Array.isArray(rootContext.modelValue.value) && rootContext.modelValue.value.includes(props2.value));
    const disabled = computed16(() => {
      return rootContext.disabled.value || props2.disabled;
    });
    const dataDisabled = computed16(() => disabled.value ? "" : void 0);
    const dataState = computed16(() => open.value ? AccordionItemState.Open : AccordionItemState.Closed);
    __expose({
      open,
      dataDisabled
    });
    const { currentRef, currentElement } = useForwardExpose();
    provideAccordionItemContext({
      open,
      dataState,
      disabled,
      dataDisabled,
      triggerId: "",
      currentRef,
      currentElement,
      value: computed16(() => props2.value)
    });
    function handleArrowKey(e) {
      const target = e.target;
      const allCollectionItems = Array.from(rootContext.parentElement.value?.querySelectorAll("[data-reka-collection-item]") ?? []);
      const collectionItemIndex = allCollectionItems.findIndex((item) => item === target);
      if (collectionItemIndex === -1) return null;
      useArrowNavigation(e, target, rootContext.parentElement.value, {
        arrowKeyOptions: rootContext.orientation,
        dir: rootContext.direction.value,
        focus: true
      });
    }
    return (_ctx, _cache) => {
      return openBlock5(), createBlock5(unref8(CollapsibleRoot_default), {
        "data-orientation": unref8(rootContext).orientation,
        "data-disabled": dataDisabled.value,
        "data-state": dataState.value,
        disabled: disabled.value,
        open: open.value,
        as: props2.as,
        "as-child": props2.asChild,
        "unmount-on-hide": unref8(rootContext).unmountOnHide.value,
        onKeydown: withKeys(handleArrowKey, [
          "up",
          "down",
          "left",
          "right",
          "home",
          "end"
        ])
      }, {
        default: withCtx5(() => [renderSlot6(_ctx.$slots, "default", { open: open.value })]),
        _: 3
      }, 8, [
        "data-orientation",
        "data-disabled",
        "data-state",
        "disabled",
        "open",
        "as",
        "as-child",
        "unmount-on-hide"
      ]);
    };
  }
});
var AccordionItem_default = AccordionItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Accordion/AccordionContent.js
import { createBlock as createBlock6, defineComponent as defineComponent11, openBlock as openBlock6, renderSlot as renderSlot7, unref as unref9, withCtx as withCtx6 } from "vue";
var AccordionContent_vue_vue_type_script_setup_true_lang_default = defineComponent11({
  __name: "AccordionContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock6(), createBlock6(unref9(CollapsibleContent_default), {
        role: "region",
        "as-child": props2.asChild,
        as: _ctx.as,
        "force-mount": props2.forceMount,
        "aria-labelledby": unref9(itemContext).triggerId,
        "data-state": unref9(itemContext).dataState.value,
        "data-disabled": unref9(itemContext).dataDisabled.value,
        "data-orientation": unref9(rootContext).orientation,
        style: {
          "--reka-accordion-content-width": "var(--reka-collapsible-content-width)",
          "--reka-accordion-content-height": "var(--reka-collapsible-content-height)"
        },
        onContentFound: _cache[0] || (_cache[0] = ($event) => unref9(rootContext).changeModelValue(unref9(itemContext).value.value))
      }, {
        default: withCtx6(() => [renderSlot7(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "force-mount",
        "aria-labelledby",
        "data-state",
        "data-disabled",
        "data-orientation"
      ]);
    };
  }
});
var AccordionContent_default = AccordionContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Accordion/AccordionHeader.js
import { createBlock as createBlock7, defineComponent as defineComponent12, openBlock as openBlock7, renderSlot as renderSlot8, unref as unref10, withCtx as withCtx7 } from "vue";
var AccordionHeader_vue_vue_type_script_setup_true_lang_default = defineComponent12({
  __name: "AccordionHeader",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "h3"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock7(), createBlock7(unref10(Primitive), {
        as: props2.as,
        "as-child": props2.asChild,
        "data-orientation": unref10(rootContext).orientation,
        "data-state": unref10(itemContext).dataState.value,
        "data-disabled": unref10(itemContext).dataDisabled.value
      }, {
        default: withCtx7(() => [renderSlot8(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-orientation",
        "data-state",
        "data-disabled"
      ]);
    };
  }
});
var AccordionHeader_default = AccordionHeader_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Accordion/AccordionTrigger.js
import { createBlock as createBlock8, defineComponent as defineComponent13, openBlock as openBlock8, renderSlot as renderSlot9, unref as unref11, withCtx as withCtx8 } from "vue";
var AccordionTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent13({
  __name: "AccordionTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAccordionRootContext();
    const itemContext = injectAccordionItemContext();
    itemContext.triggerId ||= useId2(void 0, "reka-accordion-trigger");
    function changeItem() {
      const triggerDisabled = rootContext.isSingle.value && itemContext.open.value && !rootContext.collapsible;
      if (itemContext.disabled.value || triggerDisabled) return;
      rootContext.changeModelValue(itemContext.value.value);
    }
    return (_ctx, _cache) => {
      return openBlock8(), createBlock8(unref11(CollapsibleTrigger_default), {
        id: unref11(itemContext).triggerId,
        ref: unref11(itemContext).currentRef,
        "data-reka-collection-item": "",
        as: props2.as,
        "as-child": props2.asChild,
        "aria-disabled": unref11(itemContext).disabled.value || void 0,
        "aria-expanded": unref11(itemContext).open.value || false,
        "data-disabled": unref11(itemContext).dataDisabled.value,
        "data-orientation": unref11(rootContext).orientation,
        "data-state": unref11(itemContext).dataState.value,
        disabled: unref11(itemContext).disabled.value,
        onClick: changeItem
      }, {
        default: withCtx8(() => [renderSlot9(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "as",
        "as-child",
        "aria-disabled",
        "aria-expanded",
        "data-disabled",
        "data-orientation",
        "data-state",
        "disabled"
      ]);
    };
  }
});
var AccordionTrigger_default = AccordionTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogRoot.js
import { defineComponent as defineComponent14, ref as ref16, renderSlot as renderSlot10, toRefs as toRefs6, unref as unref12 } from "vue";
var [injectDialogRootContext, provideDialogRootContext] = createContext("DialogRoot");
var DialogRoot_vue_vue_type_script_setup_true_lang_default = defineComponent14({
  inheritAttrs: false,
  __name: "DialogRoot",
  props: {
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: false,
      default: false
    },
    modal: {
      type: Boolean,
      required: false,
      default: true
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref16();
    const contentElement = ref16();
    const { modal } = toRefs6(props2);
    provideDialogRootContext({
      open,
      modal,
      openModal: () => {
        open.value = true;
      },
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement,
      contentElement
    });
    return (_ctx, _cache) => {
      return renderSlot10(_ctx.$slots, "default", {
        open: unref12(open),
        close: () => open.value = false
      });
    };
  }
});
var DialogRoot_default = DialogRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogClose.js
import { createBlock as createBlock9, defineComponent as defineComponent15, mergeProps as mergeProps4, openBlock as openBlock9, renderSlot as renderSlot11, unref as unref13, withCtx as withCtx9 } from "vue";
var DialogClose_vue_vue_type_script_setup_true_lang_default = defineComponent15({
  __name: "DialogClose",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectDialogRootContext();
    return (_ctx, _cache) => {
      return openBlock9(), createBlock9(unref13(Primitive), mergeProps4(props2, {
        type: _ctx.as === "button" ? "button" : void 0,
        onClick: _cache[0] || (_cache[0] = ($event) => unref13(rootContext).onOpenChange(false))
      }), {
        default: withCtx9(() => [renderSlot11(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["type"]);
    };
  }
});
var DialogClose_default = DialogClose_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DismissableLayer/utils.js
import { nextTick as nextTick6, ref as ref17, toValue as toValue3, watchEffect as watchEffect5 } from "vue";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
function isLayerExist(layerElement, targetElement) {
  const targetLayer = targetElement.closest("[data-dismissable-layer]");
  const mainLayer = layerElement.dataset.dismissableLayer === "" ? layerElement : layerElement.querySelector("[data-dismissable-layer]");
  const nodeList = Array.from(layerElement.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
  if (targetLayer && (mainLayer === targetLayer || nodeList.indexOf(mainLayer) < nodeList.indexOf(targetLayer))) return true;
  else return false;
}
function usePointerDownOutside(onPointerDownOutside, element, enabled = true) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isPointerInsideDOMTree = ref17(false);
  const handleClickRef = ref17(() => {
  });
  watchEffect5((cleanupFn) => {
    if (!isClient || !toValue3(enabled)) return;
    const handlePointerDown2 = async (event) => {
      const target = event.target;
      if (!element?.value || !target) return;
      if (isLayerExist(element.value, target)) {
        isPointerInsideDOMTree.value = false;
        return;
      }
      if (event.target && !isPointerInsideDOMTree.value) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, onPointerDownOutside, eventDetail);
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.value);
          handleClickRef.value = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.value, { once: true });
        } else handleAndDispatchPointerDownOutsideEvent();
      } else ownerDocument.removeEventListener("click", handleClickRef.value);
      isPointerInsideDOMTree.value = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown2);
    }, 0);
    cleanupFn(() => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown2);
      ownerDocument.removeEventListener("click", handleClickRef.value);
    });
  });
  return { onPointerDownCapture: () => {
    if (!toValue3(enabled)) return;
    isPointerInsideDOMTree.value = true;
  } };
}
function useFocusOutside(onFocusOutside, element, enabled = true) {
  const ownerDocument = element?.value?.ownerDocument ?? globalThis?.document;
  const isFocusInsideDOMTree = ref17(false);
  watchEffect5((cleanupFn) => {
    if (!isClient || !toValue3(enabled)) return;
    const handleFocus = async (event) => {
      if (!element?.value) return;
      await nextTick6();
      await nextTick6();
      const target = event.target;
      if (!element.value || !target || isLayerExist(element.value, target)) return;
      if (event.target && !isFocusInsideDOMTree.value) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, onFocusOutside, eventDetail);
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    cleanupFn(() => ownerDocument.removeEventListener("focusin", handleFocus));
  });
  return {
    onFocusCapture: () => {
      if (!toValue3(enabled)) return;
      isFocusInsideDOMTree.value = true;
    },
    onBlurCapture: () => {
      if (!toValue3(enabled)) return;
      isFocusInsideDOMTree.value = false;
    }
  };
}

// node_modules/reka-ui/dist/DismissableLayer/DismissableLayer.js
import { computed as computed17, createBlock as createBlock10, defineComponent as defineComponent16, nextTick as nextTick7, normalizeStyle, openBlock as openBlock10, reactive as reactive3, renderSlot as renderSlot12, unref as unref14, watchEffect as watchEffect6, withCtx as withCtx10 } from "vue";
var context = reactive3({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer_vue_vue_type_script_setup_true_lang_default = defineComponent16({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "dismiss"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement: layerElement } = useForwardExpose();
    const ownerDocument = computed17(() => layerElement.value?.ownerDocument ?? globalThis.document);
    const layers = computed17(() => context.layersRoot);
    const index = computed17(() => {
      return layerElement.value ? Array.from(layers.value).indexOf(layerElement.value) : -1;
    });
    const isBodyPointerEventsDisabled = computed17(() => {
      return context.layersWithOutsidePointerEventsDisabled.size > 0;
    });
    const isPointerEventsEnabled = computed17(() => {
      const localLayers = Array.from(layers.value);
      const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
      const highestLayerWithOutsidePointerEventsDisabledIndex = localLayers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
      return index.value >= highestLayerWithOutsidePointerEventsDisabledIndex;
    });
    const pointerDownOutside = usePointerDownOutside(async (event) => {
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch?.contains(event.target));
      if (!isPointerEventsEnabled.value || isPointerDownOnBranch) return;
      emits("pointerDownOutside", event);
      emits("interactOutside", event);
      await nextTick7();
      if (!event.defaultPrevented) emits("dismiss");
    }, layerElement);
    const focusOutside = useFocusOutside((event) => {
      const isFocusInBranch = [...context.branches].some((branch) => branch?.contains(event.target));
      if (isFocusInBranch) return;
      emits("focusOutside", event);
      emits("interactOutside", event);
      if (!event.defaultPrevented) emits("dismiss");
    }, layerElement);
    onKeyStroke("Escape", (event) => {
      const isHighestLayer = index.value === layers.value.size - 1;
      if (!isHighestLayer) return;
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented) emits("dismiss");
    });
    let originalBodyPointerEvents;
    watchEffect6((cleanupFn) => {
      if (!layerElement.value) return;
      if (props2.disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.value.body.style.pointerEvents;
          ownerDocument.value.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(layerElement.value);
      }
      layers.value.add(layerElement.value);
      cleanupFn(() => {
        if (props2.disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) ownerDocument.value.body.style.pointerEvents = originalBodyPointerEvents;
      });
    });
    watchEffect6((cleanupFn) => {
      cleanupFn(() => {
        if (!layerElement.value) return;
        layers.value.delete(layerElement.value);
        context.layersWithOutsidePointerEventsDisabled.delete(layerElement.value);
      });
    });
    return (_ctx, _cache) => {
      return openBlock10(), createBlock10(unref14(Primitive), {
        ref: unref14(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-dismissable-layer": "",
        style: normalizeStyle({ pointerEvents: isBodyPointerEventsDisabled.value ? isPointerEventsEnabled.value ? "auto" : "none" : void 0 }),
        onFocusCapture: unref14(focusOutside).onFocusCapture,
        onBlurCapture: unref14(focusOutside).onBlurCapture,
        onPointerdownCapture: unref14(pointerDownOutside).onPointerDownCapture
      }, {
        default: withCtx10(() => [renderSlot12(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "style",
        "onFocusCapture",
        "onBlurCapture",
        "onPointerdownCapture"
      ]);
    };
  }
});
var DismissableLayer_default = DismissableLayer_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DismissableLayer/DismissableLayerBranch.js
import { createBlock as createBlock11, defineComponent as defineComponent17, mergeProps as mergeProps5, onMounted as onMounted5, onUnmounted as onUnmounted4, openBlock as openBlock11, renderSlot as renderSlot13, unref as unref15, withCtx as withCtx11 } from "vue";
var DismissableLayerBranch_vue_vue_type_script_setup_true_lang_default = defineComponent17({
  __name: "DismissableLayerBranch",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted5(() => {
      context.branches.add(currentElement.value);
    });
    onUnmounted4(() => {
      context.branches.delete(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock11(), createBlock11(unref15(Primitive), mergeProps5({ ref: unref15(forwardRef) }, props2), {
        default: withCtx11(() => [renderSlot13(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DismissableLayerBranch_default = DismissableLayerBranch_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/FocusScope/stack.js
import { ref as ref18 } from "vue";
var useFocusStackState = createGlobalState(() => {
  const stack = ref18([]);
  return stack;
});
function createFocusScopesStack() {
  const stack = useFocusStackState();
  return {
    add(focusScope) {
      const activeFocusScope = stack.value[0];
      if (focusScope !== activeFocusScope) activeFocusScope?.pause();
      stack.value = arrayRemove(stack.value, focusScope);
      stack.value.unshift(focusScope);
    },
    remove(focusScope) {
      stack.value = arrayRemove(stack.value, focusScope);
      stack.value[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) updatedArray.splice(index, 1);
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

// node_modules/reka-ui/dist/FocusScope/utils.js
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = getActiveElement();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement() !== previouslyFocusedElement) return true;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
    const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
    if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
    return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) if (!isHidden(element, { upTo: container })) return element;
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = getActiveElement();
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) element.select();
  }
}

// node_modules/reka-ui/dist/FocusScope/FocusScope.js
import { createBlock as createBlock12, defineComponent as defineComponent18, nextTick as nextTick8, openBlock as openBlock12, reactive as reactive4, ref as ref19, renderSlot as renderSlot14, unref as unref16, watchEffect as watchEffect7, withCtx as withCtx12 } from "vue";
var FocusScope_vue_vue_type_script_setup_true_lang_default = defineComponent18({
  __name: "FocusScope",
  props: {
    loop: {
      type: Boolean,
      required: false,
      default: false
    },
    trapped: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { currentRef, currentElement } = useForwardExpose();
    const lastFocusedElementRef = ref19(null);
    const focusScopesStack = createFocusScopesStack();
    const focusScope = reactive4({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    });
    watchEffect7((cleanupFn) => {
      if (!isClient) return;
      const container = currentElement.value;
      if (!props2.trapped) return;
      function handleFocusIn(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) lastFocusedElementRef.value = target;
        else focus(lastFocusedElementRef.value, { select: true });
      }
      function handleFocusOut(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) focus(lastFocusedElementRef.value, { select: true });
      }
      function handleMutations(mutations) {
        const isLastFocusedElementExist = container.contains(lastFocusedElementRef.value);
        if (!isLastFocusedElementExist) focus(container);
      }
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      const mutationObserver = new MutationObserver(handleMutations);
      if (container) mutationObserver.observe(container, {
        childList: true,
        subtree: true
      });
      cleanupFn(() => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
        mutationObserver.disconnect();
      });
    });
    watchEffect7(async (cleanupFn) => {
      const container = currentElement.value;
      await nextTick8();
      if (!container) return;
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = getActiveElement();
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (getActiveElement() === previouslyFocusedElement) focus(container);
        }
      }
      cleanupFn(() => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
        const unmountEventHandler = (ev) => {
          emits("unmountAutoFocus", ev);
        };
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
        container.dispatchEvent(unmountEvent);
        setTimeout(() => {
          if (!unmountEvent.defaultPrevented) focus(previouslyFocusedElement ?? document.body, { select: true });
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
          focusScopesStack.remove(focusScope);
        }, 0);
      });
    });
    function handleKeyDown(event) {
      if (!props2.loop && !props2.trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = getActiveElement();
      if (isTabKey && focusedElement) {
        const container = event.currentTarget;
        const [first, last] = getTabbableEdges(container);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container) event.preventDefault();
        } else if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (props2.loop) focus(first, { select: true });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (props2.loop) focus(last, { select: true });
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock12(), createBlock12(unref16(Primitive), {
        ref_key: "currentRef",
        ref: currentRef,
        tabindex: "-1",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        onKeydown: handleKeyDown
      }, {
        default: withCtx12(() => [renderSlot14(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
var FocusScope_default = FocusScope_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/utils.js
var ITEM_SELECT = "menu.itemSelect";
var SELECTION_KEYS = ["Enter", " "];
var FIRST_KEYS = [
  "ArrowDown",
  "PageUp",
  "Home"
];
var LAST_KEYS = [
  "ArrowUp",
  "PageDown",
  "End"
];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst2(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function isPointInPolygon2(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = {
    x: event.clientX,
    y: event.clientY
  };
  return isPointInPolygon2(cursorPos, area);
}
function isMouseEvent(event) {
  return event.pointerType === "mouse";
}

// node_modules/reka-ui/dist/Dialog/utils.js
import { onMounted as onMounted6 } from "vue";
var DEFAULT_TITLE_NAME = "DialogTitle";
var DEFAULT_CONTENT_NAME = "DialogContent";
function useWarning({ titleName = DEFAULT_TITLE_NAME, contentName = DEFAULT_CONTENT_NAME, componentLink = "dialog.html#title", titleId, descriptionId, contentElement }) {
  const TITLE_MESSAGE = `Warning: \`${contentName}\` requires a \`${titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${componentLink}`;
  const DESCRIPTION_MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${contentName}.`;
  onMounted6(() => {
    const hasTitle = document.getElementById(titleId);
    if (!hasTitle) console.warn(TITLE_MESSAGE);
    const describedById = contentElement.value?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(DESCRIPTION_MESSAGE);
    }
  });
}

// node_modules/reka-ui/dist/Dialog/DialogContentImpl.js
import { createBlock as createBlock13, createVNode as createVNode2, defineComponent as defineComponent19, mergeProps as mergeProps6, onMounted as onMounted7, openBlock as openBlock13, renderSlot as renderSlot15, unref as unref17, withCtx as withCtx13 } from "vue";
var DialogContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent19({
  __name: "DialogContentImpl",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    trapFocus: {
      type: Boolean,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectDialogRootContext();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    rootContext.titleId ||= useId2(void 0, "reka-dialog-title");
    rootContext.descriptionId ||= useId2(void 0, "reka-dialog-description");
    onMounted7(() => {
      rootContext.contentElement = contentElement;
      if (getActiveElement() !== document.body) rootContext.triggerElement.value = getActiveElement();
    });
    if (true) useWarning({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: rootContext.titleId,
      descriptionId: rootContext.descriptionId,
      contentElement
    });
    return (_ctx, _cache) => {
      return openBlock13(), createBlock13(unref17(FocusScope_default), {
        "as-child": "",
        loop: "",
        trapped: props2.trapFocus,
        onMountAutoFocus: _cache[5] || (_cache[5] = ($event) => emits("openAutoFocus", $event)),
        onUnmountAutoFocus: _cache[6] || (_cache[6] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx13(() => [createVNode2(unref17(DismissableLayer_default), mergeProps6({
          id: unref17(rootContext).contentId,
          ref: unref17(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": unref17(rootContext).descriptionId,
          "aria-labelledby": unref17(rootContext).titleId,
          "data-state": unref17(getOpenState)(unref17(rootContext).open.value)
        }, _ctx.$attrs, {
          onDismiss: _cache[0] || (_cache[0] = ($event) => unref17(rootContext).onOpenChange(false)),
          onEscapeKeyDown: _cache[1] || (_cache[1] = ($event) => emits("escapeKeyDown", $event)),
          onFocusOutside: _cache[2] || (_cache[2] = ($event) => emits("focusOutside", $event)),
          onInteractOutside: _cache[3] || (_cache[3] = ($event) => emits("interactOutside", $event)),
          onPointerDownOutside: _cache[4] || (_cache[4] = ($event) => emits("pointerDownOutside", $event))
        }), {
          default: withCtx13(() => [renderSlot15(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "as",
          "as-child",
          "disable-outside-pointer-events",
          "aria-describedby",
          "aria-labelledby",
          "data-state"
        ])]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});
var DialogContentImpl_default = DialogContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogContentModal.js
import { createBlock as createBlock14, defineComponent as defineComponent20, mergeProps as mergeProps7, openBlock as openBlock14, renderSlot as renderSlot16, unref as unref18, withCtx as withCtx14 } from "vue";
var DialogContentModal_vue_vue_type_script_setup_true_lang_default = defineComponent20({
  __name: "DialogContentModal",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    trapFocus: {
      type: Boolean,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectDialogRootContext();
    const emitsAsProps = useEmitAsProps(emits);
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock14(), createBlock14(DialogContentImpl_default, mergeProps7({
        ...props2,
        ...unref18(emitsAsProps)
      }, {
        ref: unref18(forwardRef),
        "trap-focus": unref18(rootContext).open.value,
        "disable-outside-pointer-events": true,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          if (!event.defaultPrevented) {
            event.preventDefault();
            unref18(rootContext).triggerElement.value?.focus();
          }
        }),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: _cache[2] || (_cache[2] = (event) => {
          event.preventDefault();
        })
      }), {
        default: withCtx14(() => [renderSlot16(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
});
var DialogContentModal_default = DialogContentModal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogContentNonModal.js
import { createBlock as createBlock15, defineComponent as defineComponent21, mergeProps as mergeProps8, openBlock as openBlock15, ref as ref20, renderSlot as renderSlot17, unref as unref19, withCtx as withCtx15 } from "vue";
var DialogContentNonModal_vue_vue_type_script_setup_true_lang_default = defineComponent21({
  __name: "DialogContentNonModal",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    trapFocus: {
      type: Boolean,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    const rootContext = injectDialogRootContext();
    const hasInteractedOutsideRef = ref20(false);
    const hasPointerDownOutsideRef = ref20(false);
    return (_ctx, _cache) => {
      return openBlock15(), createBlock15(DialogContentImpl_default, mergeProps8({
        ...props2,
        ...unref19(emitsAsProps)
      }, {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.value) unref19(rootContext).triggerElement.value?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.value = false;
          hasPointerDownOutsideRef.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = (event) => {
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.value = true;
            if (event.detail.originalEvent.type === "pointerdown") hasPointerDownOutsideRef.value = true;
          }
          const target = event.target;
          const targetIsTrigger = unref19(rootContext).triggerElement.value?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) event.preventDefault();
        })
      }), {
        default: withCtx15(() => [renderSlot17(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DialogContentNonModal_default = DialogContentNonModal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogContent.js
import { createBlock as createBlock16, createCommentVNode as createCommentVNode2, defineComponent as defineComponent22, mergeProps as mergeProps9, openBlock as openBlock16, renderSlot as renderSlot18, unref as unref20, withCtx as withCtx16 } from "vue";
var DialogContent_vue_vue_type_script_setup_true_lang_default = defineComponent22({
  __name: "DialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectDialogRootContext();
    const emitsAsProps = useEmitAsProps(emits);
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock16(), createBlock16(unref20(Presence_default), { present: _ctx.forceMount || unref20(rootContext).open.value }, {
        default: withCtx16(() => [unref20(rootContext).modal.value ? (openBlock16(), createBlock16(DialogContentModal_default, mergeProps9({
          key: 0,
          ref: unref20(forwardRef)
        }, {
          ...props2,
          ...unref20(emitsAsProps),
          ..._ctx.$attrs
        }), {
          default: withCtx16(() => [renderSlot18(_ctx.$slots, "default")]),
          _: 3
        }, 16)) : (openBlock16(), createBlock16(DialogContentNonModal_default, mergeProps9({
          key: 1,
          ref: unref20(forwardRef)
        }, {
          ...props2,
          ...unref20(emitsAsProps),
          ..._ctx.$attrs
        }), {
          default: withCtx16(() => [renderSlot18(_ctx.$slots, "default")]),
          _: 3
        }, 16))]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var DialogContent_default = DialogContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogDescription.js
import { createBlock as createBlock17, defineComponent as defineComponent23, mergeProps as mergeProps10, openBlock as openBlock17, renderSlot as renderSlot19, unref as unref21, withCtx as withCtx17 } from "vue";
var DialogDescription_vue_vue_type_script_setup_true_lang_default = defineComponent23({
  __name: "DialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "p"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectDialogRootContext();
    return (_ctx, _cache) => {
      return openBlock17(), createBlock17(unref21(Primitive), mergeProps10(props2, { id: unref21(rootContext).descriptionId }), {
        default: withCtx17(() => [renderSlot19(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var DialogDescription_default = DialogDescription_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogOverlayImpl.js
import { createBlock as createBlock18, defineComponent as defineComponent24, openBlock as openBlock18, renderSlot as renderSlot20, unref as unref22, withCtx as withCtx18 } from "vue";
var DialogOverlayImpl_vue_vue_type_script_setup_true_lang_default = defineComponent24({
  __name: "DialogOverlayImpl",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const rootContext = injectDialogRootContext();
    useBodyScrollLock(true);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock18(), createBlock18(unref22(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-state": unref22(rootContext).open.value ? "open" : "closed",
        style: { "pointer-events": "auto" }
      }, {
        default: withCtx18(() => [renderSlot20(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-state"
      ]);
    };
  }
});
var DialogOverlayImpl_default = DialogOverlayImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogOverlay.js
import { createBlock as createBlock19, createCommentVNode as createCommentVNode3, createVNode as createVNode3, defineComponent as defineComponent25, mergeProps as mergeProps11, openBlock as openBlock19, renderSlot as renderSlot21, unref as unref23, withCtx as withCtx19 } from "vue";
var DialogOverlay_vue_vue_type_script_setup_true_lang_default = defineComponent25({
  __name: "DialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const rootContext = injectDialogRootContext();
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return unref23(rootContext)?.modal.value ? (openBlock19(), createBlock19(unref23(Presence_default), {
        key: 0,
        present: _ctx.forceMount || unref23(rootContext).open.value
      }, {
        default: withCtx19(() => [createVNode3(DialogOverlayImpl_default, mergeProps11(_ctx.$attrs, {
          ref: unref23(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild
        }), {
          default: withCtx19(() => [renderSlot21(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["as", "as-child"])]),
        _: 3
      }, 8, ["present"])) : createCommentVNode3("v-if", true);
    };
  }
});
var DialogOverlay_default = DialogOverlay_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Teleport/Teleport.js
import { Teleport, createBlock as createBlock20, createCommentVNode as createCommentVNode4, defineComponent as defineComponent26, openBlock as openBlock20, renderSlot as renderSlot22, unref as unref24 } from "vue";
var Teleport_vue_vue_type_script_setup_true_lang_default = defineComponent26({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: false,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const isMounted = useMounted();
    return (_ctx, _cache) => {
      return unref24(isMounted) || _ctx.forceMount ? (openBlock20(), createBlock20(Teleport, {
        key: 0,
        to: _ctx.to,
        disabled: _ctx.disabled,
        defer: _ctx.defer
      }, [renderSlot22(_ctx.$slots, "default")], 8, [
        "to",
        "disabled",
        "defer"
      ])) : createCommentVNode4("v-if", true);
    };
  }
});
var Teleport_default = Teleport_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogPortal.js
import { createBlock as createBlock21, defineComponent as defineComponent27, guardReactiveProps, normalizeProps, openBlock as openBlock21, renderSlot as renderSlot23, unref as unref25, withCtx as withCtx20 } from "vue";
var DialogPortal_vue_vue_type_script_setup_true_lang_default = defineComponent27({
  __name: "DialogPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock21(), createBlock21(unref25(Teleport_default), normalizeProps(guardReactiveProps(props2)), {
        default: withCtx20(() => [renderSlot23(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DialogPortal_default = DialogPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogTitle.js
import { createBlock as createBlock22, defineComponent as defineComponent28, mergeProps as mergeProps12, openBlock as openBlock22, renderSlot as renderSlot24, unref as unref26, withCtx as withCtx21 } from "vue";
var DialogTitle_vue_vue_type_script_setup_true_lang_default = defineComponent28({
  __name: "DialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "h2"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDialogRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock22(), createBlock22(unref26(Primitive), mergeProps12(props2, { id: unref26(rootContext).titleId }), {
        default: withCtx21(() => [renderSlot24(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var DialogTitle_default = DialogTitle_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Dialog/DialogTrigger.js
import { createBlock as createBlock23, defineComponent as defineComponent29, mergeProps as mergeProps13, onMounted as onMounted8, openBlock as openBlock23, renderSlot as renderSlot25, unref as unref27, withCtx as withCtx22 } from "vue";
var DialogTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent29({
  __name: "DialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDialogRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    rootContext.contentId ||= useId2(void 0, "reka-dialog-content");
    onMounted8(() => {
      rootContext.triggerElement.value = currentElement.value;
    });
    return (_ctx, _cache) => {
      return openBlock23(), createBlock23(unref27(Primitive), mergeProps13(props2, {
        ref: unref27(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-haspopup": "dialog",
        "aria-expanded": unref27(rootContext).open.value || false,
        "aria-controls": unref27(rootContext).open.value ? unref27(rootContext).contentId : void 0,
        "data-state": unref27(rootContext).open.value ? "open" : "closed",
        onClick: unref27(rootContext).onOpenToggle
      }), {
        default: withCtx22(() => [renderSlot25(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "type",
        "aria-expanded",
        "aria-controls",
        "data-state",
        "onClick"
      ]);
    };
  }
});
var DialogTrigger_default = DialogTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogAction.js
import { createBlock as createBlock24, defineComponent as defineComponent30, guardReactiveProps as guardReactiveProps2, normalizeProps as normalizeProps2, openBlock as openBlock24, renderSlot as renderSlot26, unref as unref28, withCtx as withCtx23 } from "vue";
var AlertDialogAction_vue_vue_type_script_setup_true_lang_default = defineComponent30({
  __name: "AlertDialogAction",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock24(), createBlock24(unref28(DialogClose_default), normalizeProps2(guardReactiveProps2(props2)), {
        default: withCtx23(() => [renderSlot26(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogAction_default = AlertDialogAction_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogContent.js
import { createBlock as createBlock25, defineComponent as defineComponent31, mergeProps as mergeProps14, nextTick as nextTick9, openBlock as openBlock25, ref as ref21, renderSlot as renderSlot27, unref as unref29, withCtx as withCtx24, withModifiers } from "vue";
var [injectAlertDialogContentContext, provideAlertDialogContentContext] = createContext("AlertDialogContent");
var AlertDialogContent_vue_vue_type_script_setup_true_lang_default = defineComponent31({
  __name: "AlertDialogContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    const cancelElement = ref21();
    provideAlertDialogContentContext({ onCancelElementChange: (el) => {
      cancelElement.value = el;
    } });
    return (_ctx, _cache) => {
      return openBlock25(), createBlock25(unref29(DialogContent_default), mergeProps14({
        ...props2,
        ...unref29(emitsAsProps)
      }, {
        role: "alertdialog",
        onPointerDownOutside: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["prevent"])),
        onInteractOutside: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onOpenAutoFocus: _cache[2] || (_cache[2] = () => {
          nextTick9(() => {
            cancelElement.value?.focus({ preventScroll: true });
          });
        })
      }), {
        default: withCtx24(() => [renderSlot27(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogContent_default = AlertDialogContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogCancel.js
import { createBlock as createBlock26, defineComponent as defineComponent32, mergeProps as mergeProps15, onMounted as onMounted9, openBlock as openBlock26, renderSlot as renderSlot28, unref as unref30, withCtx as withCtx25 } from "vue";
var AlertDialogCancel_vue_vue_type_script_setup_true_lang_default = defineComponent32({
  __name: "AlertDialogCancel",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const contentContext = injectAlertDialogContentContext();
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted9(() => {
      contentContext.onCancelElementChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock26(), createBlock26(unref30(DialogClose_default), mergeProps15(props2, { ref: unref30(forwardRef) }), {
        default: withCtx25(() => [renderSlot28(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogCancel_default = AlertDialogCancel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogDescription.js
import { createBlock as createBlock27, defineComponent as defineComponent33, guardReactiveProps as guardReactiveProps3, normalizeProps as normalizeProps3, openBlock as openBlock27, renderSlot as renderSlot29, unref as unref31, withCtx as withCtx26 } from "vue";
var AlertDialogDescription_vue_vue_type_script_setup_true_lang_default = defineComponent33({
  __name: "AlertDialogDescription",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "p"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock27(), createBlock27(unref31(DialogDescription_default), normalizeProps3(guardReactiveProps3(props2)), {
        default: withCtx26(() => [renderSlot29(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogDescription_default = AlertDialogDescription_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogOverlay.js
import { createBlock as createBlock28, defineComponent as defineComponent34, guardReactiveProps as guardReactiveProps4, normalizeProps as normalizeProps4, openBlock as openBlock28, renderSlot as renderSlot30, unref as unref32, withCtx as withCtx27 } from "vue";
var AlertDialogOverlay_vue_vue_type_script_setup_true_lang_default = defineComponent34({
  __name: "AlertDialogOverlay",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock28(), createBlock28(unref32(DialogOverlay_default), normalizeProps4(guardReactiveProps4(props2)), {
        default: withCtx27(() => [renderSlot30(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogOverlay_default = AlertDialogOverlay_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogPortal.js
import { createBlock as createBlock29, defineComponent as defineComponent35, guardReactiveProps as guardReactiveProps5, normalizeProps as normalizeProps5, openBlock as openBlock29, renderSlot as renderSlot31, unref as unref33, withCtx as withCtx28 } from "vue";
var AlertDialogPortal_vue_vue_type_script_setup_true_lang_default = defineComponent35({
  __name: "AlertDialogPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock29(), createBlock29(unref33(Teleport_default), normalizeProps5(guardReactiveProps5(props2)), {
        default: withCtx28(() => [renderSlot31(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogPortal_default = AlertDialogPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogRoot.js
import { createBlock as createBlock30, defineComponent as defineComponent36, guardReactiveProps as guardReactiveProps6, mergeProps as mergeProps16, normalizeProps as normalizeProps6, openBlock as openBlock30, renderSlot as renderSlot32, unref as unref34, withCtx as withCtx29 } from "vue";
var AlertDialogRoot_vue_vue_type_script_setup_true_lang_default = defineComponent36({
  __name: "AlertDialogRoot",
  props: {
    open: {
      type: Boolean,
      required: false
    },
    defaultOpen: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock30(), createBlock30(unref34(DialogRoot_default), mergeProps16(unref34(forwarded), { modal: true }), {
        default: withCtx29((slotProps) => [renderSlot32(_ctx.$slots, "default", normalizeProps6(guardReactiveProps6(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogRoot_default = AlertDialogRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogTitle.js
import { createBlock as createBlock31, defineComponent as defineComponent37, guardReactiveProps as guardReactiveProps7, normalizeProps as normalizeProps7, openBlock as openBlock31, renderSlot as renderSlot33, unref as unref35, withCtx as withCtx30 } from "vue";
var AlertDialogTitle_vue_vue_type_script_setup_true_lang_default = defineComponent37({
  __name: "AlertDialogTitle",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "h2"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock31(), createBlock31(unref35(DialogTitle_default), normalizeProps7(guardReactiveProps7(props2)), {
        default: withCtx30(() => [renderSlot33(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogTitle_default = AlertDialogTitle_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AlertDialog/AlertDialogTrigger.js
import { createBlock as createBlock32, defineComponent as defineComponent38, guardReactiveProps as guardReactiveProps8, normalizeProps as normalizeProps8, openBlock as openBlock32, renderSlot as renderSlot34, unref as unref36, withCtx as withCtx31 } from "vue";
var AlertDialogTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent38({
  __name: "AlertDialogTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock32(), createBlock32(unref36(DialogTrigger_default), normalizeProps8(guardReactiveProps8(props2)), {
        default: withCtx31(() => [renderSlot34(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var AlertDialogTrigger_default = AlertDialogTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/AspectRatio/AspectRatio.js
import { computed as computed18, createElementBlock, createVNode as createVNode4, defineComponent as defineComponent39, mergeProps as mergeProps17, normalizeStyle as normalizeStyle2, openBlock as openBlock33, renderSlot as renderSlot35, unref as unref37, withCtx as withCtx32 } from "vue";
var AspectRatio_vue_vue_type_script_setup_true_lang_default = defineComponent39({
  inheritAttrs: false,
  __name: "AspectRatio",
  props: {
    ratio: {
      type: Number,
      required: false,
      default: 1
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const aspect = computed18(() => {
      return 1 / props2.ratio * 100;
    });
    return (_ctx, _cache) => {
      return openBlock33(), createElementBlock("div", {
        style: normalizeStyle2(`position: relative; width: 100%; padding-bottom: ${aspect.value}%`),
        "data-reka-aspect-ratio-wrapper": ""
      }, [createVNode4(unref37(Primitive), mergeProps17({
        ref: unref37(forwardRef),
        "as-child": _ctx.asChild,
        as: _ctx.as,
        style: {
          "position": "absolute",
          "inset": "0px"
        }
      }, _ctx.$attrs), {
        default: withCtx32(() => [renderSlot35(_ctx.$slots, "default", { aspect: aspect.value })]),
        _: 3
      }, 16, ["as-child", "as"])], 4);
    };
  }
});
var AspectRatio_default = AspectRatio_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Avatar/AvatarRoot.js
import { createBlock as createBlock33, defineComponent as defineComponent40, openBlock as openBlock34, ref as ref22, renderSlot as renderSlot36, unref as unref38, withCtx as withCtx33 } from "vue";
var [injectAvatarRootContext, provideAvatarRootContext] = createContext("AvatarRoot");
var AvatarRoot_vue_vue_type_script_setup_true_lang_default = defineComponent40({
  __name: "AvatarRoot",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    useForwardExpose();
    provideAvatarRootContext({ imageLoadingStatus: ref22("idle") });
    return (_ctx, _cache) => {
      return openBlock34(), createBlock33(unref38(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx33(() => [renderSlot36(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
var AvatarRoot_default = AvatarRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Avatar/AvatarFallback.js
import { createBlock as createBlock34, createCommentVNode as createCommentVNode5, defineComponent as defineComponent41, openBlock as openBlock35, ref as ref23, renderSlot as renderSlot37, unref as unref39, watchEffect as watchEffect8, withCtx as withCtx34 } from "vue";
var AvatarFallback_vue_vue_type_script_setup_true_lang_default = defineComponent41({
  __name: "AvatarFallback",
  props: {
    delayMs: {
      type: Number,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectAvatarRootContext();
    useForwardExpose();
    const canRender = ref23(props2.delayMs === void 0);
    watchEffect8((onCleanup) => {
      if (props2.delayMs && isClient) {
        const timerId = window.setTimeout(() => {
          canRender.value = true;
        }, props2.delayMs);
        onCleanup(() => {
          window.clearTimeout(timerId);
        });
      }
    });
    return (_ctx, _cache) => {
      return canRender.value && unref39(rootContext).imageLoadingStatus.value !== "loaded" ? (openBlock35(), createBlock34(unref39(Primitive), {
        key: 0,
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx34(() => [renderSlot37(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["as-child", "as"])) : createCommentVNode5("v-if", true);
    };
  }
});
var AvatarFallback_default = AvatarFallback_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Avatar/utils.js
import { computed as computed19, onMounted as onMounted10, onUnmounted as onUnmounted5, ref as ref24, watchEffect as watchEffect9 } from "vue";
function resolveLoadingStatus(image, src) {
  if (!image) return "idle";
  if (!src) return "error";
  if (image.src !== src) image.src = src;
  return image.complete && image.naturalWidth > 0 ? "loaded" : "loading";
}
function useImageLoadingStatus(src, { referrerPolicy, crossOrigin } = {}) {
  const isMounted = ref24(false);
  const imageRef = ref24(null);
  const image = computed19(() => {
    if (!isMounted.value) return null;
    if (!imageRef.value && isClient) imageRef.value = new window.Image();
    return imageRef.value;
  });
  const loadingStatus = ref24(resolveLoadingStatus(image.value, src.value));
  const updateStatus = (status) => () => {
    if (isMounted.value) loadingStatus.value = status;
  };
  onMounted10(() => {
    isMounted.value = true;
    watchEffect9((onCleanup) => {
      const img = image.value;
      if (!img) return;
      loadingStatus.value = resolveLoadingStatus(img, src.value);
      const handleLoad = updateStatus("loaded");
      const handleError = updateStatus("error");
      img.addEventListener("load", handleLoad);
      img.addEventListener("error", handleError);
      if (referrerPolicy?.value) img.referrerPolicy = referrerPolicy.value;
      if (typeof crossOrigin?.value === "string") img.crossOrigin = crossOrigin.value;
      onCleanup(() => {
        img.removeEventListener("load", handleLoad);
        img.removeEventListener("error", handleError);
      });
    });
  });
  onUnmounted5(() => {
    isMounted.value = false;
  });
  return loadingStatus;
}

// node_modules/reka-ui/dist/Avatar/AvatarImage.js
import { createBlock as createBlock35, defineComponent as defineComponent42, openBlock as openBlock36, renderSlot as renderSlot38, toRefs as toRefs7, unref as unref40, vShow, watch as watch7, withCtx as withCtx35, withDirectives } from "vue";
var AvatarImage_vue_vue_type_script_setup_true_lang_default = defineComponent42({
  __name: "AvatarImage",
  props: {
    src: {
      type: String,
      required: true
    },
    referrerPolicy: {
      type: null,
      required: false
    },
    crossOrigin: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "img"
    }
  },
  emits: ["loadingStatusChange"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { src, referrerPolicy, crossOrigin } = toRefs7(props2);
    useForwardExpose();
    const rootContext = injectAvatarRootContext();
    const imageLoadingStatus = useImageLoadingStatus(src, {
      referrerPolicy,
      crossOrigin
    });
    watch7(imageLoadingStatus, (newValue) => {
      emits("loadingStatusChange", newValue);
      if (newValue !== "idle") rootContext.imageLoadingStatus.value = newValue;
    }, { immediate: true });
    return (_ctx, _cache) => {
      return withDirectives((openBlock36(), createBlock35(unref40(Primitive), {
        role: "img",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        src: unref40(src),
        "referrer-policy": unref40(referrerPolicy)
      }, {
        default: withCtx35(() => [renderSlot38(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "src",
        "referrer-policy"
      ])), [[vShow, unref40(imageLoadingStatus) === "loaded"]]);
    };
  }
});
var AvatarImage_default = AvatarImage_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/date/parts.js
var DATE_SEGMENT_PARTS = [
  "day",
  "month",
  "year"
];
var TIME_SEGMENT_PARTS = [
  "hour",
  "minute",
  "second",
  "dayPeriod"
];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS];
var EDITABLE_TIME_SEGMENT_PARTS = [...TIME_SEGMENT_PARTS];
var ALL_SEGMENT_PARTS = [...EDITABLE_SEGMENT_PARTS, ...NON_EDITABLE_SEGMENT_PARTS];
var ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter((part) => part !== "literal");
function isDateSegmentPart(part) {
  return DATE_SEGMENT_PARTS.includes(part);
}
function isSegmentPart(part) {
  return EDITABLE_SEGMENT_PARTS.includes(part);
}

// node_modules/reka-ui/dist/date/placeholders.js
var supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
];
var placeholderFields = [
  "year",
  "month",
  "day"
];
var placeholders = {
  "ach": {
    year: "mwaka",
    month: "dwe",
    day: "nino"
  },
  "af": {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  "am": {
    year: "ዓዓዓዓ",
    month: "ሚሜ",
    day: "ቀቀ"
  },
  "an": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "ar": {
    year: "سنة",
    month: "شهر",
    day: "يوم"
  },
  "ast": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "az": {
    year: "iiii",
    month: "aa",
    day: "gg"
  },
  "be": {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  "bg": {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  "bn": {
    year: "yyyy",
    month: "মিমি",
    day: "dd"
  },
  "br": {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  "bs": {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  "ca": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "cak": {
    year: "jjjj",
    month: "ii",
    day: "q'q'"
  },
  "ckb": {
    year: "ساڵ",
    month: "مانگ",
    day: "ڕۆژ"
  },
  "cs": {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  "cy": {
    year: "bbbb",
    month: "mm",
    day: "dd"
  },
  "da": {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  "de": {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  "dsb": {
    year: "llll",
    month: "mm",
    day: "źź"
  },
  "el": {
    year: "εεεε",
    month: "μμ",
    day: "ηη"
  },
  "en": {
    year: "yyyy",
    month: "mm",
    day: "dd"
  },
  "eo": {
    year: "jjjj",
    month: "mm",
    day: "tt"
  },
  "es": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "et": {
    year: "aaaa",
    month: "kk",
    day: "pp"
  },
  "eu": {
    year: "uuuu",
    month: "hh",
    day: "ee"
  },
  "fa": {
    year: "سال",
    month: "ماه",
    day: "روز"
  },
  "ff": {
    year: "hhhh",
    month: "ll",
    day: "ññ"
  },
  "fi": {
    year: "vvvv",
    month: "kk",
    day: "pp"
  },
  "fr": {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  "fy": {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  "ga": {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  "gd": {
    year: "bbbb",
    month: "mm",
    day: "ll"
  },
  "gl": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "he": {
    year: "שנה",
    month: "חודש",
    day: "יום"
  },
  "hr": {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  "hsb": {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  "hu": {
    year: "éééé",
    month: "hh",
    day: "nn"
  },
  "ia": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "id": {
    year: "tttt",
    month: "bb",
    day: "hh"
  },
  "it": {
    year: "aaaa",
    month: "mm",
    day: "gg"
  },
  "ja": {
    year: " 年 ",
    month: "月",
    day: "日"
  },
  "ka": {
    year: "წწწწ",
    month: "თთ",
    day: "რრ"
  },
  "kk": {
    year: "жжжж",
    month: "аа",
    day: "кк"
  },
  "kn": {
    year: "ವವವವ",
    month: "ಮಿಮೀ",
    day: "ದಿದಿ"
  },
  "ko": {
    year: "연도",
    month: "월",
    day: "일"
  },
  "lb": {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  "lo": {
    year: "ປປປປ",
    month: "ດດ",
    day: "ວວ"
  },
  "lt": {
    year: "mmmm",
    month: "mm",
    day: "dd"
  },
  "lv": {
    year: "gggg",
    month: "mm",
    day: "dd"
  },
  "meh": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "ml": {
    year: "വർഷം",
    month: "മാസം",
    day: "തീയതി"
  },
  "ms": {
    year: "tttt",
    month: "mm",
    day: "hh"
  },
  "nl": {
    year: "jjjj",
    month: "mm",
    day: "dd"
  },
  "nn": {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  "no": {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  "oc": {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  "pl": {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  "pt": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "rm": {
    year: "oooo",
    month: "mm",
    day: "dd"
  },
  "ro": {
    year: "aaaa",
    month: "ll",
    day: "zz"
  },
  "ru": {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  "sc": {
    year: "aaaa",
    month: "mm",
    day: "dd"
  },
  "scn": {
    year: "aaaa",
    month: "mm",
    day: "jj"
  },
  "sk": {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  "sl": {
    year: "llll",
    month: "mm",
    day: "dd"
  },
  "sr": {
    year: "гггг",
    month: "мм",
    day: "дд"
  },
  "sv": {
    year: "åååå",
    month: "mm",
    day: "dd"
  },
  "szl": {
    year: "rrrr",
    month: "mm",
    day: "dd"
  },
  "tg": {
    year: "сссс",
    month: "мм",
    day: "рр"
  },
  "th": {
    year: "ปปปป",
    month: "ดด",
    day: "วว"
  },
  "tr": {
    year: "yyyy",
    month: "aa",
    day: "gg"
  },
  "uk": {
    year: "рррр",
    month: "мм",
    day: "дд"
  },
  "zh-CN": {
    year: "年",
    month: "月",
    day: "日"
  },
  "zh-TW": {
    year: "年",
    month: "月",
    day: "日"
  }
};
function getPlaceholderObj(locale) {
  if (!isSupportedLocale(locale)) {
    const localeLanguage = getLocaleLanguage(locale);
    if (!isSupportedLocale(localeLanguage)) return placeholders.en;
    else return placeholders[localeLanguage];
  } else return placeholders[locale];
}
function getPlaceholder(field, value, locale) {
  if (isPlaceholderField(field)) return getPlaceholderObj(locale)[field];
  if (isDefaultField(field)) return value;
  if (isTimeField(field)) return "––";
  return "";
}
function isSupportedLocale(locale) {
  return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
  return placeholderFields.includes(field);
}
function isTimeField(field) {
  return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
  return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
  if (Intl.Locale) return new Intl.Locale(locale).language;
  return locale.split("-")[0];
}

// node_modules/reka-ui/dist/date/parser.js
var calendarDateTimeGranularities = [
  "hour",
  "minute",
  "second"
];
function syncTimeSegmentValues(props2) {
  return Object.fromEntries(TIME_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") return [part, props2.formatter.dayPeriod(toDate(props2.value))];
    return [part, props2.value[part]];
  }));
}
function syncSegmentValues(props2) {
  const { formatter } = props2;
  const dateValues = DATE_SEGMENT_PARTS.map((part) => {
    return [part, props2.value[part]];
  });
  if ("hour" in props2.value) {
    const timeValues = syncTimeSegmentValues({
      value: props2.value,
      formatter
    });
    return {
      ...Object.fromEntries(dateValues),
      ...timeValues
    };
  }
  return Object.fromEntries(dateValues);
}
function initializeTimeSegmentValues(granularity) {
  return Object.fromEntries(TIME_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") return [part, "AM"];
    return [part, null];
  }).filter(([key]) => {
    if (key === "literal" || key === null) return false;
    if (granularity === "minute" && key === "second") return false;
    if (granularity === "hour" && (key === "second" || key === "minute")) return false;
    else return true;
  }));
}
function initializeSegmentValues(granularity) {
  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") return [part, "AM"];
    return [part, null];
  }).filter(([key]) => {
    if (key === "literal" || key === null) return false;
    if (granularity === "minute" && key === "second") return false;
    if (granularity === "hour" && (key === "second" || key === "minute")) return false;
    if (granularity === "day") return !calendarDateTimeGranularities.includes(key) && key !== "dayPeriod";
    else return true;
  });
  return Object.fromEntries(initialParts);
}
function createContentObj(props2) {
  const { segmentValues, formatter, locale } = props2;
  function getPartContent(part) {
    if ("hour" in segmentValues) {
      const value = segmentValues[part];
      if (value !== null) {
        if (part === "day") return formatter.part(props2.dateRef.set({
          [part]: value,
          month: segmentValues.month ?? 1
        }), part, { hourCycle: normalizeHourCycle(props2.hourCycle) });
        return formatter.part(props2.dateRef.set({ [part]: value }), part, { hourCycle: normalizeHourCycle(props2.hourCycle) });
      } else return getPlaceholder(part, "", locale.value);
    } else {
      if (isDateSegmentPart(part)) {
        const value = segmentValues[part];
        if (value !== null) {
          if (part === "day") return formatter.part(props2.dateRef.set({
            [part]: value,
            month: segmentValues.month ?? 1
          }), part);
          return formatter.part(props2.dateRef.set({ [part]: value }), part);
        } else return getPlaceholder(part, "", locale.value);
      }
      return "";
    }
  }
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isSegmentPart(part)) return obj;
    if ("hour" in segmentValues && part === "dayPeriod") {
      const value = segmentValues[part];
      if (value !== null) obj[part] = value;
      else obj[part] = getPlaceholder(part, "AM", locale.value);
    } else obj[part] = getPartContent(part);
    return obj;
  }, {});
  return content;
}
function createContentArr(props2) {
  const { granularity, formatter, contentObj, hideTimeZone, hourCycle, isTimeValue } = props2;
  const parts = formatter.toParts(props2.dateRef, getOptsByGranularity(granularity, hourCycle, isTimeValue));
  const segmentContentArr = parts.map((part) => {
    const defaultParts = [
      "literal",
      "timeZoneName",
      null
    ];
    if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) return {
      part: part.type,
      value: part.value
    };
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (segment.part === null || segment.value === null) return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(props2.dateRef) || hideTimeZone)) return false;
    return true;
  });
  return segmentContentArr;
}
function createContent(props2) {
  const contentObj = createContentObj(props2);
  const contentArr = createContentArr({
    contentObj,
    ...props2
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}

// node_modules/reka-ui/dist/date/segment.js
function isSegmentNavigationKey(key) {
  const kbd = useKbd();
  if (key === kbd.ARROW_RIGHT || key === kbd.ARROW_LEFT) return true;
  return false;
}
function isNumberString(value) {
  if (Number.isNaN(Number.parseInt(value))) return false;
  return true;
}
function isAcceptableSegmentKey(key) {
  const kbd = useKbd();
  const acceptableSegmentKeys = [
    kbd.ENTER,
    kbd.ARROW_UP,
    kbd.ARROW_DOWN,
    kbd.ARROW_LEFT,
    kbd.ARROW_RIGHT,
    kbd.BACKSPACE,
    kbd.SPACE,
    "a",
    "A",
    "p",
    "P"
  ];
  if (acceptableSegmentKeys.includes(key)) return true;
  if (isNumberString(key)) return true;
  return false;
}
function getSegmentElements(parentElement) {
  return Array.from(parentElement.querySelectorAll("[data-reka-date-field-segment]")).filter((item) => item.getAttribute("data-reka-date-field-segment") !== "literal");
}
function getTimeFieldSegmentElements(parentElement) {
  return Array.from(parentElement.querySelectorAll("[data-reka-time-field-segment]")).filter((item) => item.getAttribute("data-reka-time-field-segment") !== "literal");
}

// node_modules/reka-ui/dist/date/useDateField.js
import { computed as computed20 } from "vue";
function commonSegmentAttrs(props2) {
  return {
    role: "spinbutton",
    contenteditable: true,
    tabindex: props2.disabled ? void 0 : 0,
    spellcheck: false,
    inputmode: "numeric",
    autocorrect: "off",
    enterkeyhint: "next",
    style: "caret-color: transparent;"
  };
}
function daySegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  const isEmpty = segmentValues.day === null;
  const date = segmentValues.day ? placeholder.set({ day: segmentValues.day }) : placeholder;
  const valueNow = date.day;
  const valueMin = 1;
  const valueMax = getDaysInMonth(date);
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "day,",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function monthSegmentAttrs(props2) {
  const { segmentValues, placeholder, formatter } = props2;
  const isEmpty = segmentValues.month === null;
  const date = segmentValues.month ? placeholder.set({ month: segmentValues.month }) : placeholder;
  const valueNow = date.month;
  const valueMin = 1;
  const valueMax = 12;
  const valueText = isEmpty ? "Empty" : `${valueNow} - ${formatter.fullMonth(toDate(date))}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "month, ",
    "contenteditable": true,
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function yearSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  const isEmpty = segmentValues.year === null;
  const date = segmentValues.year ? placeholder.set({ year: segmentValues.year }) : placeholder;
  const valueMin = 1;
  const valueMax = 9999;
  const valueNow = date.year;
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "year, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function hourSegmentAttrs(props2) {
  const { segmentValues, hourCycle, placeholder } = props2;
  if (!("hour" in segmentValues) || !("hour" in placeholder)) return {};
  const isEmpty = segmentValues.hour === null;
  const date = segmentValues.hour ? placeholder.set({ hour: segmentValues.hour }) : placeholder;
  const valueMin = hourCycle === 12 ? 1 : 0;
  const valueMax = hourCycle === 12 ? 12 : 23;
  const valueNow = date.hour;
  const valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod ?? ""}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "hour, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function minuteSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  if (!("minute" in segmentValues) || !("minute" in placeholder)) return {};
  const isEmpty = segmentValues.minute === null;
  const date = segmentValues.minute ? placeholder.set({ minute: segmentValues.minute }) : placeholder;
  const valueNow = date.minute;
  const valueMin = 0;
  const valueMax = 59;
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "minute, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function secondSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  if (!("second" in segmentValues) || !("second" in placeholder)) return {};
  const isEmpty = segmentValues.second === null;
  const date = segmentValues.second ? placeholder.set({ second: segmentValues.second }) : placeholder;
  const valueNow = date.second;
  const valueMin = 0;
  const valueMax = 59;
  const valueText = isEmpty ? "Empty" : `${valueNow}`;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "second, ",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText,
    "data-placeholder": isEmpty ? "" : void 0
  };
}
function dayPeriodSegmentAttrs(props2) {
  const { segmentValues } = props2;
  if (!("dayPeriod" in segmentValues)) return {};
  const valueMin = 0;
  const valueMax = 12;
  const valueNow = segmentValues.hour ? segmentValues.hour > 12 ? segmentValues.hour - 12 : segmentValues.hour : 0;
  const valueText = segmentValues.dayPeriod ?? "AM";
  return {
    ...commonSegmentAttrs(props2),
    "inputmode": "text",
    "aria-label": "AM/PM",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText
  };
}
function literalSegmentAttrs(_props) {
  return {
    "aria-hidden": true,
    "data-segment": "literal"
  };
}
function timeZoneSegmentAttrs(props2) {
  return {
    "role": "textbox",
    "aria-label": "timezone, ",
    "data-readonly": true,
    "data-segment": "timeZoneName",
    "tabindex": props2.disabled ? void 0 : 0,
    "style": "caret-color: transparent;"
  };
}
function eraSegmentAttrs(props2) {
  const { segmentValues, placeholder } = props2;
  const valueMin = 0;
  const valueMax = 0;
  const valueNow = 0;
  const valueText = "era" in segmentValues ? segmentValues.era : placeholder.era;
  return {
    ...commonSegmentAttrs(props2),
    "aria-label": "era",
    "aria-valuemin": valueMin,
    "aria-valuemax": valueMax,
    "aria-valuenow": valueNow,
    "aria-valuetext": valueText
  };
}
var segmentBuilders = {
  day: { attrs: daySegmentAttrs },
  month: { attrs: monthSegmentAttrs },
  year: { attrs: yearSegmentAttrs },
  hour: { attrs: hourSegmentAttrs },
  minute: { attrs: minuteSegmentAttrs },
  second: { attrs: secondSegmentAttrs },
  dayPeriod: { attrs: dayPeriodSegmentAttrs },
  literal: { attrs: literalSegmentAttrs },
  timeZoneName: { attrs: timeZoneSegmentAttrs },
  era: { attrs: eraSegmentAttrs }
};
function useDateField(props2) {
  const kbd = useKbd();
  function minuteSecondIncrementation({ e, part, dateRef, prevValue }) {
    const step = props2.step.value[part] ?? 1;
    const sign = e.key === kbd.ARROW_UP ? step : -step;
    const min2 = 0;
    const max2 = 59;
    if (prevValue === null) return sign > 0 ? min2 : max2;
    const cycleArgs = [part, sign];
    return dateRef.set({ [part]: prevValue }).cycle(...cycleArgs)[part];
  }
  function deleteValue(prevValue) {
    props2.hasLeftFocus.value = false;
    if (prevValue === null) return prevValue;
    const str = prevValue.toString();
    if (str.length === 1) {
      props2.modelValue.value = void 0;
      return null;
    }
    return Number.parseInt(str.slice(0, -1));
  }
  function dateTimeValueIncrementation({ e, part, dateRef, prevValue, hourCycle }) {
    const step = props2.step.value[part] ?? 1;
    const sign = e.key === kbd.ARROW_UP ? step : -step;
    if (prevValue === null) return dateRef[part];
    if (part === "hour" && "hour" in dateRef) {
      const cycleArgs$1 = [
        part,
        sign,
        { hourCycle }
      ];
      return dateRef.set({ [part]: prevValue }).cycle(...cycleArgs$1)[part];
    }
    const cycleArgs = [part, sign];
    if (part === "day") return dateRef.set({
      [part]: prevValue,
      month: props2.segmentValues.value.month ?? 1
    }).cycle(...cycleArgs)[part];
    return dateRef.set({ [part]: prevValue }).cycle(...cycleArgs)[part];
  }
  function updateDayOrMonth(max2, num, prev) {
    let moveToNext = false;
    const maxStart = Math.floor(max2 / 10);
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null) {
      if (num === 0) {
        props2.lastKeyZero.value = true;
        return {
          value: null,
          moveToNext
        };
      }
      if (props2.lastKeyZero.value || num > maxStart) moveToNext = true;
      props2.lastKeyZero.value = false;
      return {
        value: num,
        moveToNext
      };
    }
    const digits = prev.toString().length;
    const total = Number.parseInt(prev.toString() + num.toString());
    if (digits === 2 || total > max2) {
      if (num > maxStart || total > max2) moveToNext = true;
      return {
        value: num,
        moveToNext
      };
    }
    moveToNext = true;
    return {
      value: total,
      moveToNext
    };
  }
  function updateMinuteOrSecond(num, prev) {
    const max2 = 59;
    let moveToNext = false;
    const maxStart = Math.floor(max2 / 10);
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null) {
      if (num === 0) {
        props2.lastKeyZero.value = true;
        return {
          value: 0,
          moveToNext
        };
      }
      if (props2.lastKeyZero.value || num > maxStart) moveToNext = true;
      props2.lastKeyZero.value = false;
      return {
        value: num,
        moveToNext
      };
    }
    const digits = prev.toString().length;
    const total = Number.parseInt(prev.toString() + num.toString());
    if (digits === 2 || total > max2) {
      if (num > maxStart) moveToNext = true;
      return {
        value: num,
        moveToNext
      };
    }
    moveToNext = true;
    return {
      value: total,
      moveToNext
    };
  }
  function updateHour(num, prev) {
    const max2 = 24;
    let moveToNext = false;
    const maxStart = Math.floor(max2 / 10);
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null) {
      if (num === 0) {
        props2.lastKeyZero.value = true;
        return {
          value: 0,
          moveToNext
        };
      }
      if (props2.lastKeyZero.value || num > maxStart) moveToNext = true;
      props2.lastKeyZero.value = false;
      return {
        value: num,
        moveToNext
      };
    }
    const digits = prev.toString().length;
    const total = Number.parseInt(prev.toString() + num.toString());
    if (digits === 2 || total > max2) {
      if (num > maxStart) moveToNext = true;
      return {
        value: num,
        moveToNext
      };
    }
    moveToNext = true;
    return {
      value: total,
      moveToNext
    };
  }
  function updateYear(num, prev) {
    let moveToNext = false;
    if (props2.hasLeftFocus.value) {
      props2.hasLeftFocus.value = false;
      prev = null;
    }
    if (prev === null) return {
      value: num === 0 ? 1 : num,
      moveToNext
    };
    const str = prev.toString() + num.toString();
    if (str.length > 4) return {
      value: num === 0 ? 1 : num,
      moveToNext
    };
    if (str.length === 4) moveToNext = true;
    const int = Number.parseInt(str);
    return {
      value: int,
      moveToNext
    };
  }
  const attributes = computed20(() => segmentBuilders[props2.part]?.attrs({
    disabled: props2.disabled.value,
    placeholder: props2.placeholder.value,
    hourCycle: props2.hourCycle,
    segmentValues: props2.segmentValues.value,
    formatter: props2.formatter
  }) ?? {});
  function handleDaySegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) return;
    const prevValue = props2.segmentValues.value.day;
    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
      props2.segmentValues.value.day = dateTimeValueIncrementation({
        e,
        part: "day",
        dateRef: props2.placeholder.value,
        prevValue
      });
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const segmentMonthValue = props2.segmentValues.value.month;
      const daysInMonth = segmentMonthValue ? getDaysInMonth(props2.placeholder.value.set({ month: segmentMonthValue })) : 31;
      const { value, moveToNext } = updateDayOrMonth(daysInMonth, num, prevValue);
      props2.segmentValues.value.day = value;
      if (moveToNext) props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.day = deleteValue(prevValue);
    }
  }
  function handleMonthSegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) return;
    const prevValue = props2.segmentValues.value.month;
    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
      props2.segmentValues.value.month = dateTimeValueIncrementation({
        e,
        part: "month",
        dateRef: props2.placeholder.value,
        prevValue
      });
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateDayOrMonth(12, num, prevValue);
      props2.segmentValues.value.month = value;
      if (moveToNext) props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.month = deleteValue(prevValue);
    }
  }
  function handleYearSegmentKeydown(e) {
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) return;
    const prevValue = props2.segmentValues.value.year;
    if (e.key === kbd.ARROW_DOWN || e.key === kbd.ARROW_UP) {
      props2.segmentValues.value.year = dateTimeValueIncrementation({
        e,
        part: "year",
        dateRef: props2.placeholder.value,
        prevValue
      });
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateYear(num, prevValue);
      props2.segmentValues.value.year = value;
      if (moveToNext) props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.year = deleteValue(prevValue);
    }
  }
  function handleHourSegmentKeydown(e) {
    const dateRef = props2.placeholder.value;
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("hour" in dateRef) || !("hour" in props2.segmentValues.value)) return;
    const prevValue = props2.segmentValues.value.hour;
    const hourCycle = props2.hourCycle;
    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {
      props2.segmentValues.value.hour = dateTimeValueIncrementation({
        e,
        part: "hour",
        dateRef: props2.placeholder.value,
        prevValue,
        hourCycle
      });
      if ("dayPeriod" in props2.segmentValues.value) {
        if (props2.segmentValues.value.hour < 12) props2.segmentValues.value.dayPeriod = "AM";
        else if (props2.segmentValues.value.hour) props2.segmentValues.value.dayPeriod = "PM";
      }
      return;
    }
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateHour(num, prevValue);
      if ("dayPeriod" in props2.segmentValues.value && value && value > 12) props2.segmentValues.value.dayPeriod = "PM";
      else if ("dayPeriod" in props2.segmentValues.value && value) props2.segmentValues.value.dayPeriod = "AM";
      props2.segmentValues.value.hour = value;
      if (moveToNext) props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.hour = deleteValue(prevValue);
    }
  }
  function handleMinuteSegmentKeydown(e) {
    const dateRef = props2.placeholder.value;
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("minute" in dateRef) || !("minute" in props2.segmentValues.value)) return;
    const prevValue = props2.segmentValues.value.minute;
    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) props2.segmentValues.value.minute = minuteSecondIncrementation({
      e,
      part: "minute",
      dateRef: props2.placeholder.value,
      prevValue
    });
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateMinuteOrSecond(num, prevValue);
      props2.segmentValues.value.minute = value;
      if (moveToNext) props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.minute = deleteValue(prevValue);
    }
  }
  function handleSecondSegmentKeydown(e) {
    const dateRef = props2.placeholder.value;
    if (!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key) || !("second" in dateRef) || !("second" in props2.segmentValues.value)) return;
    const prevValue = props2.segmentValues.value.second;
    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) props2.segmentValues.value.second = minuteSecondIncrementation({
      e,
      part: "second",
      dateRef: props2.placeholder.value,
      prevValue
    });
    if (isNumberString(e.key)) {
      const num = Number.parseInt(e.key);
      const { value, moveToNext } = updateMinuteOrSecond(num, prevValue);
      props2.segmentValues.value.second = value;
      if (moveToNext) props2.focusNext();
    }
    if (e.key === kbd.BACKSPACE) {
      props2.hasLeftFocus.value = false;
      props2.segmentValues.value.second = deleteValue(prevValue);
    }
  }
  function handleDayPeriodSegmentKeydown(e) {
    if ((!isAcceptableSegmentKey(e.key) || isSegmentNavigationKey(e.key)) && e.key !== "a" && e.key !== "p" || !("hour" in props2.placeholder.value) || !("dayPeriod" in props2.segmentValues.value)) return;
    if (e.key === kbd.ARROW_UP || e.key === kbd.ARROW_DOWN) {
      if (props2.segmentValues.value.dayPeriod === "AM") {
        props2.segmentValues.value.dayPeriod = "PM";
        props2.segmentValues.value.hour = props2.segmentValues.value.hour + 12;
        return;
      }
      props2.segmentValues.value.dayPeriod = "AM";
      props2.segmentValues.value.hour = props2.segmentValues.value.hour - 12;
      return;
    }
    if (["a", "A"].includes(e.key) && props2.segmentValues.value.dayPeriod !== "AM") {
      props2.segmentValues.value.dayPeriod = "AM";
      props2.segmentValues.value.hour = props2.segmentValues.value.hour - 12;
      return;
    }
    if (["p", "P"].includes(e.key) && props2.segmentValues.value.dayPeriod !== "PM") {
      props2.segmentValues.value.dayPeriod = "PM";
      props2.segmentValues.value.hour = props2.segmentValues.value.hour + 12;
    }
  }
  function handleSegmentClick(e) {
    const disabled = props2.disabled.value;
    if (disabled) e.preventDefault();
  }
  function handleSegmentKeydown(e) {
    const disabled = props2.disabled.value;
    const readonly3 = props2.readonly.value;
    if (e.key !== kbd.TAB) e.preventDefault();
    if (disabled || readonly3) return;
    const segmentKeydownHandlers = {
      day: handleDaySegmentKeydown,
      month: handleMonthSegmentKeydown,
      year: handleYearSegmentKeydown,
      hour: handleHourSegmentKeydown,
      minute: handleMinuteSegmentKeydown,
      second: handleSecondSegmentKeydown,
      dayPeriod: handleDayPeriodSegmentKeydown,
      timeZoneName: () => {
      }
    };
    segmentKeydownHandlers[props2.part](e);
    if (![kbd.ARROW_LEFT, kbd.ARROW_RIGHT].includes(e.key) && e.key !== kbd.TAB && e.key !== kbd.SHIFT && isAcceptableSegmentKey(e.key)) {
      if (Object.values(props2.segmentValues.value).every((item) => item !== null)) {
        const updateObject = { ...props2.segmentValues.value };
        let dateRef = props2.placeholder.value.copy();
        Object.keys(updateObject).forEach((part) => {
          const value = updateObject[part];
          dateRef = dateRef.set({ [part]: value });
        });
        props2.modelValue.value = dateRef.copy();
      }
    }
  }
  return {
    handleSegmentClick,
    handleSegmentKeydown,
    attributes
  };
}

// node_modules/reka-ui/dist/Calendar/useCalendar.js
import { computed as computed21, ref as ref25, watch as watch8 } from "vue";
function useCalendarState(props2) {
  function isDateSelected(dateObj) {
    if (Array.isArray(props2.date.value)) return props2.date.value.some((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, dateObj));
    else if (!props2.date.value) return false;
    else return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.date.value, dateObj);
  }
  const isInvalid = computed21(() => {
    if (Array.isArray(props2.date.value)) {
      if (!props2.date.value.length) return false;
      for (const dateObj of props2.date.value) {
        if (props2.isDateDisabled?.(dateObj)) return true;
        if (props2.isDateUnavailable?.(dateObj)) return true;
      }
    } else {
      if (!props2.date.value) return false;
      if (props2.isDateDisabled?.(props2.date.value)) return true;
      if (props2.isDateUnavailable?.(props2.date.value)) return true;
    }
    return false;
  });
  return {
    isDateSelected,
    isInvalid
  };
}
function handleNextDisabled(lastPeriodInView, nextPageFunc) {
  const firstPeriodOfNextPage = nextPageFunc(lastPeriodInView);
  const diff = firstPeriodOfNextPage.compare(lastPeriodInView);
  const duration = {};
  if (diff >= 7) duration.day = 1;
  if (diff >= getDaysInMonth(lastPeriodInView)) duration.month = 1;
  return firstPeriodOfNextPage.set({ ...duration });
}
function handlePrevDisabled(firstPeriodInView, prevPageFunc) {
  const lastPeriodOfPrevPage = prevPageFunc(firstPeriodInView);
  const diff = firstPeriodInView.compare(lastPeriodOfPrevPage);
  const duration = {};
  if (diff >= 7) duration.day = 35;
  if (diff >= getDaysInMonth(firstPeriodInView)) duration.month = 13;
  return lastPeriodOfPrevPage.set({ ...duration });
}
function handleNextPage(date, nextPageFunc) {
  return nextPageFunc(date);
}
function handlePrevPage(date, prevPageFunc) {
  return prevPageFunc(date);
}
function useCalendar(props2) {
  const formatter = useDateFormatter(props2.locale.value);
  const headingFormatOptions = computed21(() => {
    const options = { calendar: props2.placeholder.value.calendar.identifier };
    if (props2.placeholder.value.calendar.identifier === "gregory" && props2.placeholder.value.era === "BC") options.era = "short";
    return options;
  });
  const grid = ref25(createMonths({
    dateObj: props2.placeholder.value,
    weekStartsOn: props2.weekStartsOn.value,
    locale: props2.locale.value,
    fixedWeeks: props2.fixedWeeks.value,
    numberOfMonths: props2.numberOfMonths.value
  }));
  const visibleView = computed21(() => {
    return grid.value.map((month) => month.value);
  });
  function isOutsideVisibleView(date) {
    return !visibleView.value.some((month) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(date, month));
  }
  const isNextButtonDisabled = (nextPageFunc) => {
    if (!props2.maxValue.value || !grid.value.length) return false;
    if (props2.disabled.value) return true;
    const lastPeriodInView = grid.value[grid.value.length - 1].value;
    if (!nextPageFunc && !props2.nextPage.value) {
      const firstPeriodOfNextPage$1 = lastPeriodInView.add({ months: 1 }).set({ day: 1 });
      return isAfter(firstPeriodOfNextPage$1, props2.maxValue.value);
    }
    const firstPeriodOfNextPage = handleNextDisabled(lastPeriodInView, nextPageFunc || props2.nextPage.value);
    return isAfter(firstPeriodOfNextPage, props2.maxValue.value);
  };
  const isPrevButtonDisabled = (prevPageFunc) => {
    if (!props2.minValue.value || !grid.value.length) return false;
    if (props2.disabled.value) return true;
    const firstPeriodInView = grid.value[0].value;
    if (!prevPageFunc && !props2.prevPage.value) {
      const lastPeriodOfPrevPage$1 = firstPeriodInView.subtract({ months: 1 }).set({ day: 35 });
      return isBefore(lastPeriodOfPrevPage$1, props2.minValue.value);
    }
    const lastPeriodOfPrevPage = handlePrevDisabled(firstPeriodInView, prevPageFunc || props2.prevPage.value);
    return isBefore(lastPeriodOfPrevPage, props2.minValue.value);
  };
  function isDateDisabled(dateObj) {
    if (props2.isDateDisabled?.(dateObj) || props2.disabled.value) return true;
    if (props2.maxValue.value && isAfter(dateObj, props2.maxValue.value)) return true;
    if (props2.minValue.value && isBefore(dateObj, props2.minValue.value)) return true;
    return false;
  }
  const isDateUnavailable = (date) => {
    if (props2.isDateUnavailable?.(date)) return true;
    return false;
  };
  const weekdays = computed21(() => {
    if (!grid.value.length) return [];
    return grid.value[0].rows[0].map((date) => {
      return formatter.dayOfWeek(toDate(date), props2.weekdayFormat.value);
    });
  });
  const nextPage = (nextPageFunc) => {
    const firstDate = grid.value[0].value;
    if (!nextPageFunc && !props2.nextPage.value) {
      const newDate$1 = firstDate.add({ months: props2.pagedNavigation.value ? props2.numberOfMonths.value : 1 });
      const newGrid$1 = createMonths({
        dateObj: newDate$1,
        weekStartsOn: props2.weekStartsOn.value,
        locale: props2.locale.value,
        fixedWeeks: props2.fixedWeeks.value,
        numberOfMonths: props2.numberOfMonths.value
      });
      grid.value = newGrid$1;
      props2.placeholder.value = newGrid$1[0].value.set({ day: 1 });
      return;
    }
    const newDate = handleNextPage(firstDate, nextPageFunc || props2.nextPage.value);
    const newGrid = createMonths({
      dateObj: newDate,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
    grid.value = newGrid;
    const duration = {};
    if (!nextPageFunc) {
      const diff = newGrid[0].value.compare(firstDate);
      if (diff >= getDaysInMonth(firstDate)) duration.day = 1;
      if (diff >= 365) duration.month = 1;
    }
    props2.placeholder.value = newGrid[0].value.set({ ...duration });
  };
  const prevPage = (prevPageFunc) => {
    const firstDate = grid.value[0].value;
    if (!prevPageFunc && !props2.prevPage.value) {
      const newDate$1 = firstDate.subtract({ months: props2.pagedNavigation.value ? props2.numberOfMonths.value : 1 });
      const newGrid$1 = createMonths({
        dateObj: newDate$1,
        weekStartsOn: props2.weekStartsOn.value,
        locale: props2.locale.value,
        fixedWeeks: props2.fixedWeeks.value,
        numberOfMonths: props2.numberOfMonths.value
      });
      grid.value = newGrid$1;
      props2.placeholder.value = newGrid$1[0].value.set({ day: 1 });
      return;
    }
    const newDate = handlePrevPage(firstDate, prevPageFunc || props2.prevPage.value);
    const newGrid = createMonths({
      dateObj: newDate,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
    grid.value = newGrid;
    const duration = {};
    if (!prevPageFunc) {
      const diff = firstDate.compare(newGrid[0].value);
      if (diff >= getDaysInMonth(firstDate)) duration.day = 1;
      if (diff >= 365) duration.month = 1;
    }
    props2.placeholder.value = newGrid[0].value.set({ ...duration });
  };
  watch8(props2.placeholder, (value) => {
    if (visibleView.value.some((month) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(month, value))) return;
    grid.value = createMonths({
      dateObj: value,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
  });
  watch8([
    props2.locale,
    props2.weekStartsOn,
    props2.fixedWeeks,
    props2.numberOfMonths
  ], () => {
    grid.value = createMonths({
      dateObj: props2.placeholder.value,
      weekStartsOn: props2.weekStartsOn.value,
      locale: props2.locale.value,
      fixedWeeks: props2.fixedWeeks.value,
      numberOfMonths: props2.numberOfMonths.value
    });
  });
  const headingValue = computed21(() => {
    if (!grid.value.length) return "";
    if (props2.locale.value !== formatter.getLocale()) formatter.setLocale(props2.locale.value);
    if (grid.value.length === 1) {
      const month = grid.value[0].value;
      return `${formatter.fullMonthAndYear(toDate(month), headingFormatOptions.value)}`;
    }
    const startMonth = toDate(grid.value[0].value);
    const endMonth = toDate(grid.value[grid.value.length - 1].value);
    const startMonthName = formatter.fullMonth(startMonth, headingFormatOptions.value);
    const endMonthName = formatter.fullMonth(endMonth, headingFormatOptions.value);
    const startMonthYear = formatter.fullYear(startMonth, headingFormatOptions.value);
    const endMonthYear = formatter.fullYear(endMonth, headingFormatOptions.value);
    const content = startMonthYear === endMonthYear ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
    return content;
  });
  const fullCalendarLabel = computed21(() => `${props2.calendarLabel.value ?? "Event Date"}, ${headingValue.value}`);
  return {
    isDateDisabled,
    isDateUnavailable,
    isNextButtonDisabled,
    isPrevButtonDisabled,
    grid,
    weekdays,
    visibleView,
    isOutsideVisibleView,
    formatter,
    nextPage,
    prevPage,
    headingValue,
    fullCalendarLabel
  };
}

// node_modules/reka-ui/dist/Calendar/CalendarRoot.js
import { createBlock as createBlock36, createElementVNode, defineComponent as defineComponent43, onMounted as onMounted11, openBlock as openBlock37, renderSlot as renderSlot39, toDisplayString, toRefs as toRefs8, unref as unref41, watch as watch9, withCtx as withCtx36 } from "vue";
var _hoisted_1 = { style: {
  "border": "0px",
  "clip": "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  "height": "1px",
  "margin": "-1px",
  "overflow": "hidden",
  "padding": "0px",
  "position": "absolute",
  "white-space": "nowrap",
  "width": "1px"
} };
var _hoisted_2 = {
  role: "heading",
  "aria-level": "2"
};
var [injectCalendarRootContext, provideCalendarRootContext] = createContext("CalendarRoot");
var CalendarRoot_vue_vue_type_script_setup_true_lang_default = defineComponent43({
  __name: "CalendarRoot",
  props: {
    defaultValue: {
      type: null,
      required: false,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: false
    },
    placeholder: {
      type: null,
      required: false,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: false,
      default: false
    },
    preventDeselect: {
      type: Boolean,
      required: false,
      default: false
    },
    weekStartsOn: {
      type: Number,
      required: false,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: false,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: false
    },
    fixedWeeks: {
      type: Boolean,
      required: false,
      default: false
    },
    maxValue: {
      type: null,
      required: false
    },
    minValue: {
      type: null,
      required: false
    },
    locale: {
      type: String,
      required: false
    },
    numberOfMonths: {
      type: Number,
      required: false,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false,
      default: false
    },
    initialFocus: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateDisabled: {
      type: Function,
      required: false,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: false,
      default: void 0
    },
    dir: {
      type: String,
      required: false
    },
    nextPage: {
      type: Function,
      required: false
    },
    prevPage: {
      type: Function,
      required: false
    },
    modelValue: {
      type: null,
      required: false
    },
    multiple: {
      type: Boolean,
      required: false,
      default: false
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, initialFocus, pagedNavigation, weekStartsOn, weekdayFormat, fixedWeeks, multiple, minValue, maxValue, numberOfMonths, preventDeselect, isDateDisabled: propsIsDateDisabled, isDateUnavailable: propsIsDateUnavailable, calendarLabel, defaultValue, nextPage: propsNextPage, prevPage: propsPrevPage, dir: propDir, locale: propLocale, disableDaysOutsideCurrentView } = toRefs8(props2);
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      defaultValue: modelValue.value,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    function onPlaceholderChange(value) {
      placeholder.value = value.copy();
    }
    const { fullCalendarLabel, headingValue, isDateDisabled, isDateUnavailable, isNextButtonDisabled, isPrevButtonDisabled, weekdays, isOutsideVisibleView, nextPage, prevPage, formatter, grid } = useCalendar({
      locale,
      placeholder,
      weekStartsOn,
      fixedWeeks,
      numberOfMonths,
      minValue,
      maxValue,
      disabled,
      weekdayFormat,
      pagedNavigation,
      isDateDisabled: propsIsDateDisabled.value,
      isDateUnavailable: propsIsDateUnavailable.value,
      calendarLabel,
      nextPage: propsNextPage,
      prevPage: propsPrevPage
    });
    const { isInvalid, isDateSelected } = useCalendarState({
      date: modelValue,
      isDateDisabled,
      isDateUnavailable
    });
    watch9(modelValue, (_modelValue) => {
      if (Array.isArray(_modelValue) && _modelValue.length) {
        const lastValue = _modelValue[_modelValue.length - 1];
        if (lastValue && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(placeholder.value, lastValue)) onPlaceholderChange(lastValue);
      } else if (!Array.isArray(_modelValue) && _modelValue && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(placeholder.value, _modelValue)) onPlaceholderChange(_modelValue);
    });
    function onDateChange(value) {
      if (!multiple.value) {
        if (!modelValue.value) {
          modelValue.value = value.copy();
          return;
        }
        if (!preventDeselect.value && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(modelValue.value, value)) {
          placeholder.value = value.copy();
          modelValue.value = void 0;
        } else modelValue.value = value.copy();
      } else if (!modelValue.value) modelValue.value = [value.copy()];
      else if (Array.isArray(modelValue.value)) {
        const index = modelValue.value.findIndex((date) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, value));
        if (index === -1) modelValue.value = [...modelValue.value, value];
        else if (!preventDeselect.value) {
          const next = modelValue.value.filter((date) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(date, value));
          if (!next.length) {
            placeholder.value = value.copy();
            modelValue.value = void 0;
            return;
          }
          modelValue.value = next.map((date) => date.copy());
        }
      }
    }
    onMounted11(() => {
      if (initialFocus.value) handleCalendarInitialFocus(parentElement.value);
    });
    provideCalendarRootContext({
      isDateUnavailable,
      dir,
      isDateDisabled,
      locale,
      formatter,
      modelValue,
      placeholder,
      disabled,
      initialFocus,
      pagedNavigation,
      grid,
      weekDays: weekdays,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      multiple,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      fullCalendarLabel,
      headingValue,
      isInvalid,
      isDateSelected,
      isNextButtonDisabled,
      isPrevButtonDisabled,
      isOutsideVisibleView,
      nextPage,
      prevPage,
      parentElement,
      onPlaceholderChange,
      onDateChange,
      disableDaysOutsideCurrentView,
      minValue,
      maxValue
    });
    return (_ctx, _cache) => {
      return openBlock37(), createBlock36(unref41(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "application",
        "aria-label": unref41(fullCalendarLabel),
        "data-readonly": unref41(readonly3) ? "" : void 0,
        "data-disabled": unref41(disabled) ? "" : void 0,
        "data-invalid": unref41(isInvalid) ? "" : void 0,
        dir: unref41(dir)
      }, {
        default: withCtx36(() => [renderSlot39(_ctx.$slots, "default", {
          date: unref41(placeholder),
          grid: unref41(grid),
          weekDays: unref41(weekdays),
          weekStartsOn: unref41(weekStartsOn),
          locale: unref41(locale),
          fixedWeeks: unref41(fixedWeeks),
          modelValue: unref41(modelValue)
        }), createElementVNode("div", _hoisted_1, [createElementVNode("div", _hoisted_2, toDisplayString(unref41(fullCalendarLabel)), 1)])]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-label",
        "data-readonly",
        "data-disabled",
        "data-invalid",
        "dir"
      ]);
    };
  }
});
var CalendarRoot_default = CalendarRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarCell.js
import { createBlock as createBlock37, defineComponent as defineComponent44, openBlock as openBlock38, renderSlot as renderSlot40, unref as unref42, withCtx as withCtx37 } from "vue";
var CalendarCell_vue_vue_type_script_setup_true_lang_default = defineComponent44({
  __name: "CalendarCell",
  props: {
    date: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "td"
    }
  },
  setup(__props) {
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock38(), createBlock37(unref42(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "gridcell",
        "aria-selected": unref42(rootContext).isDateSelected(_ctx.date) ? true : void 0,
        "aria-disabled": unref42(rootContext).isDateDisabled(_ctx.date) || unref42(rootContext).isDateUnavailable?.(_ctx.date) || unref42(rootContext).disableDaysOutsideCurrentView.value,
        "data-disabled": unref42(rootContext).isDateDisabled(_ctx.date) || unref42(rootContext).disableDaysOutsideCurrentView.value ? "" : void 0
      }, {
        default: withCtx37(() => [renderSlot40(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-selected",
        "aria-disabled",
        "data-disabled"
      ]);
    };
  }
});
var CalendarCell_default = CalendarCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/utils.js
var SELECTOR = "[data-reka-calendar-cell-trigger]:not([data-outside-view]):not([data-outside-visible-view])";
function getSelectableCells(calendar) {
  return Array.from(calendar.querySelectorAll(SELECTOR)) ?? [];
}

// node_modules/reka-ui/dist/Calendar/CalendarCellTrigger.js
import { computed as computed22, createBlock as createBlock38, createTextVNode, defineComponent as defineComponent45, mergeProps as mergeProps18, nextTick as nextTick10, openBlock as openBlock39, renderSlot as renderSlot41, toDisplayString as toDisplayString2, unref as unref43, withCtx as withCtx38, withKeys as withKeys2, withModifiers as withModifiers2 } from "vue";
var CalendarCellTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent45({
  __name: "CalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: true
    },
    month: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const kbd = useKbd();
    const rootContext = injectCalendarRootContext();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const dayValue = computed22(() => props2.day.day.toLocaleString(rootContext.locale.value));
    const labelText = computed22(() => {
      return rootContext.formatter.custom(toDate(props2.day), {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      });
    });
    const isUnavailable = computed22(() => rootContext.isDateUnavailable?.(props2.day) ?? false);
    const isDateToday = computed22(() => {
      return $14e0f24ef4ac5c92$export$629b0a497aa65267(props2.day, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    });
    const isOutsideView = computed22(() => {
      return !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(props2.day, props2.month);
    });
    const isOutsideVisibleView = computed22(() => rootContext.isOutsideVisibleView(props2.day));
    const isDisabled = computed22(() => rootContext.isDateDisabled(props2.day) || rootContext.disableDaysOutsideCurrentView.value && isOutsideView.value);
    const isFocusedDate = computed22(() => {
      return !rootContext.disabled.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.day, rootContext.placeholder.value);
    });
    const isSelectedDate = computed22(() => rootContext.isDateSelected(props2.day));
    function changeDate(date) {
      if (rootContext.readonly.value) return;
      if (rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date)) return;
      rootContext.onDateChange(date);
    }
    function handleClick() {
      if (isDisabled.value) return;
      changeDate(props2.day);
    }
    function handleArrowKey(e) {
      if (isDisabled.value) return;
      e.preventDefault();
      e.stopPropagation();
      const parentElement = rootContext.parentElement.value;
      const indexIncrementation = 7;
      const sign = rootContext.dir.value === "rtl" ? -1 : 1;
      switch (e.code) {
        case kbd.ARROW_RIGHT:
          shiftFocus(currentElement.value, sign);
          break;
        case kbd.ARROW_LEFT:
          shiftFocus(currentElement.value, -sign);
          break;
        case kbd.ARROW_UP:
          shiftFocus(currentElement.value, -indexIncrementation);
          break;
        case kbd.ARROW_DOWN:
          shiftFocus(currentElement.value, indexIncrementation);
          break;
        case kbd.ENTER:
        case kbd.SPACE_CODE:
          changeDate(props2.day);
      }
      function shiftFocus(node, add) {
        const allCollectionItems = getSelectableCells(parentElement);
        if (!allCollectionItems.length) return;
        const index = allCollectionItems.indexOf(node);
        const newIndex = index + add;
        if (newIndex >= 0 && newIndex < allCollectionItems.length) {
          const newDate = allCollectionItems[newIndex].getAttribute("data-value");
          const newDateValue = parseStringToDateValue(newDate, rootContext.placeholder.value);
          const minValue = rootContext.minValue.value;
          const maxValue = rootContext.maxValue.value;
          if (minValue && newDateValue.compare(minValue) < 0 || maxValue && newDateValue.compare(maxValue) > 0) return;
          if (allCollectionItems[newIndex].hasAttribute("data-disabled")) shiftFocus(allCollectionItems[newIndex], add);
          rootContext.onPlaceholderChange(newDateValue);
          allCollectionItems[newIndex].focus();
          return;
        }
        if (newIndex < 0) {
          if (rootContext.isPrevButtonDisabled()) return;
          rootContext.prevPage();
          nextTick10(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length) return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(rootContext.placeholder.value);
              const computedIndex$1 = numberOfDays - Math.abs(newIndex);
              if (newCollectionItems[computedIndex$1].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex$1], add);
              const newDate$1 = newCollectionItems[computedIndex$1].getAttribute("data-value");
              newCollectionItems[computedIndex$1].focus();
              rootContext.onPlaceholderChange(parseStringToDateValue(newDate$1, rootContext.placeholder.value));
              return;
            }
            const computedIndex = newCollectionItems.length - Math.abs(newIndex);
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex], add);
            const newDate = newCollectionItems[computedIndex].getAttribute("data-value");
            rootContext.onPlaceholderChange(parseStringToDateValue(newDate, rootContext.placeholder.value));
            newCollectionItems[computedIndex].focus();
          });
          return;
        }
        if (newIndex >= allCollectionItems.length) {
          if (rootContext.isNextButtonDisabled()) return;
          rootContext.nextPage();
          nextTick10(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length) return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(rootContext.placeholder.value.add({ months: rootContext.numberOfMonths.value - 1 }));
              const computedIndex$1 = newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays);
              if (newCollectionItems[computedIndex$1].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex$1], add);
              const newDate$1 = newCollectionItems[computedIndex$1].getAttribute("data-value");
              rootContext.onPlaceholderChange(parseStringToDateValue(newDate$1, rootContext.placeholder.value));
              newCollectionItems[computedIndex$1].focus();
              return;
            }
            const computedIndex = newIndex - allCollectionItems.length;
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex], add);
            const newDate = newCollectionItems[computedIndex].getAttribute("data-value");
            rootContext.onPlaceholderChange(parseStringToDateValue(newDate, rootContext.placeholder.value));
            newCollectionItems[computedIndex].focus();
          });
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock39(), createBlock38(unref43(Primitive), mergeProps18({
        ref_key: "primitiveElement",
        ref: primitiveElement
      }, props2, {
        role: "button",
        "aria-label": labelText.value,
        "data-reka-calendar-cell-trigger": "",
        "aria-disabled": isDisabled.value || isUnavailable.value ? true : void 0,
        "data-selected": isSelectedDate.value ? true : void 0,
        "data-value": _ctx.day.toString(),
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-unavailable": isUnavailable.value ? "" : void 0,
        "data-today": isDateToday.value ? "" : void 0,
        "data-outside-view": isOutsideView.value ? "" : void 0,
        "data-outside-visible-view": isOutsideVisibleView.value ? "" : void 0,
        "data-focused": isFocusedDate.value ? "" : void 0,
        tabindex: isFocusedDate.value ? 0 : isOutsideView.value || isDisabled.value ? void 0 : -1,
        onClick: handleClick,
        onKeydown: [withKeys2(handleArrowKey, [
          "up",
          "down",
          "left",
          "right",
          "space",
          "enter"
        ]), _cache[0] || (_cache[0] = withKeys2(withModifiers2(() => {
        }, ["prevent"]), ["enter"]))]
      }), {
        default: withCtx38(() => [renderSlot41(_ctx.$slots, "default", {
          dayValue: dayValue.value,
          disabled: isDisabled.value,
          today: isDateToday.value,
          selected: isSelectedDate.value,
          outsideView: isOutsideView.value,
          outsideVisibleView: isOutsideVisibleView.value,
          unavailable: isUnavailable.value
        }, () => [createTextVNode(toDisplayString2(dayValue.value), 1)])]),
        _: 3
      }, 16, [
        "aria-label",
        "aria-disabled",
        "data-selected",
        "data-value",
        "data-disabled",
        "data-unavailable",
        "data-today",
        "data-outside-view",
        "data-outside-visible-view",
        "data-focused",
        "tabindex"
      ]);
    };
  }
});
var CalendarCellTrigger_default = CalendarCellTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarGrid.js
import { computed as computed23, createBlock as createBlock39, defineComponent as defineComponent46, mergeProps as mergeProps19, openBlock as openBlock40, renderSlot as renderSlot42, unref as unref44, withCtx as withCtx39 } from "vue";
var CalendarGrid_vue_vue_type_script_setup_true_lang_default = defineComponent46({
  __name: "CalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "table"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectCalendarRootContext();
    const disabled = computed23(() => rootContext.disabled.value ? true : void 0);
    const readonly3 = computed23(() => rootContext.readonly.value ? true : void 0);
    return (_ctx, _cache) => {
      return openBlock40(), createBlock39(unref44(Primitive), mergeProps19(props2, {
        tabindex: "-1",
        role: "grid",
        "aria-readonly": readonly3.value,
        "aria-disabled": disabled.value,
        "data-readonly": readonly3.value && "",
        "data-disabled": disabled.value && ""
      }), {
        default: withCtx39(() => [renderSlot42(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-readonly",
        "aria-disabled",
        "data-readonly",
        "data-disabled"
      ]);
    };
  }
});
var CalendarGrid_default = CalendarGrid_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarGridBody.js
import { createBlock as createBlock40, defineComponent as defineComponent47, guardReactiveProps as guardReactiveProps9, normalizeProps as normalizeProps9, openBlock as openBlock41, renderSlot as renderSlot43, unref as unref45, withCtx as withCtx40 } from "vue";
var CalendarGridBody_vue_vue_type_script_setup_true_lang_default = defineComponent47({
  __name: "CalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "tbody"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock41(), createBlock40(unref45(Primitive), normalizeProps9(guardReactiveProps9(props2)), {
        default: withCtx40(() => [renderSlot43(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var CalendarGridBody_default = CalendarGridBody_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarGridHead.js
import { createBlock as createBlock41, defineComponent as defineComponent48, mergeProps as mergeProps20, openBlock as openBlock42, renderSlot as renderSlot44, unref as unref46, withCtx as withCtx41 } from "vue";
var CalendarGridHead_vue_vue_type_script_setup_true_lang_default = defineComponent48({
  __name: "CalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "thead"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock42(), createBlock41(unref46(Primitive), mergeProps20(props2, { "aria-hidden": "true" }), {
        default: withCtx41(() => [renderSlot44(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var CalendarGridHead_default = CalendarGridHead_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarGridRow.js
import { createBlock as createBlock42, defineComponent as defineComponent49, guardReactiveProps as guardReactiveProps10, normalizeProps as normalizeProps10, openBlock as openBlock43, renderSlot as renderSlot45, unref as unref47, withCtx as withCtx42 } from "vue";
var CalendarGridRow_vue_vue_type_script_setup_true_lang_default = defineComponent49({
  __name: "CalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "tr"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock43(), createBlock42(unref47(Primitive), normalizeProps10(guardReactiveProps10(props2)), {
        default: withCtx42(() => [renderSlot45(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var CalendarGridRow_default = CalendarGridRow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarHeadCell.js
import { createBlock as createBlock43, defineComponent as defineComponent50, guardReactiveProps as guardReactiveProps11, normalizeProps as normalizeProps11, openBlock as openBlock44, renderSlot as renderSlot46, unref as unref48, withCtx as withCtx43 } from "vue";
var CalendarHeadCell_vue_vue_type_script_setup_true_lang_default = defineComponent50({
  __name: "CalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "th"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock44(), createBlock43(unref48(Primitive), normalizeProps11(guardReactiveProps11(props2)), {
        default: withCtx43(() => [renderSlot46(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var CalendarHeadCell_default = CalendarHeadCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarHeader.js
import { createBlock as createBlock44, defineComponent as defineComponent51, guardReactiveProps as guardReactiveProps12, normalizeProps as normalizeProps12, openBlock as openBlock45, renderSlot as renderSlot47, unref as unref49, withCtx as withCtx44 } from "vue";
var CalendarHeader_vue_vue_type_script_setup_true_lang_default = defineComponent51({
  __name: "CalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock45(), createBlock44(unref49(Primitive), normalizeProps12(guardReactiveProps12(props2)), {
        default: withCtx44(() => [renderSlot47(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var CalendarHeader_default = CalendarHeader_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarHeading.js
import { createBlock as createBlock45, createTextVNode as createTextVNode2, defineComponent as defineComponent52, mergeProps as mergeProps21, openBlock as openBlock46, renderSlot as renderSlot48, toDisplayString as toDisplayString3, unref as unref50, withCtx as withCtx45 } from "vue";
var CalendarHeading_vue_vue_type_script_setup_true_lang_default = defineComponent52({
  __name: "CalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock46(), createBlock45(unref50(Primitive), mergeProps21(props2, { "data-disabled": unref50(rootContext).disabled.value ? "" : void 0 }), {
        default: withCtx45(() => [renderSlot48(_ctx.$slots, "default", { headingValue: unref50(rootContext).headingValue.value }, () => [createTextVNode2(toDisplayString3(unref50(rootContext).headingValue.value), 1)])]),
        _: 3
      }, 16, ["data-disabled"]);
    };
  }
});
var CalendarHeading_default = CalendarHeading_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarNext.js
import { computed as computed24, createBlock as createBlock46, createTextVNode as createTextVNode3, defineComponent as defineComponent53, openBlock as openBlock47, renderSlot as renderSlot49, unref as unref51, withCtx as withCtx46 } from "vue";
var CalendarNext_vue_vue_type_script_setup_true_lang_default = defineComponent53({
  __name: "CalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed24(() => rootContext.disabled.value || rootContext.isNextButtonDisabled(props2.nextPage));
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock47(), createBlock46(unref51(Primitive), {
        as: props2.as,
        "as-child": props2.asChild,
        "aria-label": "Next page",
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref51(rootContext).nextPage(props2.nextPage))
      }, {
        default: withCtx46(() => [renderSlot49(_ctx.$slots, "default", { disabled: disabled.value }, () => [_cache[1] || (_cache[1] = createTextVNode3(" Next page "))])]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "type",
        "aria-disabled",
        "data-disabled",
        "disabled"
      ]);
    };
  }
});
var CalendarNext_default = CalendarNext_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Calendar/CalendarPrev.js
import { computed as computed25, createBlock as createBlock47, createTextVNode as createTextVNode4, defineComponent as defineComponent54, openBlock as openBlock48, renderSlot as renderSlot50, unref as unref52, withCtx as withCtx47 } from "vue";
var CalendarPrev_vue_vue_type_script_setup_true_lang_default = defineComponent54({
  __name: "CalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed25(() => rootContext.disabled.value || rootContext.isPrevButtonDisabled(props2.prevPage));
    const rootContext = injectCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock48(), createBlock47(unref52(Primitive), {
        "aria-label": "Previous page",
        as: props2.as,
        "as-child": props2.asChild,
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref52(rootContext).prevPage(props2.prevPage))
      }, {
        default: withCtx47(() => [renderSlot50(_ctx.$slots, "default", { disabled: disabled.value }, () => [_cache[1] || (_cache[1] = createTextVNode4(" Prev page "))])]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "type",
        "aria-disabled",
        "data-disabled",
        "disabled"
      ]);
    };
  }
});
var CalendarPrev_default = CalendarPrev_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Collection/Collection.js
import { computed as computed26, defineComponent as defineComponent55, h as h5, inject as inject4, markRaw as markRaw2, provide as provide3, ref as ref26, watch as watch10, watchEffect as watchEffect10 } from "vue";
var ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(options = {}) {
  const { key = "", isProvider = false } = options;
  const injectionKey = `${key}CollectionProvider`;
  let context2;
  if (isProvider) {
    const itemMap = ref26(/* @__PURE__ */ new Map());
    const collectionRef = ref26();
    context2 = {
      collectionRef,
      itemMap
    };
    provide3(injectionKey, context2);
  } else context2 = inject4(injectionKey);
  const getItems = (includeDisabledItem = false) => {
    const collectionNode = context2.collectionRef.value;
    if (!collectionNode) return [];
    const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
    const items = Array.from(context2.itemMap.value.values());
    const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref));
    if (includeDisabledItem) return orderedItems;
    else return orderedItems.filter((i) => i.ref.dataset.disabled !== "");
  };
  const CollectionSlot = defineComponent55({
    name: "CollectionSlot",
    setup(_, { slots }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watch10(currentElement, () => {
        context2.collectionRef.value = currentElement.value;
      });
      return () => h5(Slot, { ref: primitiveElement }, slots);
    }
  });
  const CollectionItem = defineComponent55({
    name: "CollectionItem",
    inheritAttrs: false,
    props: { value: { validator: () => true } },
    setup(props2, { slots, attrs }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watchEffect10((cleanupFn) => {
        if (currentElement.value) {
          const key$1 = markRaw2(currentElement.value);
          context2.itemMap.value.set(key$1, {
            ref: currentElement.value,
            value: props2.value
          });
          cleanupFn(() => context2.itemMap.value.delete(key$1));
        }
      });
      return () => h5(Slot, {
        ...attrs,
        [ITEM_DATA_ATTR]: "",
        ref: primitiveElement
      }, slots);
    }
  });
  const reactiveItems = computed26(() => Array.from(context2.itemMap.value.values()));
  const itemMapSize = computed26(() => context2.itemMap.value.size);
  return {
    getItems,
    reactiveItems,
    itemMapSize,
    CollectionSlot,
    CollectionItem
  };
}

// node_modules/reka-ui/dist/RovingFocus/utils.js
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS2 = {
  bubbles: false,
  cancelable: true
};
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst3(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray2(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}

// node_modules/reka-ui/dist/RovingFocus/RovingFocusGroup.js
import { createBlock as createBlock48, createVNode as createVNode5, defineComponent as defineComponent56, openBlock as openBlock49, ref as ref27, renderSlot as renderSlot51, toRefs as toRefs9, unref as unref53, withCtx as withCtx48 } from "vue";
var [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext("RovingFocusGroup");
var RovingFocusGroup_vue_vue_type_script_setup_true_lang_default = defineComponent56({
  __name: "RovingFocusGroup",
  props: {
    orientation: {
      type: String,
      required: false,
      default: void 0
    },
    dir: {
      type: String,
      required: false
    },
    loop: {
      type: Boolean,
      required: false,
      default: false
    },
    currentTabStopId: {
      type: [String, null],
      required: false
    },
    defaultCurrentTabStopId: {
      type: String,
      required: false
    },
    preventScrollOnEntryFocus: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { loop, orientation, dir: propDir } = toRefs9(props2);
    const dir = useDirection(propDir);
    const currentTabStopId = useVModel(props2, "currentTabStopId", emits, {
      defaultValue: props2.defaultCurrentTabStopId,
      passive: props2.currentTabStopId === void 0
    });
    const isTabbingBackOut = ref27(false);
    const isClickFocus = ref27(false);
    const focusableItemsCount = ref27(0);
    const { getItems, CollectionSlot } = useCollection({ isProvider: true });
    function handleFocus(event) {
      const isKeyboardFocus = !isClickFocus.value;
      if (event.currentTarget && event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut.value) {
        const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS2);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        emits("entryFocus", entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "");
          const activeItem = items.find((item) => item.getAttribute("data-active") === "");
          const highlightedItem = items.find((item) => item.getAttribute("data-highlighted") === "");
          const currentItem = items.find((item) => item.id === currentTabStopId.value);
          const candidateItems = [
            activeItem,
            highlightedItem,
            currentItem,
            ...items
          ].filter(Boolean);
          focusFirst3(candidateItems, props2.preventScrollOnEntryFocus);
        }
      }
      isClickFocus.value = false;
    }
    function handleMouseUp() {
      setTimeout(() => {
        isClickFocus.value = false;
      }, 1);
    }
    __expose({ getItems });
    provideRovingFocusGroupContext({
      loop,
      dir,
      orientation,
      currentTabStopId,
      onItemFocus: (tabStopId) => {
        currentTabStopId.value = tabStopId;
      },
      onItemShiftTab: () => {
        isTabbingBackOut.value = true;
      },
      onFocusableItemAdd: () => {
        focusableItemsCount.value++;
      },
      onFocusableItemRemove: () => {
        focusableItemsCount.value--;
      }
    });
    return (_ctx, _cache) => {
      return openBlock49(), createBlock48(unref53(CollectionSlot), null, {
        default: withCtx48(() => [createVNode5(unref53(Primitive), {
          tabindex: isTabbingBackOut.value || focusableItemsCount.value === 0 ? -1 : 0,
          "data-orientation": unref53(orientation),
          as: _ctx.as,
          "as-child": _ctx.asChild,
          dir: unref53(dir),
          style: { "outline": "none" },
          onMousedown: _cache[0] || (_cache[0] = ($event) => isClickFocus.value = true),
          onMouseup: handleMouseUp,
          onFocus: handleFocus,
          onBlur: _cache[1] || (_cache[1] = ($event) => isTabbingBackOut.value = false)
        }, {
          default: withCtx48(() => [renderSlot51(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "tabindex",
          "data-orientation",
          "as",
          "as-child",
          "dir"
        ])]),
        _: 3
      });
    };
  }
});
var RovingFocusGroup_default = RovingFocusGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RovingFocus/RovingFocusItem.js
import { computed as computed27, createBlock as createBlock49, createVNode as createVNode6, defineComponent as defineComponent57, nextTick as nextTick11, onMounted as onMounted12, onUnmounted as onUnmounted6, openBlock as openBlock50, renderSlot as renderSlot52, unref as unref54, withCtx as withCtx49 } from "vue";
var RovingFocusItem_vue_vue_type_script_setup_true_lang_default = defineComponent57({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {
      type: String,
      required: false
    },
    focusable: {
      type: Boolean,
      required: false,
      default: true
    },
    active: {
      type: Boolean,
      required: false
    },
    allowShiftKey: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectRovingFocusGroupContext();
    const randomId = useId2();
    const id = computed27(() => props2.tabStopId || randomId);
    const isCurrentTabStop = computed27(() => context2.currentTabStopId.value === id.value);
    const { getItems, CollectionItem } = useCollection();
    onMounted12(() => {
      if (props2.focusable) context2.onFocusableItemAdd();
    });
    onUnmounted6(() => {
      if (props2.focusable) context2.onFocusableItemRemove();
    });
    function handleKeydown(event) {
      if (event.key === "Tab" && event.shiftKey) {
        context2.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget) return;
      const focusIntent = getFocusIntent(event, context2.orientation.value, context2.dir.value);
      if (focusIntent !== void 0) {
        if (event.metaKey || event.ctrlKey || event.altKey || (props2.allowShiftKey ? false : event.shiftKey)) return;
        event.preventDefault();
        let candidateNodes = [...getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "")];
        if (focusIntent === "last") candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev") candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context2.loop.value ? wrapArray2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        nextTick11(() => focusFirst3(candidateNodes));
      }
    }
    return (_ctx, _cache) => {
      return openBlock50(), createBlock49(unref54(CollectionItem), null, {
        default: withCtx49(() => [createVNode6(unref54(Primitive), {
          tabindex: isCurrentTabStop.value ? 0 : -1,
          "data-orientation": unref54(context2).orientation.value,
          "data-active": _ctx.active ? "" : void 0,
          "data-disabled": !_ctx.focusable ? "" : void 0,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          onMousedown: _cache[0] || (_cache[0] = (event) => {
            if (!_ctx.focusable) event.preventDefault();
            else unref54(context2).onItemFocus(id.value);
          }),
          onFocus: _cache[1] || (_cache[1] = ($event) => unref54(context2).onItemFocus(id.value)),
          onKeydown: handleKeydown
        }, {
          default: withCtx49(() => [renderSlot52(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "tabindex",
          "data-orientation",
          "data-active",
          "data-disabled",
          "as",
          "as-child"
        ])]),
        _: 3
      });
    };
  }
});
var RovingFocusItem_default = RovingFocusItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHidden.js
import { createBlock as createBlock50, defineComponent as defineComponent58, openBlock as openBlock51, renderSlot as renderSlot53, unref as unref55, withCtx as withCtx50 } from "vue";
var VisuallyHidden_vue_vue_type_script_setup_true_lang_default = defineComponent58({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: false,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock51(), createBlock50(unref55(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-hidden": _ctx.feature === "focusable" ? "true" : void 0,
        "data-hidden": _ctx.feature === "fully-hidden" ? "" : void 0,
        tabindex: _ctx.feature === "fully-hidden" ? "-1" : void 0,
        style: {
          position: "absolute",
          border: 0,
          width: "1px",
          height: "1px",
          padding: 0,
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          clipPath: "inset(50%)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          top: "-1px",
          left: "-1px"
        }
      }, {
        default: withCtx50(() => [renderSlot53(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-hidden",
        "data-hidden",
        "tabindex"
      ]);
    };
  }
});
var VisuallyHidden_default = VisuallyHidden_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHiddenInputBubble.js
import { computed as computed28, createBlock as createBlock51, defineComponent as defineComponent59, mergeProps as mergeProps22, openBlock as openBlock52, watch as watch11 } from "vue";
var VisuallyHiddenInputBubble_vue_vue_type_script_setup_true_lang_default = defineComponent59({
  inheritAttrs: false,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {
      type: String,
      required: true
    },
    value: {
      type: null,
      required: true
    },
    checked: {
      type: Boolean,
      required: false,
      default: void 0
    },
    required: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    feature: {
      type: String,
      required: false,
      default: "fully-hidden"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const valueState = computed28(() => props2.checked ?? props2.value);
    watch11(valueState, (cur, prev) => {
      if (!currentElement.value) return;
      const input = currentElement.value;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (setValue && cur !== prev) {
        const inputEvent = new Event("input", { bubbles: true });
        const changeEvent = new Event("change", { bubbles: true });
        setValue.call(input, cur);
        input.dispatchEvent(inputEvent);
        input.dispatchEvent(changeEvent);
      }
    });
    return (_ctx, _cache) => {
      return openBlock52(), createBlock51(VisuallyHidden_default, mergeProps22({
        ref_key: "primitiveElement",
        ref: primitiveElement
      }, {
        ...props2,
        ..._ctx.$attrs
      }, { as: "input" }), null, 16);
    };
  }
});
var VisuallyHiddenInputBubble_default = VisuallyHiddenInputBubble_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/VisuallyHidden/VisuallyHiddenInput.js
import { Fragment as Fragment3, computed as computed29, createBlock as createBlock52, createCommentVNode as createCommentVNode6, createElementBlock as createElementBlock2, defineComponent as defineComponent60, mergeProps as mergeProps23, openBlock as openBlock53, renderList } from "vue";
var VisuallyHiddenInput_vue_vue_type_script_setup_true_lang_default = defineComponent60({
  inheritAttrs: false,
  __name: "VisuallyHiddenInput",
  props: {
    name: {
      type: String,
      required: true
    },
    value: {
      type: null,
      required: true
    },
    checked: {
      type: Boolean,
      required: false,
      default: void 0
    },
    required: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    feature: {
      type: String,
      required: false,
      default: "fully-hidden"
    }
  },
  setup(__props) {
    const props2 = __props;
    const isFormArrayEmptyAndRequired = computed29(() => typeof props2.value === "object" && Array.isArray(props2.value) && props2.value.length === 0 && props2.required);
    const parsedValue = computed29(() => {
      if (typeof props2.value === "string" || typeof props2.value === "number" || typeof props2.value === "boolean" || props2.value === null || props2.value === void 0) return [{
        name: props2.name,
        value: props2.value
      }];
      else if (typeof props2.value === "object" && Array.isArray(props2.value)) return props2.value.flatMap((obj, index) => {
        if (typeof obj === "object") return Object.entries(obj).map(([key, value]) => ({
          name: `${props2.name}[${index}][${key}]`,
          value
        }));
        else return {
          name: `${props2.name}[${index}]`,
          value: obj
        };
      });
      else if (props2.value !== null && typeof props2.value === "object" && !Array.isArray(props2.value)) return Object.entries(props2.value).map(([key, value]) => ({
        name: `${props2.name}[${key}]`,
        value
      }));
      return [];
    });
    return (_ctx, _cache) => {
      return openBlock53(), createElementBlock2(Fragment3, null, [createCommentVNode6(" We render single input if it's required "), isFormArrayEmptyAndRequired.value ? (openBlock53(), createBlock52(VisuallyHiddenInputBubble_default, mergeProps23({ key: _ctx.name }, {
        ...props2,
        ..._ctx.$attrs
      }, {
        name: _ctx.name,
        value: _ctx.value
      }), null, 16, ["name", "value"])) : (openBlock53(true), createElementBlock2(Fragment3, { key: 1 }, renderList(parsedValue.value, (parsed) => {
        return openBlock53(), createBlock52(VisuallyHiddenInputBubble_default, mergeProps23({ key: parsed.name }, { ref_for: true }, {
          ...props2,
          ..._ctx.$attrs
        }, {
          name: parsed.name,
          value: parsed.value
        }), null, 16, ["name", "value"]);
      }), 128))], 2112);
    };
  }
});
var VisuallyHiddenInput_default = VisuallyHiddenInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Checkbox/CheckboxGroupRoot.js
import { computed as computed30, createBlock as createBlock53, createCommentVNode as createCommentVNode7, defineComponent as defineComponent61, mergeProps as mergeProps24, openBlock as openBlock54, renderSlot as renderSlot54, resolveDynamicComponent, toRefs as toRefs10, unref as unref56, withCtx as withCtx51 } from "vue";
var [injectCheckboxGroupRootContext, provideCheckboxGroupRootContext] = createContext("CheckboxGroupRoot");
var CheckboxGroupRoot_vue_vue_type_script_setup_true_lang_default = defineComponent61({
  __name: "CheckboxGroupRoot",
  props: {
    defaultValue: {
      type: Array,
      required: false
    },
    modelValue: {
      type: Array,
      required: false
    },
    rovingFocus: {
      type: Boolean,
      required: false,
      default: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    orientation: {
      type: String,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, rovingFocus, dir: propDir } = toRefs10(props2);
    const dir = useDirection(propDir);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const isFormControl = useFormControl(currentElement);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? [],
      passive: props2.modelValue === void 0
    });
    const rovingFocusProps = computed30(() => {
      return rovingFocus.value ? {
        loop: props2.loop,
        dir: dir.value,
        orientation: props2.orientation
      } : {};
    });
    provideCheckboxGroupRootContext({
      modelValue,
      rovingFocus,
      disabled
    });
    return (_ctx, _cache) => {
      return openBlock54(), createBlock53(resolveDynamicComponent(unref56(rovingFocus) ? unref56(RovingFocusGroup_default) : unref56(Primitive)), mergeProps24({
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, rovingFocusProps.value), {
        default: withCtx51(() => [renderSlot54(_ctx.$slots, "default"), unref56(isFormControl) && _ctx.name ? (openBlock54(), createBlock53(unref56(VisuallyHiddenInput_default), {
          key: 0,
          name: _ctx.name,
          value: unref56(modelValue),
          required: _ctx.required
        }, null, 8, [
          "name",
          "value",
          "required"
        ])) : createCommentVNode7("v-if", true)]),
        _: 3
      }, 16, ["as", "as-child"]);
    };
  }
});
var CheckboxGroupRoot_default = CheckboxGroupRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Checkbox/utils.js
function isIndeterminate2(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate2(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}

// node_modules/reka-ui/dist/Checkbox/CheckboxRoot.js
import { computed as computed31, createBlock as createBlock54, createCommentVNode as createCommentVNode8, defineComponent as defineComponent62, mergeProps as mergeProps25, openBlock as openBlock55, renderSlot as renderSlot55, resolveDynamicComponent as resolveDynamicComponent2, unref as unref57, withCtx as withCtx52, withKeys as withKeys3, withModifiers as withModifiers3 } from "vue";
var [injectCheckboxRootContext, provideCheckboxRootContext] = createContext("CheckboxRoot");
var CheckboxRoot_vue_vue_type_script_setup_true_lang_default = defineComponent62({
  inheritAttrs: false,
  __name: "CheckboxRoot",
  props: {
    defaultValue: {
      type: [Boolean, String],
      required: false
    },
    modelValue: {
      type: [
        Boolean,
        String,
        null
      ],
      required: false,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: false
    },
    value: {
      type: null,
      required: false,
      default: "on"
    },
    id: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const checkboxGroupContext = injectCheckboxGroupRootContext(null);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const disabled = computed31(() => checkboxGroupContext?.disabled.value || props2.disabled);
    const checkboxState = computed31(() => {
      if (!isNullish(checkboxGroupContext?.modelValue.value)) return isValueEqualOrExist(checkboxGroupContext.modelValue.value, props2.value);
      else return modelValue.value === "indeterminate" ? "indeterminate" : modelValue.value;
    });
    function handleClick() {
      if (!isNullish(checkboxGroupContext?.modelValue.value)) {
        const modelValueArray = [...checkboxGroupContext.modelValue.value || []];
        if (isValueEqualOrExist(modelValueArray, props2.value)) {
          const index = modelValueArray.findIndex((i) => isEqual(i, props2.value));
          modelValueArray.splice(index, 1);
        } else modelValueArray.push(props2.value);
        checkboxGroupContext.modelValue.value = modelValueArray;
      } else modelValue.value = isIndeterminate2(modelValue.value) ? true : !modelValue.value;
    }
    const isFormControl = useFormControl(currentElement);
    const ariaLabel = computed31(() => props2.id && currentElement.value ? document.querySelector(`[for="${props2.id}"]`)?.innerText : void 0);
    provideCheckboxRootContext({
      disabled,
      state: checkboxState
    });
    return (_ctx, _cache) => {
      return openBlock55(), createBlock54(resolveDynamicComponent2(unref57(checkboxGroupContext)?.rovingFocus.value ? unref57(RovingFocusItem_default) : unref57(Primitive)), mergeProps25(_ctx.$attrs, {
        id: _ctx.id,
        ref: unref57(forwardRef),
        role: "checkbox",
        "as-child": _ctx.asChild,
        as: _ctx.as,
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-checked": unref57(isIndeterminate2)(checkboxState.value) ? "mixed" : checkboxState.value,
        "aria-required": _ctx.required,
        "aria-label": _ctx.$attrs["aria-label"] || ariaLabel.value,
        "data-state": unref57(getState)(checkboxState.value),
        "data-disabled": disabled.value ? "" : void 0,
        disabled: disabled.value,
        focusable: unref57(checkboxGroupContext)?.rovingFocus.value ? !disabled.value : void 0,
        onKeydown: withKeys3(withModifiers3(() => {
        }, ["prevent"]), ["enter"]),
        onClick: handleClick
      }), {
        default: withCtx52(() => [renderSlot55(_ctx.$slots, "default", {
          modelValue: unref57(modelValue),
          state: checkboxState.value
        }), unref57(isFormControl) && _ctx.name && !unref57(checkboxGroupContext) ? (openBlock55(), createBlock54(unref57(VisuallyHiddenInput_default), {
          key: 0,
          type: "checkbox",
          checked: !!checkboxState.value,
          name: _ctx.name,
          value: _ctx.value,
          disabled: disabled.value,
          required: _ctx.required
        }, null, 8, [
          "checked",
          "name",
          "value",
          "disabled",
          "required"
        ])) : createCommentVNode8("v-if", true)]),
        _: 3
      }, 16, [
        "id",
        "as-child",
        "as",
        "type",
        "aria-checked",
        "aria-required",
        "aria-label",
        "data-state",
        "data-disabled",
        "disabled",
        "focusable",
        "onKeydown"
      ]);
    };
  }
});
var CheckboxRoot_default = CheckboxRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Checkbox/CheckboxIndicator.js
import { createBlock as createBlock55, createVNode as createVNode7, defineComponent as defineComponent63, mergeProps as mergeProps26, openBlock as openBlock56, renderSlot as renderSlot56, unref as unref58, withCtx as withCtx53 } from "vue";
var CheckboxIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent63({
  __name: "CheckboxIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const rootContext = injectCheckboxRootContext();
    return (_ctx, _cache) => {
      return openBlock56(), createBlock55(unref58(Presence_default), { present: _ctx.forceMount || unref58(isIndeterminate2)(unref58(rootContext).state.value) || unref58(rootContext).state.value === true }, {
        default: withCtx53(() => [createVNode7(unref58(Primitive), mergeProps26({
          ref: unref58(forwardRef),
          "data-state": unref58(getState)(unref58(rootContext).state.value),
          "data-disabled": unref58(rootContext).disabled.value ? "" : void 0,
          style: { pointerEvents: "none" },
          "as-child": _ctx.asChild,
          as: _ctx.as
        }, _ctx.$attrs), {
          default: withCtx53(() => [renderSlot56(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "data-state",
          "data-disabled",
          "as-child",
          "as"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var CheckboxIndicator_default = CheckboxIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popper/PopperRoot.js
import { defineComponent as defineComponent64, ref as ref28, renderSlot as renderSlot57 } from "vue";
var [injectPopperRootContext, providePopperRootContext] = createContext("PopperRoot");
var PopperRoot_vue_vue_type_script_setup_true_lang_default = defineComponent64({
  inheritAttrs: false,
  __name: "PopperRoot",
  setup(__props) {
    const anchor = ref28();
    providePopperRootContext({
      anchor,
      onAnchorChange: (element) => anchor.value = element
    });
    return (_ctx, _cache) => {
      return renderSlot57(_ctx.$slots, "default");
    };
  }
});
var PopperRoot_default = PopperRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popper/PopperAnchor.js
import { createBlock as createBlock56, defineComponent as defineComponent65, openBlock as openBlock57, renderSlot as renderSlot58, unref as unref59, watchPostEffect, withCtx as withCtx54 } from "vue";
var PopperAnchor_vue_vue_type_script_setup_true_lang_default = defineComponent65({
  __name: "PopperAnchor",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectPopperRootContext();
    watchPostEffect(() => {
      rootContext.onAnchorChange(props2.reference ?? currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock57(), createBlock56(unref59(Primitive), {
        ref: unref59(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx54(() => [renderSlot58(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});
var PopperAnchor_default = PopperAnchor_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/component/Arrow.js
import { createBlock as createBlock57, createCommentVNode as createCommentVNode9, createElementBlock as createElementBlock3, defineComponent as defineComponent66, mergeProps as mergeProps27, openBlock as openBlock58, renderSlot as renderSlot59, unref as unref60, withCtx as withCtx55 } from "vue";
var _hoisted_12 = {
  key: 0,
  d: "M0 0L6 6L12 0"
};
var _hoisted_22 = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
};
var Arrow_vue_vue_type_script_setup_true_lang_default = defineComponent66({
  __name: "Arrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock58(), createBlock57(unref60(Primitive), mergeProps27(props2, {
        width: _ctx.width,
        height: _ctx.height,
        viewBox: _ctx.asChild ? void 0 : "0 0 12 6",
        preserveAspectRatio: _ctx.asChild ? void 0 : "none"
      }), {
        default: withCtx55(() => [renderSlot59(_ctx.$slots, "default", {}, () => [!_ctx.rounded ? (openBlock58(), createElementBlock3("path", _hoisted_12)) : (openBlock58(), createElementBlock3("path", _hoisted_22))])]),
        _: 3
      }, 16, [
        "width",
        "height",
        "viewBox",
        "preserveAspectRatio"
      ]);
    };
  }
});
var Arrow_default = Arrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popper/utils.js
function isNotNull(value) {
  return value !== null;
}
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (placedSide === "bottom") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: {
        x,
        y
      } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}

// node_modules/reka-ui/dist/Popper/PopperContent.js
import { computed as computed33, createElementBlock as createElementBlock4, createVNode as createVNode8, defineComponent as defineComponent67, mergeDefaults, mergeProps as mergeProps28, normalizeStyle as normalizeStyle3, openBlock as openBlock59, ref as ref30, renderSlot as renderSlot60, unref as unref62, watchEffect as watchEffect11, watchPostEffect as watchPostEffect2, withCtx as withCtx56 } from "vue";

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp3(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp3(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp3(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp3(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs
import { unref as unref61, computed as computed32, ref as ref29, shallowRef as shallowRef3, watch as watch12, getCurrentScope as getCurrentScope3, onScopeDispose as onScopeDispose2, shallowReadonly } from "vue-demi";
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement2(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function toValue4(source) {
  return typeof source === "function" ? source() : unref61(source);
}
function arrow3(options) {
  return {
    name: "arrow",
    options,
    fn(args) {
      const element = unwrapElement2(toValue4(options.element));
      if (element == null) {
        return {};
      }
      return arrow2({
        element,
        padding: options.padding
      }).fn(args);
    }
  };
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed32(() => {
    var _toValue;
    return (_toValue = toValue4(options.open)) != null ? _toValue : true;
  });
  const middlewareOption = computed32(() => toValue4(options.middleware));
  const placementOption = computed32(() => {
    var _toValue2;
    return (_toValue2 = toValue4(options.placement)) != null ? _toValue2 : "bottom";
  });
  const strategyOption = computed32(() => {
    var _toValue3;
    return (_toValue3 = toValue4(options.strategy)) != null ? _toValue3 : "absolute";
  });
  const transformOption = computed32(() => {
    var _toValue4;
    return (_toValue4 = toValue4(options.transform)) != null ? _toValue4 : true;
  });
  const referenceElement = computed32(() => unwrapElement2(reference.value));
  const floatingElement = computed32(() => unwrapElement2(floating.value));
  const x = ref29(0);
  const y = ref29(0);
  const strategy = ref29(strategyOption.value);
  const placement = ref29(placementOption.value);
  const middlewareData = shallowRef3({});
  const isPositioned = ref29(false);
  const floatingStyles = computed32(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x.value);
    const yVal = roundByDPR(floatingElement.value, y.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    const open = openOption.value;
    computePosition2(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = open !== false;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch12([middlewareOption, placementOption, strategyOption, openOption], update, {
    flush: "sync"
  });
  watch12([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch12(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope3()) {
    onScopeDispose2(cleanup);
  }
  return {
    x: shallowReadonly(x),
    y: shallowReadonly(y),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}

// node_modules/reka-ui/dist/Popper/PopperContent.js
var PopperContentPropsDefaultValue = {
  side: "bottom",
  sideOffset: 0,
  sideFlip: true,
  align: "center",
  alignOffset: 0,
  alignFlip: true,
  arrowPadding: 0,
  avoidCollisions: true,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: false,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: false
};
var [injectPopperContentContext, providePopperContentContext] = createContext("PopperContent");
var PopperContent_vue_vue_type_script_setup_true_lang_default = defineComponent67({
  inheritAttrs: false,
  __name: "PopperContent",
  props: mergeDefaults({
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  }, { ...PopperContentPropsDefaultValue }),
  emits: ["placed"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopperRootContext();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const floatingRef = ref30();
    const arrow$1 = ref30();
    const { width: arrowWidth, height: arrowHeight } = useSize(arrow$1);
    const desiredPlacement = computed33(() => props2.side + (props2.align !== "center" ? `-${props2.align}` : ""));
    const collisionPadding = computed33(() => {
      return typeof props2.collisionPadding === "number" ? props2.collisionPadding : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...props2.collisionPadding
      };
    });
    const boundary = computed33(() => {
      return Array.isArray(props2.collisionBoundary) ? props2.collisionBoundary : [props2.collisionBoundary];
    });
    const detectOverflowOptions = computed33(() => {
      return {
        padding: collisionPadding.value,
        boundary: boundary.value.filter(isNotNull),
        altBoundary: boundary.value.length > 0
      };
    });
    const flipOptions = computed33(() => {
      return {
        mainAxis: props2.sideFlip,
        crossAxis: props2.alignFlip
      };
    });
    const computedMiddleware = computedEager(() => {
      return [
        offset2({
          mainAxis: props2.sideOffset + arrowHeight.value,
          alignmentAxis: props2.alignOffset
        }),
        props2.prioritizePosition && props2.avoidCollisions && flip2({
          ...detectOverflowOptions.value,
          ...flipOptions.value
        }),
        props2.avoidCollisions && shift2({
          mainAxis: true,
          crossAxis: !!props2.prioritizePosition,
          limiter: props2.sticky === "partial" ? limitShift2() : void 0,
          ...detectOverflowOptions.value
        }),
        !props2.prioritizePosition && props2.avoidCollisions && flip2({
          ...detectOverflowOptions.value,
          ...flipOptions.value
        }),
        size2({
          ...detectOverflowOptions.value,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--reka-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--reka-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--reka-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--reka-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$1.value && arrow3({
          element: arrow$1.value,
          padding: props2.arrowPadding
        }),
        transformOrigin({
          arrowWidth: arrowWidth.value,
          arrowHeight: arrowHeight.value
        }),
        props2.hideWhenDetached && hide2({
          strategy: "referenceHidden",
          ...detectOverflowOptions.value
        })
      ];
    });
    const reference = computed33(() => props2.reference ?? rootContext.anchor.value);
    const { floatingStyles, placement, isPositioned, middlewareData, update } = useFloating(reference, floatingRef, {
      strategy: props2.positionStrategy,
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          layoutShift: !props2.disableUpdateOnLayoutShift,
          animationFrame: props2.updatePositionStrategy === "always"
        });
        return cleanup;
      },
      middleware: computedMiddleware
    });
    const placedSide = computed33(() => getSideAndAlignFromPlacement(placement.value)[0]);
    const placedAlign = computed33(() => getSideAndAlignFromPlacement(placement.value)[1]);
    watchPostEffect2(() => {
      if (isPositioned.value) emits("placed");
    });
    const cannotCenterArrow = computed33(() => middlewareData.value.arrow?.centerOffset !== 0);
    const contentZIndex = ref30("");
    watchEffect11(() => {
      if (contentElement.value) contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
    });
    const arrowX = computed33(() => middlewareData.value.arrow?.x ?? 0);
    const arrowY = computed33(() => middlewareData.value.arrow?.y ?? 0);
    providePopperContentContext({
      placedSide,
      onArrowChange: (element) => arrow$1.value = element,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    });
    return (_ctx, _cache) => {
      return openBlock59(), createElementBlock4("div", {
        ref_key: "floatingRef",
        ref: floatingRef,
        "data-reka-popper-content-wrapper": "",
        style: normalizeStyle3({
          ...unref62(floatingStyles),
          transform: unref62(isPositioned) ? unref62(floatingStyles).transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: contentZIndex.value,
          ["--reka-popper-transform-origin"]: [unref62(middlewareData).transformOrigin?.x, unref62(middlewareData).transformOrigin?.y].join(" "),
          ...unref62(middlewareData).hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        })
      }, [createVNode8(unref62(Primitive), mergeProps28({ ref: unref62(forwardRef) }, _ctx.$attrs, {
        "as-child": props2.asChild,
        as: _ctx.as,
        "data-side": placedSide.value,
        "data-align": placedAlign.value,
        style: { animation: !unref62(isPositioned) ? "none" : void 0 }
      }), {
        default: withCtx56(() => [renderSlot60(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "as-child",
        "as",
        "data-side",
        "data-align",
        "style"
      ])], 4);
    };
  }
});
var PopperContent_default = PopperContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popper/PopperArrow.js
import { computed as computed34, createElementBlock as createElementBlock5, createVNode as createVNode9, defineComponent as defineComponent68, mergeProps as mergeProps29, normalizeStyle as normalizeStyle4, openBlock as openBlock60, renderSlot as renderSlot61, unref as unref63, withCtx as withCtx57 } from "vue";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow_vue_vue_type_script_setup_true_lang_default = defineComponent68({
  inheritAttrs: false,
  __name: "PopperArrow",
  props: {
    width: {
      type: Number,
      required: false
    },
    height: {
      type: Number,
      required: false
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const contentContext = injectPopperContentContext();
    const baseSide = computed34(() => OPPOSITE_SIDE[contentContext.placedSide.value]);
    return (_ctx, _cache) => {
      return openBlock60(), createElementBlock5("span", {
        ref: (el) => {
          unref63(contentContext).onArrowChange(el);
          return void 0;
        },
        style: normalizeStyle4({
          position: "absolute",
          left: unref63(contentContext).arrowX?.value ? `${unref63(contentContext).arrowX?.value}px` : void 0,
          top: unref63(contentContext).arrowY?.value ? `${unref63(contentContext).arrowY?.value}px` : void 0,
          [baseSide.value]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[unref63(contentContext).placedSide.value],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[unref63(contentContext).placedSide.value],
          visibility: unref63(contentContext).shouldHideArrow.value ? "hidden" : void 0
        })
      }, [createVNode9(Arrow_default, mergeProps29(_ctx.$attrs, {
        ref: unref63(forwardRef),
        style: { display: "block" },
        as: _ctx.as,
        "as-child": _ctx.asChild,
        rounded: _ctx.rounded,
        width: _ctx.width,
        height: _ctx.height
      }), {
        default: withCtx57(() => [renderSlot61(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "rounded",
        "width",
        "height"
      ])], 4);
    };
  }
});
var PopperArrow_default = PopperArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxAnchor.js
import { createBlock as createBlock58, createVNode as createVNode10, defineComponent as defineComponent69, mergeProps as mergeProps30, openBlock as openBlock61, renderSlot as renderSlot62, unref as unref64, withCtx as withCtx58 } from "vue";
var ComboboxAnchor_vue_vue_type_script_setup_true_lang_default = defineComponent69({
  __name: "ComboboxAnchor",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock61(), createBlock58(unref64(PopperAnchor_default), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx58(() => [createVNode10(unref64(Primitive), mergeProps30({
          ref: unref64(forwardRef),
          "as-child": _ctx.asChild,
          as: _ctx.as
        }, _ctx.$attrs), {
          default: withCtx58(() => [renderSlot62(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["as-child", "as"])]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});
var ComboboxAnchor_default = ComboboxAnchor_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/utils.js
function queryCheckedElement(parentEl) {
  return parentEl?.querySelector("[data-state=checked]");
}
function valueComparator(value, currentValue, comparator) {
  if (value === void 0) return false;
  else if (Array.isArray(value)) return value.some((val) => compare(val, currentValue, comparator));
  else return compare(value, currentValue, comparator);
}
function compare(value, currentValue, comparator) {
  if (value === void 0 || currentValue === void 0) return false;
  if (typeof value === "string") return value === currentValue;
  if (typeof comparator === "function") return comparator(value, currentValue);
  if (typeof comparator === "string") return value?.[comparator] === currentValue?.[comparator];
  return isEqual(value, currentValue);
}

// node_modules/reka-ui/dist/Listbox/ListboxRoot.js
import { createBlock as createBlock59, createCommentVNode as createCommentVNode10, defineComponent as defineComponent70, nextTick as nextTick12, openBlock as openBlock62, ref as ref31, renderSlot as renderSlot63, toRefs as toRefs11, unref as unref65, watch as watch13, withCtx as withCtx59 } from "vue";
var [injectListboxRootContext, provideListboxRootContext] = createContext("ListboxRoot");
var ListboxRoot_vue_vue_type_script_setup_true_lang_default = defineComponent70({
  __name: "ListboxRoot",
  props: {
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    },
    multiple: {
      type: Boolean,
      required: false
    },
    orientation: {
      type: String,
      required: false,
      default: "vertical"
    },
    dir: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    selectionBehavior: {
      type: String,
      required: false,
      default: "toggle"
    },
    highlightOnHover: {
      type: Boolean,
      required: false
    },
    by: {
      type: [String, Function],
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "entryFocus",
    "leave"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { multiple, highlightOnHover, orientation, disabled, selectionBehavior, dir: propDir } = toRefs11(props2);
    const { getItems } = useCollection({ isProvider: true });
    const { handleTypeaheadSearch } = useTypeahead();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const kbd = useKbd();
    const dir = useDirection(propDir);
    const isFormControl = useFormControl(currentElement);
    const firstValue = ref31();
    const isUserAction = ref31(false);
    const focusable = ref31(true);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: props2.modelValue === void 0,
      deep: true
    });
    function onValueChange(val) {
      isUserAction.value = true;
      if (props2.multiple) {
        const modelArray = Array.isArray(modelValue.value) ? [...modelValue.value] : [];
        const index = modelArray.findIndex((i) => compare(i, val, props2.by));
        if (props2.selectionBehavior === "toggle") {
          index === -1 ? modelArray.push(val) : modelArray.splice(index, 1);
          modelValue.value = modelArray;
        } else {
          modelValue.value = [val];
          firstValue.value = val;
        }
      } else if (props2.selectionBehavior === "toggle") if (compare(modelValue.value, val, props2.by)) modelValue.value = void 0;
      else modelValue.value = val;
      else modelValue.value = val;
      setTimeout(() => {
        isUserAction.value = false;
      }, 1);
    }
    const highlightedElement = ref31(null);
    const previousElement = ref31(null);
    const isVirtual = ref31(false);
    const isComposing = ref31(false);
    const virtualFocusHook = createEventHook();
    const virtualKeydownHook = createEventHook();
    const virtualHighlightHook = createEventHook();
    function getCollectionItem() {
      return getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "");
    }
    function changeHighlight(el, scrollIntoView = true) {
      if (!el) return;
      highlightedElement.value = el;
      if (focusable.value) highlightedElement.value.focus();
      if (scrollIntoView) highlightedElement.value.scrollIntoView({ block: "nearest" });
      const highlightedItem = getItems().find((i) => i.ref === el);
      emits("highlight", highlightedItem);
    }
    function highlightItem(value) {
      if (isVirtual.value) virtualHighlightHook.trigger(value);
      else {
        const item = getItems().find((i) => compare(i.value, value, props2.by));
        if (item) {
          highlightedElement.value = item.ref;
          changeHighlight(item.ref);
        }
      }
    }
    function onKeydownEnter(event) {
      if (highlightedElement.value && highlightedElement.value.isConnected) {
        event.preventDefault();
        event.stopPropagation();
        if (!isComposing.value) highlightedElement.value.click();
      }
    }
    function onKeydownTypeAhead(event) {
      if (!focusable.value) return;
      isUserAction.value = true;
      if (isVirtual.value) virtualKeydownHook.trigger(event);
      else {
        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
        if (isMetaKey && event.key === "a" && multiple.value) {
          const collection = getItems();
          const values = collection.map((i) => i.value);
          modelValue.value = [...values];
          event.preventDefault();
          changeHighlight(collection[collection.length - 1].ref);
        } else if (!isMetaKey) {
          const el = handleTypeaheadSearch(event.key, getItems());
          if (el) changeHighlight(el);
        }
      }
      setTimeout(() => {
        isUserAction.value = false;
      }, 1);
    }
    function onCompositionStart() {
      isComposing.value = true;
    }
    function onCompositionEnd() {
      nextTick12(() => {
        isComposing.value = false;
      });
    }
    function highlightFirstItem() {
      nextTick12(() => {
        const event = new KeyboardEvent("keydown", { key: "PageUp" });
        onKeydownNavigation(event);
      });
    }
    function onLeave(event) {
      const el = highlightedElement.value;
      if (el?.isConnected) previousElement.value = el;
      highlightedElement.value = null;
      emits("leave", event);
    }
    function onEnter(event) {
      const entryFocusEvent = new CustomEvent("listbox.entryFocus", {
        bubbles: false,
        cancelable: true
      });
      event.currentTarget?.dispatchEvent(entryFocusEvent);
      emits("entryFocus", entryFocusEvent);
      if (entryFocusEvent.defaultPrevented) return;
      if (previousElement.value) changeHighlight(previousElement.value);
      else {
        const el = getCollectionItem()?.[0];
        changeHighlight(el);
      }
    }
    function onKeydownNavigation(event) {
      const intent = getFocusIntent(event, orientation.value, dir.value);
      if (!intent) return;
      let collection = getCollectionItem();
      if (highlightedElement.value) {
        if (intent === "last") collection.reverse();
        else if (intent === "prev" || intent === "next") {
          if (intent === "prev") collection.reverse();
          const currentIndex = collection.indexOf(highlightedElement.value);
          collection = collection.slice(currentIndex + 1);
        }
        handleMultipleReplace(event, collection[0]);
      }
      if (collection.length) {
        const index = !highlightedElement.value && intent === "prev" ? collection.length - 1 : 0;
        changeHighlight(collection[index]);
      }
      if (isVirtual.value) return virtualKeydownHook.trigger(event);
    }
    function handleMultipleReplace(event, targetEl) {
      if (isVirtual.value || props2.selectionBehavior !== "replace" || !multiple.value || !Array.isArray(modelValue.value)) return;
      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
      if (isMetaKey && !event.shiftKey) return;
      if (event.shiftKey) {
        const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
        let lastValue = collection.find((i) => i.ref === targetEl)?.value;
        if (event.key === kbd.END) lastValue = collection[collection.length - 1].value;
        else if (event.key === kbd.HOME) lastValue = collection[0].value;
        if (!lastValue || !firstValue.value) return;
        const values = findValuesBetween(collection.map((i) => i.value), firstValue.value, lastValue);
        modelValue.value = values;
      }
    }
    async function highlightSelected(event) {
      await nextTick12();
      if (isVirtual.value) virtualFocusHook.trigger(event);
      else {
        const collection = getCollectionItem();
        const item = collection.find((i) => i.dataset.state === "checked");
        if (item) changeHighlight(item);
        else if (collection.length) changeHighlight(collection[0]);
      }
    }
    watch13(modelValue, () => {
      if (!isUserAction.value) nextTick12(() => {
        highlightSelected();
      });
    }, {
      immediate: true,
      deep: true
    });
    __expose({
      highlightedElement,
      highlightItem,
      highlightFirstItem,
      highlightSelected,
      getItems
    });
    provideListboxRootContext({
      modelValue,
      onValueChange,
      multiple,
      orientation,
      dir,
      disabled,
      highlightOnHover,
      highlightedElement,
      isVirtual,
      virtualFocusHook,
      virtualKeydownHook,
      virtualHighlightHook,
      by: props2.by,
      firstValue,
      selectionBehavior,
      focusable,
      onLeave,
      onEnter,
      changeHighlight,
      onKeydownEnter,
      onKeydownNavigation,
      onKeydownTypeAhead,
      onCompositionStart,
      onCompositionEnd,
      highlightFirstItem
    });
    return (_ctx, _cache) => {
      return openBlock62(), createBlock59(unref65(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        dir: unref65(dir),
        "data-disabled": unref65(disabled) ? "" : void 0,
        onPointerleave: onLeave,
        onFocusout: _cache[0] || (_cache[0] = async (event) => {
          const target = event.relatedTarget || event.target;
          await nextTick12();
          if (highlightedElement.value && unref65(currentElement) && !unref65(currentElement).contains(target)) onLeave(event);
        })
      }, {
        default: withCtx59(() => [renderSlot63(_ctx.$slots, "default", { modelValue: unref65(modelValue) }), unref65(isFormControl) && _ctx.name ? (openBlock62(), createBlock59(unref65(VisuallyHiddenInput_default), {
          key: 0,
          name: _ctx.name,
          value: unref65(modelValue),
          disabled: unref65(disabled),
          required: _ctx.required
        }, null, 8, [
          "name",
          "value",
          "disabled",
          "required"
        ])) : createCommentVNode10("v-if", true)]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "dir",
        "data-disabled"
      ]);
    };
  }
});
var ListboxRoot_default = ListboxRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/ListboxContent.js
import { createBlock as createBlock60, createVNode as createVNode11, defineComponent as defineComponent71, openBlock as openBlock63, renderSlot as renderSlot64, unref as unref66, withCtx as withCtx60, withKeys as withKeys4, withModifiers as withModifiers4 } from "vue";
var ListboxContent_vue_vue_type_script_setup_true_lang_default = defineComponent71({
  __name: "ListboxContent",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const { CollectionSlot } = useCollection();
    const rootContext = injectListboxRootContext();
    const isClickFocus = refAutoReset(false, 10);
    return (_ctx, _cache) => {
      return openBlock63(), createBlock60(unref66(CollectionSlot), null, {
        default: withCtx60(() => [createVNode11(unref66(Primitive), {
          role: "listbox",
          as: _ctx.as,
          "as-child": _ctx.asChild,
          tabindex: unref66(rootContext).focusable.value ? unref66(rootContext).highlightedElement.value ? "-1" : "0" : void 0,
          "aria-orientation": unref66(rootContext).orientation.value,
          "aria-multiselectable": !!unref66(rootContext).multiple.value,
          "data-orientation": unref66(rootContext).orientation.value,
          onMousedown: _cache[0] || (_cache[0] = withModifiers4(($event) => isClickFocus.value = true, ["left"])),
          onFocus: _cache[1] || (_cache[1] = (ev) => {
            if (unref66(isClickFocus)) return;
            unref66(rootContext).onEnter(ev);
          }),
          onKeydown: [
            _cache[2] || (_cache[2] = withKeys4((event) => {
              if (unref66(rootContext).orientation.value === "vertical" && (event.key === "ArrowLeft" || event.key === "ArrowRight") || unref66(rootContext).orientation.value === "horizontal" && (event.key === "ArrowUp" || event.key === "ArrowDown")) return;
              event.preventDefault();
              unref66(rootContext).focusable.value && unref66(rootContext).onKeydownNavigation(event);
            }, [
              "down",
              "up",
              "left",
              "right",
              "home",
              "end"
            ])),
            withKeys4(unref66(rootContext).onKeydownEnter, ["enter"]),
            unref66(rootContext).onKeydownTypeAhead
          ]
        }, {
          default: withCtx60(() => [renderSlot64(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "tabindex",
          "aria-orientation",
          "aria-multiselectable",
          "data-orientation",
          "onKeydown"
        ])]),
        _: 3
      });
    };
  }
});
var ListboxContent_default = ListboxContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/ListboxFilter.js
import { computed as computed35, createBlock as createBlock61, defineComponent as defineComponent72, onMounted as onMounted13, onUnmounted as onUnmounted7, openBlock as openBlock64, ref as ref32, renderSlot as renderSlot65, unref as unref67, watchSyncEffect, withCtx as withCtx61, withKeys as withKeys5, withModifiers as withModifiers5 } from "vue";
var ListboxFilter_vue_vue_type_script_setup_true_lang_default = defineComponent72({
  __name: "ListboxFilter",
  props: {
    modelValue: {
      type: String,
      required: false
    },
    autoFocus: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: "",
      passive: props2.modelValue === void 0
    });
    const rootContext = injectListboxRootContext();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const disabled = computed35(() => props2.disabled || rootContext.disabled.value || false);
    const activedescendant = ref32();
    watchSyncEffect(() => activedescendant.value = rootContext.highlightedElement.value?.id);
    onMounted13(() => {
      rootContext.focusable.value = false;
      setTimeout(() => {
        if (props2.autoFocus) currentElement.value?.focus();
      }, 1);
    });
    onUnmounted7(() => {
      rootContext.focusable.value = true;
    });
    return (_ctx, _cache) => {
      return openBlock64(), createBlock61(unref67(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        value: unref67(modelValue),
        disabled: disabled.value ? "" : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "aria-disabled": disabled.value ?? void 0,
        "aria-activedescendant": activedescendant.value,
        type: "text",
        onKeydown: [withKeys5(withModifiers5(unref67(rootContext).onKeydownNavigation, ["prevent"]), [
          "down",
          "up",
          "home",
          "end"
        ]), withKeys5(unref67(rootContext).onKeydownEnter, ["enter"])],
        onInput: _cache[0] || (_cache[0] = (event) => {
          modelValue.value = event.target.value;
          unref67(rootContext).highlightFirstItem();
        }),
        onCompositionstart: unref67(rootContext).onCompositionStart,
        onCompositionend: unref67(rootContext).onCompositionEnd
      }, {
        default: withCtx61(() => [renderSlot65(_ctx.$slots, "default", { modelValue: unref67(modelValue) })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "value",
        "disabled",
        "data-disabled",
        "aria-disabled",
        "aria-activedescendant",
        "onKeydown",
        "onCompositionstart",
        "onCompositionend"
      ]);
    };
  }
});
var ListboxFilter_default = ListboxFilter_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/ListboxGroup.js
import { createBlock as createBlock62, defineComponent as defineComponent73, mergeProps as mergeProps31, openBlock as openBlock65, renderSlot as renderSlot66, unref as unref68, withCtx as withCtx62 } from "vue";
var [injectListboxGroupContext, provideListboxGroupContext] = createContext("ListboxGroup");
var ListboxGroup_vue_vue_type_script_setup_true_lang_default = defineComponent73({
  __name: "ListboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const id = useId2(void 0, "reka-listbox-group");
    provideListboxGroupContext({ id });
    return (_ctx, _cache) => {
      return openBlock65(), createBlock62(unref68(Primitive), mergeProps31({ role: "group" }, props2, { "aria-labelledby": unref68(id) }), {
        default: withCtx62(() => [renderSlot66(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["aria-labelledby"]);
    };
  }
});
var ListboxGroup_default = ListboxGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/ListboxGroupLabel.js
import { createBlock as createBlock63, defineComponent as defineComponent74, mergeProps as mergeProps32, openBlock as openBlock66, renderSlot as renderSlot67, unref as unref69, withCtx as withCtx63 } from "vue";
var ListboxGroupLabel_vue_vue_type_script_setup_true_lang_default = defineComponent74({
  __name: "ListboxGroupLabel",
  props: {
    for: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const groupContext = injectListboxGroupContext({ id: "" });
    return (_ctx, _cache) => {
      return openBlock66(), createBlock63(unref69(Primitive), mergeProps32(props2, { id: unref69(groupContext).id }), {
        default: withCtx63(() => [renderSlot67(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var ListboxGroupLabel_default = ListboxGroupLabel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/ListboxItem.js
import { computed as computed36, createBlock as createBlock64, createVNode as createVNode12, defineComponent as defineComponent75, mergeProps as mergeProps33, openBlock as openBlock67, renderSlot as renderSlot68, unref as unref70, withCtx as withCtx64, withKeys as withKeys6, withMemo, withModifiers as withModifiers6 } from "vue";
var LISTBOX_SELECT = "listbox.select";
var [injectListboxItemContext, provideListboxItemContext] = createContext("ListboxItem");
var ListboxItem_vue_vue_type_script_setup_true_lang_default = defineComponent75({
  __name: "ListboxItem",
  props: {
    value: {
      type: null,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const id = useId2(void 0, "reka-listbox-item");
    const { CollectionItem } = useCollection();
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectListboxRootContext();
    const isHighlighted = computed36(() => currentElement.value === rootContext.highlightedElement.value);
    const isSelected = computed36(() => valueComparator(rootContext.modelValue.value, props2.value, rootContext.by));
    const disabled = computed36(() => rootContext.disabled.value || props2.disabled);
    async function handleSelect2(ev) {
      emits("select", ev);
      if (ev?.defaultPrevented) return;
      if (!disabled.value && ev) {
        rootContext.onValueChange(props2.value);
        rootContext.changeHighlight(currentElement.value);
      }
    }
    function handleSelectCustomEvent(ev) {
      const eventDetail = {
        originalEvent: ev,
        value: props2.value
      };
      handleAndDispatchCustomEvent(LISTBOX_SELECT, handleSelect2, eventDetail);
    }
    provideListboxItemContext({ isSelected });
    return (_ctx, _cache) => {
      return openBlock67(), createBlock64(unref70(CollectionItem), { value: _ctx.value }, {
        default: withCtx64(() => [withMemo([isHighlighted.value, isSelected.value], () => createVNode12(unref70(Primitive), mergeProps33({ id: unref70(id) }, _ctx.$attrs, {
          ref: unref70(forwardRef),
          role: "option",
          tabindex: unref70(rootContext).focusable.value ? isHighlighted.value ? "0" : "-1" : -1,
          "aria-selected": isSelected.value,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          disabled: disabled.value ? "" : void 0,
          "data-disabled": disabled.value ? "" : void 0,
          "data-highlighted": isHighlighted.value ? "" : void 0,
          "data-state": isSelected.value ? "checked" : "unchecked",
          onClick: handleSelectCustomEvent,
          onKeydown: withKeys6(withModifiers6(handleSelectCustomEvent, ["prevent"]), ["space"]),
          onPointermove: _cache[0] || (_cache[0] = (event) => {
            if (unref70(rootContext).highlightedElement.value === unref70(currentElement)) return;
            if (unref70(rootContext).highlightOnHover.value) unref70(rootContext).changeHighlight(unref70(currentElement), false);
            else unref70(rootContext).focusable.value || unref70(rootContext).changeHighlight(unref70(currentElement), false);
          })
        }), {
          default: withCtx64(() => [renderSlot68(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "tabindex",
          "aria-selected",
          "as",
          "as-child",
          "disabled",
          "data-disabled",
          "data-highlighted",
          "data-state",
          "onKeydown"
        ]), _cache, 1)]),
        _: 3
      }, 8, ["value"]);
    };
  }
});
var ListboxItem_default = ListboxItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/ListboxItemIndicator.js
import { createBlock as createBlock65, createCommentVNode as createCommentVNode11, defineComponent as defineComponent76, mergeProps as mergeProps34, openBlock as openBlock68, renderSlot as renderSlot69, unref as unref71, withCtx as withCtx65 } from "vue";
var ListboxItemIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent76({
  __name: "ListboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const itemContext = injectListboxItemContext();
    return (_ctx, _cache) => {
      return unref71(itemContext).isSelected.value ? (openBlock68(), createBlock65(unref71(Primitive), mergeProps34({
        key: 0,
        "aria-hidden": "true"
      }, props2), {
        default: withCtx65(() => [renderSlot69(_ctx.$slots, "default")]),
        _: 3
      }, 16)) : createCommentVNode11("v-if", true);
    };
  }
});
var ListboxItemIndicator_default = ListboxItemIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Listbox/ListboxVirtualizer.js
import { Fragment as Fragment4, cloneVNode as cloneVNode2, computed as computed38, createBlock as createBlock66, createElementBlock as createElementBlock6, defineComponent as defineComponent77, normalizeStyle as normalizeStyle5, openBlock as openBlock69, renderList as renderList2, resolveDynamicComponent as resolveDynamicComponent3, unref as unref73, useSlots } from "vue";

// node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
var approxEqual = (a, b) => Math.abs(a - b) < 1.01;
var debounce = (targetWindow, fn, ms) => {
  let timeoutId;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId);
    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

// node_modules/@tanstack/virtual-core/dist/esm/index.js
var getRect = (element) => {
  const { offsetWidth, offsetHeight } = element;
  return { width: offsetWidth, height: offsetHeight };
};
var defaultKeyExtractor = (index) => index;
var defaultRangeExtractor = (range2) => {
  const start = Math.max(range2.startIndex - range2.overscan, 0);
  const end = Math.min(range2.endIndex + range2.overscan, range2.count - 1);
  const arr = [];
  for (let i = start; i <= end; i++) {
    arr.push(i);
  }
  return arr;
};
var observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(getRect(element));
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(getRect(element));
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
var addEventListenerOptions = {
  passive: true
};
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset3 = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset3, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset3 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset3, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
var measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size3 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size3;
    }
  }
  return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
var elementScroll = (offset3, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset3 + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
var Virtualizer = class {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a;
          (_a = get()) == null ? void 0 : _a.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a, _b;
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d) => d());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset3, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset3 ? "forward" : "backward" : null;
            this.scrollOffset = offset3;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m = index - 1; m >= 0; m--) {
        const measurement = measurements[m];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {
        if (a.end === b.end) {
          return a.index - b.index;
        }
        return a.end - b.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count3, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count3,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count3, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i = min2; i < count3; i++) {
          const key = getItemKey(i);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);
          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size3 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i);
          const end = start + size3;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;
          measurements[i] = {
            index: i,
            start,
            size: size3,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range2 = this.calculateRange();
        if (range2) {
          startIndex = range2.startIndex;
          endIndex = range2.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count3, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count: count3
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index = this.indexFromElement(node);
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index, size3) => {
      const item = this.measurementsCache[index];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size3 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size3));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k = 0, len = indexes.length; k < len; k++) {
          const i = indexes[k];
          const measurement = measurements[i];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset3) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index) => notUndefined(measurements[index]).start,
          offset3
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size3 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size3 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size3) / 2;
      } else if (align === "end") {
        toOffset -= size3;
      }
      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size3;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index, align = "auto") => {
      index = Math.max(0, Math.min(index, this.options.count - 1));
      const item = this.measurementsCache[index];
      if (!item) {
        return void 0;
      }
      const size3 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size3 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index, { align: initialAlign = "auto", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      index = Math.max(0, Math.min(index, this.options.count - 1));
      let attempts = 0;
      const maxAttempts = 10;
      const tryScroll = (currentAlign) => {
        if (!this.targetWindow) return;
        const offsetInfo = this.getOffsetForIndex(index, currentAlign);
        if (!offsetInfo) {
          console.warn("Failed to get offset for index:", index);
          return;
        }
        const [offset3, align] = offsetInfo;
        this._scrollToOffset(offset3, { adjustments: void 0, behavior });
        this.targetWindow.requestAnimationFrame(() => {
          const currentOffset = this.getScrollOffset();
          const afterInfo = this.getOffsetForIndex(index, align);
          if (!afterInfo) {
            console.warn("Failed to get offset for index:", index);
            return;
          }
          if (!approxEqual(afterInfo[0], currentOffset)) {
            scheduleRetry(align);
          }
        });
      };
      const scheduleRetry = (align) => {
        if (!this.targetWindow) return;
        attempts++;
        if (attempts < maxAttempts) {
          if (this.options.debug) {
            console.info("Schedule retry", attempts, maxAttempts);
          }
          this.targetWindow.requestAnimationFrame(() => tryScroll(align));
        } else {
          console.warn(
            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`
          );
        }
      };
      tryScroll(initialAlign);
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset3, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset3, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index) => measurements[index].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

// node_modules/@tanstack/vue-virtual/dist/esm/index.js
import { computed as computed37, unref as unref72, shallowRef as shallowRef4, watch as watch14, triggerRef, onScopeDispose as onScopeDispose3 } from "vue";
function useVirtualizerBase(options) {
  const virtualizer = new Virtualizer(unref72(options));
  const state = shallowRef4(virtualizer);
  const cleanup = virtualizer._didMount();
  watch14(
    () => unref72(options).getScrollElement(),
    (el) => {
      if (el) {
        virtualizer._willUpdate();
      }
    },
    {
      immediate: true
    }
  );
  watch14(
    () => unref72(options),
    (options2) => {
      virtualizer.setOptions({
        ...options2,
        onChange: (instance, sync) => {
          var _a;
          triggerRef(state);
          (_a = options2.onChange) == null ? void 0 : _a.call(options2, instance, sync);
        }
      });
      virtualizer._willUpdate();
      triggerRef(state);
    },
    {
      immediate: true
    }
  );
  onScopeDispose3(cleanup);
  return state;
}
function useVirtualizer(options) {
  return useVirtualizerBase(
    computed37(() => ({
      observeElementRect,
      observeElementOffset,
      scrollToFn: elementScroll,
      ...unref72(options)
    }))
  );
}

// node_modules/reka-ui/dist/Listbox/ListboxVirtualizer.js
var ListboxVirtualizer_vue_vue_type_script_setup_true_lang_default = defineComponent77({
  __name: "ListboxVirtualizer",
  props: {
    options: {
      type: Array,
      required: true
    },
    overscan: {
      type: Number,
      required: false
    },
    estimateSize: {
      type: Number,
      required: false
    },
    textContent: {
      type: Function,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const slots = useSlots();
    const rootContext = injectListboxRootContext();
    const parentEl = useParentElement();
    const { getItems } = useCollection();
    rootContext.isVirtual.value = true;
    const padding = computed38(() => {
      const el = parentEl.value;
      if (!el) return {
        start: 0,
        end: 0
      };
      else {
        const styles = window.getComputedStyle(el);
        return {
          start: Number.parseFloat(styles.paddingBlockStart || styles.paddingTop),
          end: Number.parseFloat(styles.paddingBlockEnd || styles.paddingBottom)
        };
      }
    });
    const virtualizer = useVirtualizer({
      get scrollPaddingStart() {
        return padding.value.start;
      },
      get scrollPaddingEnd() {
        return padding.value.end;
      },
      get count() {
        return props2.options.length;
      },
      get horizontal() {
        return rootContext.orientation.value === "horizontal";
      },
      estimateSize() {
        return props2.estimateSize ?? 28;
      },
      getScrollElement() {
        return parentEl.value;
      },
      overscan: props2.overscan ?? 12
    });
    const virtualizedItems = computed38(() => virtualizer.value.getVirtualItems().map((item) => {
      const defaultNode = slots.default({
        option: props2.options[item.index],
        virtualizer: virtualizer.value,
        virtualItem: item
      })[0];
      const targetNode = defaultNode.type === Fragment4 && Array.isArray(defaultNode.children) ? defaultNode.children[0] : defaultNode;
      return {
        item,
        is: cloneVNode2(targetNode, {
          "key": `${item.key}`,
          "data-index": item.index,
          "aria-setsize": props2.options.length,
          "aria-posinset": item.index + 1,
          "style": {
            position: "absolute",
            top: 0,
            left: 0,
            transform: `translateY(${item.start}px)`,
            overflowAnchor: "none"
          }
        })
      };
    }));
    rootContext.virtualFocusHook.on((event) => {
      const index = props2.options.findIndex((option) => {
        if (Array.isArray(rootContext.modelValue.value)) return compare(option, rootContext.modelValue.value[0], rootContext.by);
        else return compare(option, rootContext.modelValue.value, rootContext.by);
      });
      if (index !== -1) {
        event?.preventDefault();
        virtualizer.value.scrollToIndex(index, { align: "start" });
        requestAnimationFrame(() => {
          const item = queryCheckedElement(parentEl.value);
          if (item) {
            rootContext.changeHighlight(item);
            if (event) item?.focus();
          }
        });
      } else rootContext.highlightFirstItem();
    });
    rootContext.virtualHighlightHook.on((value) => {
      const index = props2.options.findIndex((option) => {
        return compare(option, value, rootContext.by);
      });
      virtualizer.value.scrollToIndex(index, { align: "start" });
      requestAnimationFrame(() => {
        const item = queryCheckedElement(parentEl.value);
        if (item) rootContext.changeHighlight(item);
      });
    });
    const search = refAutoReset("", 1e3);
    const optionsWithMetadata = computed38(() => {
      const parseTextContent = (option) => {
        if (props2.textContent) return props2.textContent(option);
        else return option?.toString().toLowerCase();
      };
      return props2.options.map((option, index) => ({
        index,
        textContent: parseTextContent(option)
      }));
    });
    function handleMultipleReplace(event, intent) {
      if (!rootContext.firstValue?.value || !rootContext.multiple.value || !Array.isArray(rootContext.modelValue.value)) return;
      const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
      const lastValue = collection.find((i) => i.ref === rootContext.highlightedElement.value)?.value;
      if (!lastValue) return;
      let value = null;
      switch (intent) {
        case "prev":
        case "next": {
          value = findValuesBetween(props2.options, rootContext.firstValue.value, lastValue);
          break;
        }
        case "first": {
          value = findValuesBetween(props2.options, rootContext.firstValue.value, props2.options?.[0]);
          break;
        }
        case "last": {
          value = findValuesBetween(props2.options, rootContext.firstValue.value, props2.options?.[props2.options.length - 1]);
          break;
        }
      }
      rootContext.modelValue.value = value;
    }
    rootContext.virtualKeydownHook.on((event) => {
      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
      const isTabKey = event.key === "Tab" && !isMetaKey;
      if (isTabKey) return;
      let intent = MAP_KEY_TO_FOCUS_INTENT[event.key];
      if (isMetaKey && event.key === "a" && rootContext.multiple.value) {
        event.preventDefault();
        rootContext.modelValue.value = [...props2.options];
        intent = "last";
      } else if (event.shiftKey && intent) handleMultipleReplace(event, intent);
      if (["first", "last"].includes(intent)) {
        event.preventDefault();
        const index = intent === "first" ? 0 : props2.options.length - 1;
        virtualizer.value.scrollToIndex(index);
        requestAnimationFrame(() => {
          const items = getItems();
          const item = intent === "first" ? items[0] : items[items.length - 1];
          if (item) rootContext.changeHighlight(item.ref);
        });
      } else if (!intent && !isMetaKey) {
        search.value += event.key;
        const currentIndex = Number(getActiveElement()?.getAttribute("data-index"));
        const currentMatch = optionsWithMetadata.value[currentIndex].textContent;
        const filteredOptions = optionsWithMetadata.value.map((i) => i.textContent ?? "");
        const next = getNextMatch(filteredOptions, search.value, currentMatch);
        const nextMatch = optionsWithMetadata.value.find((option) => option.textContent === next);
        if (nextMatch) {
          virtualizer.value.scrollToIndex(nextMatch.index, { align: "start" });
          requestAnimationFrame(() => {
            const item = parentEl.value.querySelector(`[data-index="${nextMatch.index}"]`);
            if (item instanceof HTMLElement) rootContext.changeHighlight(item);
          });
        }
      }
    });
    return (_ctx, _cache) => {
      return openBlock69(), createElementBlock6("div", {
        "data-reka-virtualizer": "",
        style: normalizeStyle5({
          position: "relative",
          width: "100%",
          height: `${unref73(virtualizer).getTotalSize()}px`
        })
      }, [(openBlock69(true), createElementBlock6(Fragment4, null, renderList2(virtualizedItems.value, ({ is, item }) => {
        return openBlock69(), createBlock66(resolveDynamicComponent3(is), { key: item.index });
      }), 128))], 4);
    };
  }
});
var ListboxVirtualizer_default = ListboxVirtualizer_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxRoot.js
import { computed as computed39, createBlock as createBlock67, createVNode as createVNode13, defineComponent as defineComponent78, getCurrentInstance as getCurrentInstance7, isRef as isRef3, mergeProps as mergeProps35, nextTick as nextTick13, onMounted as onMounted14, openBlock as openBlock70, ref as ref33, renderSlot as renderSlot70, toRefs as toRefs12, unref as unref74, withCtx as withCtx66 } from "vue";
var [injectComboboxRootContext, provideComboboxRootContext] = createContext("ComboboxRoot");
var ComboboxRoot_vue_vue_type_script_setup_true_lang_default = defineComponent78({
  __name: "ComboboxRoot",
  props: {
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: false
    },
    resetSearchTermOnBlur: {
      type: Boolean,
      required: false,
      default: true
    },
    resetSearchTermOnSelect: {
      type: Boolean,
      required: false,
      default: true
    },
    openOnFocus: {
      type: Boolean,
      required: false,
      default: false
    },
    openOnClick: {
      type: Boolean,
      required: false,
      default: false
    },
    ignoreFilter: {
      type: Boolean,
      required: false
    },
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    },
    multiple: {
      type: Boolean,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    highlightOnHover: {
      type: Boolean,
      required: false
    },
    by: {
      type: [String, Function],
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "update:modelValue",
    "highlight",
    "update:open"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const { multiple, disabled, ignoreFilter, resetSearchTermOnSelect, openOnFocus, openOnClick, dir: propDir } = toRefs12(props2);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: props2.modelValue === void 0,
      deep: true
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    async function onOpenChange(val) {
      open.value = val;
      filterSearch.value = "";
      if (val) {
        await nextTick13();
        primitiveElement.value?.highlightSelected();
        isUserInputted.value = true;
      } else isUserInputted.value = false;
      inputElement.value?.focus();
      setTimeout(() => {
        if (!val && props2.resetSearchTermOnBlur) resetSearchTerm.trigger();
      }, 1);
    }
    const resetSearchTerm = createEventHook();
    const isUserInputted = ref33(false);
    const isVirtual = ref33(false);
    const inputElement = ref33();
    const triggerElement = ref33();
    const highlightedElement = computed39(() => primitiveElement.value?.highlightedElement ?? void 0);
    const allItems = ref33(/* @__PURE__ */ new Map());
    const allGroups = ref33(/* @__PURE__ */ new Map());
    const { contains } = useFilter({ sensitivity: "base" });
    const filterSearch = ref33("");
    const filterState = computed39((oldValue) => {
      if (!filterSearch.value || props2.ignoreFilter || isVirtual.value) return {
        count: allItems.value.size,
        items: oldValue?.items ?? /* @__PURE__ */ new Map(),
        groups: oldValue?.groups ?? new Set(allGroups.value.keys())
      };
      let itemCount = 0;
      const filteredItems = /* @__PURE__ */ new Map();
      const filteredGroups = /* @__PURE__ */ new Set();
      for (const [id, value] of allItems.value) {
        const score = contains(value, filterSearch.value);
        filteredItems.set(id, score ? 1 : 0);
        if (score) itemCount++;
      }
      for (const [groupId, group] of allGroups.value) for (const itemId of group) if (filteredItems.get(itemId) > 0) {
        filteredGroups.add(groupId);
        break;
      }
      return {
        count: itemCount,
        items: filteredItems,
        groups: filteredGroups
      };
    });
    const inst = getCurrentInstance7();
    onMounted14(() => {
      if (inst?.exposed) {
        inst.exposed.highlightItem = primitiveElement.value?.highlightItem;
        inst.exposed.highlightFirstItem = primitiveElement.value?.highlightFirstItem;
        inst.exposed.highlightSelected = primitiveElement.value?.highlightSelected;
      }
    });
    __expose({
      filtered: filterState,
      highlightedElement,
      highlightItem: primitiveElement.value?.highlightItem,
      highlightFirstItem: primitiveElement.value?.highlightFirstItem,
      highlightSelected: primitiveElement.value?.highlightSelected
    });
    provideComboboxRootContext({
      modelValue,
      multiple,
      disabled,
      open,
      onOpenChange,
      contentId: "",
      isUserInputted,
      isVirtual,
      inputElement,
      highlightedElement,
      onInputElementChange: (val) => inputElement.value = val,
      triggerElement,
      onTriggerElementChange: (val) => triggerElement.value = val,
      parentElement,
      resetSearchTermOnSelect,
      onResetSearchTerm: resetSearchTerm.on,
      allItems,
      allGroups,
      filterSearch,
      filterState,
      ignoreFilter,
      openOnFocus,
      openOnClick
    });
    return (_ctx, _cache) => {
      return openBlock70(), createBlock67(unref74(PopperRoot_default), null, {
        default: withCtx66(() => [createVNode13(unref74(ListboxRoot_default), mergeProps35({
          ref_key: "primitiveElement",
          ref: primitiveElement
        }, _ctx.$attrs, {
          modelValue: unref74(modelValue),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef3(modelValue) ? modelValue.value = $event : null),
          style: { pointerEvents: unref74(open) ? "auto" : void 0 },
          as: _ctx.as,
          "as-child": _ctx.asChild,
          dir: unref74(dir),
          multiple: unref74(multiple),
          name: _ctx.name,
          required: _ctx.required,
          disabled: unref74(disabled),
          "highlight-on-hover": true,
          by: props2.by,
          onHighlight: _cache[1] || (_cache[1] = ($event) => emits("highlight", $event))
        }), {
          default: withCtx66(() => [renderSlot70(_ctx.$slots, "default", {
            open: unref74(open),
            modelValue: unref74(modelValue)
          })]),
          _: 3
        }, 16, [
          "modelValue",
          "style",
          "as",
          "as-child",
          "dir",
          "multiple",
          "name",
          "required",
          "disabled",
          "by"
        ])]),
        _: 3
      });
    };
  }
});
var ComboboxRoot_default = ComboboxRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxContentImpl.js
import { computed as computed40, createBlock as createBlock68, createVNode as createVNode14, defineComponent as defineComponent79, mergeProps as mergeProps36, onMounted as onMounted15, onUnmounted as onUnmounted8, openBlock as openBlock71, ref as ref34, renderSlot as renderSlot71, resolveDynamicComponent as resolveDynamicComponent4, toRefs as toRefs13, unref as unref75, withCtx as withCtx67 } from "vue";
var [injectComboboxContentContext, provideComboboxContentContext] = createContext("ComboboxContent");
var ComboboxContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent79({
  __name: "ComboboxContentImpl",
  props: {
    position: {
      type: String,
      required: false,
      default: "inline"
    },
    bodyLock: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { position } = toRefs13(props2);
    const rootContext = injectComboboxRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    useBodyScrollLock(props2.bodyLock);
    useHideOthers(rootContext.parentElement);
    const pickedProps = computed40(() => {
      if (props2.position === "popper") return props2;
      else return {};
    });
    const forwardedProps = useForwardProps(pickedProps.value);
    const popperStyle = {
      "boxSizing": "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    provideComboboxContentContext({ position });
    const isInputWithinContent = ref34(false);
    onMounted15(() => {
      if (rootContext.inputElement.value) {
        isInputWithinContent.value = currentElement.value.contains(rootContext.inputElement.value);
        if (isInputWithinContent.value) rootContext.inputElement.value.focus();
      }
    });
    onUnmounted8(() => {
      if (isInputWithinContent.value) rootContext.triggerElement.value?.focus();
    });
    return (_ctx, _cache) => {
      return openBlock71(), createBlock68(unref75(ListboxContent_default), { "as-child": "" }, {
        default: withCtx67(() => [createVNode14(unref75(DismissableLayer_default), {
          "as-child": "",
          "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
          onDismiss: _cache[0] || (_cache[0] = ($event) => unref75(rootContext).onOpenChange(false)),
          onFocusOutside: _cache[1] || (_cache[1] = (ev) => {
            if (unref75(rootContext).parentElement.value?.contains(ev.target)) ev.preventDefault();
            emits("focusOutside", ev);
          }),
          onInteractOutside: _cache[2] || (_cache[2] = ($event) => emits("interactOutside", $event)),
          onEscapeKeyDown: _cache[3] || (_cache[3] = ($event) => emits("escapeKeyDown", $event)),
          onPointerDownOutside: _cache[4] || (_cache[4] = (ev) => {
            if (unref75(rootContext).parentElement.value?.contains(ev.target)) ev.preventDefault();
            emits("pointerDownOutside", ev);
          })
        }, {
          default: withCtx67(() => [(openBlock71(), createBlock68(resolveDynamicComponent4(unref75(position) === "popper" ? unref75(PopperContent_default) : unref75(Primitive)), mergeProps36({
            ..._ctx.$attrs,
            ...unref75(forwardedProps)
          }, {
            id: unref75(rootContext).contentId,
            ref: unref75(forwardRef),
            "data-state": unref75(rootContext).open.value ? "open" : "closed",
            style: {
              display: "flex",
              flexDirection: "column",
              outline: "none",
              ...unref75(position) === "popper" ? popperStyle : {}
            }
          }), {
            default: withCtx67(() => [renderSlot71(_ctx.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "data-state",
            "style"
          ]))]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      });
    };
  }
});
var ComboboxContentImpl_default = ComboboxContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxArrow.js
import { createBlock as createBlock69, createCommentVNode as createCommentVNode12, defineComponent as defineComponent80, guardReactiveProps as guardReactiveProps13, mergeProps as mergeProps37, normalizeProps as normalizeProps13, openBlock as openBlock72, renderSlot as renderSlot72, unref as unref76, withCtx as withCtx68 } from "vue";
var ComboboxArrow_vue_vue_type_script_setup_true_lang_default = defineComponent80({
  __name: "ComboboxArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectComboboxRootContext();
    const contentContext = injectComboboxContentContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return unref76(rootContext).open.value && unref76(contentContext).position.value === "popper" ? (openBlock72(), createBlock69(unref76(PopperArrow_default), normalizeProps13(mergeProps37({ key: 0 }, props2)), {
        default: withCtx68(() => [renderSlot72(_ctx.$slots, "default")]),
        _: 3
      }, 16)) : createCommentVNode12("v-if", true);
    };
  }
});
var ComboboxArrow_default = ComboboxArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxCancel.js
import { createBlock as createBlock70, defineComponent as defineComponent81, mergeProps as mergeProps38, openBlock as openBlock73, renderSlot as renderSlot73, unref as unref77, withCtx as withCtx69 } from "vue";
var ComboboxCancel_vue_vue_type_script_setup_true_lang_default = defineComponent81({
  __name: "ComboboxCancel",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectComboboxRootContext();
    function handleClick() {
      rootContext.filterSearch.value = "";
      if (rootContext.inputElement.value) {
        rootContext.inputElement.value.value = "";
        rootContext.inputElement.value.focus();
      }
    }
    return (_ctx, _cache) => {
      return openBlock73(), createBlock70(unref77(Primitive), mergeProps38({ type: _ctx.as === "button" ? "button" : void 0 }, props2, {
        tabindex: "-1",
        onClick: handleClick
      }), {
        default: withCtx69(() => [renderSlot73(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["type"]);
    };
  }
});
var ComboboxCancel_default = ComboboxCancel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxContent.js
import { createBlock as createBlock71, createVNode as createVNode15, defineComponent as defineComponent82, mergeProps as mergeProps39, openBlock as openBlock74, renderSlot as renderSlot74, unref as unref78, withCtx as withCtx70 } from "vue";
var ComboboxContent_vue_vue_type_script_setup_true_lang_default = defineComponent82({
  __name: "ComboboxContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    position: {
      type: String,
      required: false
    },
    bodyLock: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectComboboxRootContext();
    rootContext.contentId ||= useId2(void 0, "reka-combobox-content");
    return (_ctx, _cache) => {
      return openBlock74(), createBlock71(unref78(Presence_default), { present: _ctx.forceMount || unref78(rootContext).open.value }, {
        default: withCtx70(() => [createVNode15(ComboboxContentImpl_default, mergeProps39({
          ...unref78(forwarded),
          ..._ctx.$attrs
        }, { ref: unref78(forwardRef) }), {
          default: withCtx70(() => [renderSlot74(_ctx.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var ComboboxContent_default = ComboboxContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxEmpty.js
import { computed as computed41, createBlock as createBlock72, createCommentVNode as createCommentVNode13, createTextVNode as createTextVNode5, defineComponent as defineComponent83, guardReactiveProps as guardReactiveProps14, mergeProps as mergeProps40, normalizeProps as normalizeProps14, openBlock as openBlock75, renderSlot as renderSlot75, unref as unref79, withCtx as withCtx71 } from "vue";
var ComboboxEmpty_vue_vue_type_script_setup_true_lang_default = defineComponent83({
  __name: "ComboboxEmpty",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectComboboxRootContext();
    const isRender = computed41(() => rootContext.ignoreFilter.value ? rootContext.allItems.value.size === 0 : rootContext.filterState.value.count === 0);
    return (_ctx, _cache) => {
      return isRender.value ? (openBlock75(), createBlock72(unref79(Primitive), normalizeProps14(mergeProps40({ key: 0 }, props2)), {
        default: withCtx71(() => [renderSlot75(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createTextVNode5("No options"))])]),
        _: 3
      }, 16)) : createCommentVNode13("v-if", true);
    };
  }
});
var ComboboxEmpty_default = ComboboxEmpty_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxGroup.js
import { computed as computed42, createBlock as createBlock73, defineComponent as defineComponent84, mergeProps as mergeProps41, onMounted as onMounted16, onUnmounted as onUnmounted9, openBlock as openBlock76, renderSlot as renderSlot76, unref as unref80, withCtx as withCtx72 } from "vue";
var [injectComboboxGroupContext, provideComboboxGroupContext] = createContext("ComboboxGroup");
var ComboboxGroup_vue_vue_type_script_setup_true_lang_default = defineComponent84({
  __name: "ComboboxGroup",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const id = useId2(void 0, "reka-combobox-group");
    const rootContext = injectComboboxRootContext();
    const isRender = computed42(() => rootContext.ignoreFilter.value ? true : !rootContext.filterSearch.value ? true : rootContext.filterState.value.groups.has(id));
    const context2 = provideComboboxGroupContext({
      id,
      labelId: ""
    });
    onMounted16(() => {
      if (!rootContext.allGroups.value.has(id)) rootContext.allGroups.value.set(id, /* @__PURE__ */ new Set());
    });
    onUnmounted9(() => {
      rootContext.allGroups.value.delete(id);
    });
    return (_ctx, _cache) => {
      return openBlock76(), createBlock73(unref80(ListboxGroup_default), mergeProps41({
        id: unref80(id),
        "aria-labelledby": unref80(context2).labelId
      }, props2, { hidden: isRender.value ? void 0 : true }), {
        default: withCtx72(() => [renderSlot76(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "hidden"
      ]);
    };
  }
});
var ComboboxGroup_default = ComboboxGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxInput.js
import { createBlock as createBlock74, defineComponent as defineComponent85, isRef as isRef4, nextTick as nextTick14, onMounted as onMounted17, openBlock as openBlock77, renderSlot as renderSlot77, unref as unref81, watch as watch15, withCtx as withCtx73, withKeys as withKeys7, withModifiers as withModifiers7 } from "vue";
var ComboboxInput_vue_vue_type_script_setup_true_lang_default = defineComponent85({
  __name: "ComboboxInput",
  props: {
    displayValue: {
      type: Function,
      required: false
    },
    modelValue: {
      type: String,
      required: false
    },
    autoFocus: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "input"
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectComboboxRootContext();
    const listboxContext = injectListboxRootContext();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const modelValue = useVModel(props2, "modelValue", emits, { passive: props2.modelValue === void 0 });
    onMounted17(() => {
      if (currentElement.value) rootContext.onInputElementChange(currentElement.value);
    });
    function handleKeyDown(ev) {
      if (!rootContext.open.value) rootContext.onOpenChange(true);
    }
    function handleInput(event) {
      const target = event.target;
      if (!rootContext.open.value) {
        rootContext.onOpenChange(true);
        nextTick14(() => {
          if (target.value) {
            rootContext.filterSearch.value = target.value;
            listboxContext.highlightFirstItem();
          }
        });
      } else rootContext.filterSearch.value = target.value;
    }
    function handleFocus() {
      if (rootContext.openOnFocus.value && !rootContext.open.value) rootContext.onOpenChange(true);
    }
    function handleClick() {
      if (rootContext.openOnClick.value && !rootContext.open.value) rootContext.onOpenChange(true);
    }
    function resetSearchTerm() {
      const rootModelValue = rootContext.modelValue.value;
      if (props2.displayValue) modelValue.value = props2.displayValue(rootModelValue);
      else if (!rootContext.multiple.value && rootModelValue && !Array.isArray(rootModelValue)) if (typeof rootModelValue !== "object") modelValue.value = rootModelValue.toString();
      else modelValue.value = "";
      else modelValue.value = "";
      nextTick14(() => {
        modelValue.value = modelValue.value;
      });
    }
    rootContext.onResetSearchTerm(() => {
      resetSearchTerm();
    });
    watch15(rootContext.modelValue, async () => {
      if (!rootContext.isUserInputted.value && rootContext.resetSearchTermOnSelect.value) resetSearchTerm();
    }, {
      immediate: true,
      deep: true
    });
    watch15(rootContext.filterState, () => {
      if (!rootContext.isVirtual.value && !rootContext.highlightedElement.value) listboxContext.highlightFirstItem();
    });
    return (_ctx, _cache) => {
      return openBlock77(), createBlock74(unref81(ListboxFilter_default), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        modelValue: unref81(modelValue),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef4(modelValue) ? modelValue.value = $event : null),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "auto-focus": _ctx.autoFocus,
        disabled: _ctx.disabled,
        "aria-expanded": unref81(rootContext).open.value,
        "aria-controls": unref81(rootContext).contentId,
        "aria-autocomplete": "list",
        role: "combobox",
        autocomplete: "off",
        onClick: handleClick,
        onInput: handleInput,
        onKeydown: withKeys7(withModifiers7(handleKeyDown, ["prevent"]), ["down", "up"]),
        onFocus: handleFocus
      }, {
        default: withCtx73(() => [renderSlot77(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "modelValue",
        "as",
        "as-child",
        "auto-focus",
        "disabled",
        "aria-expanded",
        "aria-controls",
        "onKeydown"
      ]);
    };
  }
});
var ComboboxInput_default = ComboboxInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxItem.js
import { computed as computed43, createBlock as createBlock75, createCommentVNode as createCommentVNode14, createTextVNode as createTextVNode6, defineComponent as defineComponent86, mergeProps as mergeProps42, onMounted as onMounted18, onUnmounted as onUnmounted10, openBlock as openBlock78, renderSlot as renderSlot78, toDisplayString as toDisplayString4, unref as unref82, withCtx as withCtx74 } from "vue";
var ComboboxItem_vue_vue_type_script_setup_true_lang_default = defineComponent86({
  __name: "ComboboxItem",
  props: {
    textValue: {
      type: String,
      required: false
    },
    value: {
      type: null,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const id = useId2(void 0, "reka-combobox-item");
    const rootContext = injectComboboxRootContext();
    const groupContext = injectComboboxGroupContext(null);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    if (props2.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
    const isRender = computed43(() => {
      if (rootContext.isVirtual.value || rootContext.ignoreFilter.value || !rootContext.filterSearch.value) return true;
      else {
        const filteredCurrentItem = rootContext.filterState.value.items.get(id);
        if (filteredCurrentItem === void 0) return true;
        return filteredCurrentItem > 0;
      }
    });
    onMounted18(() => {
      rootContext.allItems.value.set(id, props2.textValue || currentElement.value.textContent || currentElement.value.innerText);
      const groupId = groupContext?.id;
      if (groupId) if (!rootContext.allGroups.value.has(groupId)) rootContext.allGroups.value.set(groupId, /* @__PURE__ */ new Set([id]));
      else rootContext.allGroups.value.get(groupId)?.add(id);
    });
    onUnmounted10(() => {
      rootContext.allItems.value.delete(id);
    });
    return (_ctx, _cache) => {
      return isRender.value ? (openBlock78(), createBlock75(unref82(ListboxItem_default), mergeProps42({ key: 0 }, props2, {
        id: unref82(id),
        ref_key: "primitiveElement",
        ref: primitiveElement,
        disabled: unref82(rootContext).disabled.value || _ctx.disabled,
        onSelect: _cache[0] || (_cache[0] = (event) => {
          emits("select", event);
          if (event.defaultPrevented) return;
          if (!unref82(rootContext).multiple.value && !_ctx.disabled && !unref82(rootContext).disabled.value) {
            event.preventDefault();
            unref82(rootContext).onOpenChange(false);
            unref82(rootContext).modelValue.value = props2.value;
          }
        })
      }), {
        default: withCtx74(() => [renderSlot78(_ctx.$slots, "default", {}, () => [createTextVNode6(toDisplayString4(_ctx.value), 1)])]),
        _: 3
      }, 16, ["id", "disabled"])) : createCommentVNode14("v-if", true);
    };
  }
});
var ComboboxItem_default = ComboboxItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxItemIndicator.js
import { createBlock as createBlock76, defineComponent as defineComponent87, guardReactiveProps as guardReactiveProps15, normalizeProps as normalizeProps15, openBlock as openBlock79, renderSlot as renderSlot79, unref as unref83, withCtx as withCtx75 } from "vue";
var ComboboxItemIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent87({
  __name: "ComboboxItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock79(), createBlock76(unref83(ListboxItemIndicator_default), normalizeProps15(guardReactiveProps15(props2)), {
        default: withCtx75(() => [renderSlot79(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ComboboxItemIndicator_default = ComboboxItemIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxLabel.js
import { createBlock as createBlock77, defineComponent as defineComponent88, mergeProps as mergeProps43, openBlock as openBlock80, renderSlot as renderSlot80, unref as unref84, withCtx as withCtx76 } from "vue";
var ComboboxLabel_vue_vue_type_script_setup_true_lang_default = defineComponent88({
  __name: "ComboboxLabel",
  props: {
    for: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const groupContext = injectComboboxGroupContext({
      id: "",
      labelId: ""
    });
    groupContext.labelId ||= useId2(void 0, "reka-combobox-group-label");
    return (_ctx, _cache) => {
      return openBlock80(), createBlock77(unref84(Primitive), mergeProps43(props2, { id: unref84(groupContext).labelId }), {
        default: withCtx76(() => [renderSlot80(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var ComboboxLabel_default = ComboboxLabel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxPortal.js
import { createBlock as createBlock78, defineComponent as defineComponent89, guardReactiveProps as guardReactiveProps16, normalizeProps as normalizeProps16, openBlock as openBlock81, renderSlot as renderSlot81, unref as unref85, withCtx as withCtx77 } from "vue";
var ComboboxPortal_vue_vue_type_script_setup_true_lang_default = defineComponent89({
  __name: "ComboboxPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock81(), createBlock78(unref85(Teleport_default), normalizeProps16(guardReactiveProps16(props2)), {
        default: withCtx77(() => [renderSlot81(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ComboboxPortal_default = ComboboxPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxSeparator.js
import { createBlock as createBlock79, defineComponent as defineComponent90, mergeProps as mergeProps44, openBlock as openBlock82, renderSlot as renderSlot82, unref as unref86, withCtx as withCtx78 } from "vue";
var ComboboxSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent90({
  __name: "ComboboxSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock82(), createBlock79(unref86(Primitive), mergeProps44(props2, { "aria-hidden": "true" }), {
        default: withCtx78(() => [renderSlot82(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ComboboxSeparator_default = ComboboxSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxTrigger.js
import { computed as computed44, createBlock as createBlock80, defineComponent as defineComponent91, mergeProps as mergeProps45, onMounted as onMounted19, openBlock as openBlock83, renderSlot as renderSlot83, unref as unref87, withCtx as withCtx79 } from "vue";
var ComboboxTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent91({
  __name: "ComboboxTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectComboboxRootContext();
    const disabled = computed44(() => props2.disabled || rootContext.disabled.value || false);
    onMounted19(() => {
      if (currentElement.value) rootContext.onTriggerElementChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock83(), createBlock80(unref87(Primitive), mergeProps45(props2, {
        ref: unref87(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        tabindex: "-1",
        "aria-label": "Show popup",
        "aria-haspopup": "listbox",
        "aria-expanded": unref87(rootContext).open.value,
        "aria-controls": unref87(rootContext).contentId,
        "data-state": unref87(rootContext).open.value ? "open" : "closed",
        disabled: disabled.value,
        "data-disabled": disabled.value ? "" : void 0,
        "aria-disabled": disabled.value ?? void 0,
        onClick: _cache[0] || (_cache[0] = ($event) => unref87(rootContext).onOpenChange(!unref87(rootContext).open.value))
      }), {
        default: withCtx79(() => [renderSlot83(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "type",
        "aria-expanded",
        "aria-controls",
        "data-state",
        "disabled",
        "data-disabled",
        "aria-disabled"
      ]);
    };
  }
});
var ComboboxTrigger_default = ComboboxTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/shared/useNonce.js
import { computed as computed45, ref as ref35 } from "vue";
function useNonce(nonce) {
  const context2 = injectConfigProviderContext({ nonce: ref35() });
  return computed45(() => nonce?.value || context2.nonce?.value);
}

// node_modules/reka-ui/dist/Combobox/ComboboxViewport.js
import { Fragment as Fragment5, createElementBlock as createElementBlock7, createTextVNode as createTextVNode7, createVNode as createVNode16, defineComponent as defineComponent92, mergeProps as mergeProps46, openBlock as openBlock84, renderSlot as renderSlot84, toRefs as toRefs14, unref as unref88, withCtx as withCtx80 } from "vue";
var ComboboxViewport_vue_vue_type_script_setup_true_lang_default = defineComponent92({
  __name: "ComboboxViewport",
  props: {
    nonce: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const { nonce: propNonce } = toRefs14(props2);
    const nonce = useNonce(propNonce);
    const rootContext = injectComboboxRootContext();
    return (_ctx, _cache) => {
      return openBlock84(), createElementBlock7(Fragment5, null, [createVNode16(unref88(Primitive), mergeProps46({
        ..._ctx.$attrs,
        ...props2
      }, {
        ref: unref88(forwardRef),
        "data-reka-combobox-viewport": "",
        role: "presentation",
        style: {
          position: "relative",
          flex: unref88(rootContext).isVirtual.value ? void 0 : 1,
          overflow: "auto"
        }
      }), {
        default: withCtx80(() => [renderSlot84(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["style"]), createVNode16(unref88(Primitive), {
        as: "style",
        nonce: unref88(nonce)
      }, {
        default: withCtx80(() => _cache[0] || (_cache[0] = [createTextVNode7(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
        _: 1,
        __: [0]
      }, 8, ["nonce"])], 64);
    };
  }
});
var ComboboxViewport_default = ComboboxViewport_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Combobox/ComboboxVirtualizer.js
import { createBlock as createBlock81, defineComponent as defineComponent93, guardReactiveProps as guardReactiveProps17, normalizeProps as normalizeProps17, openBlock as openBlock85, renderSlot as renderSlot85, withCtx as withCtx81 } from "vue";
var ComboboxVirtualizer_vue_vue_type_script_setup_true_lang_default = defineComponent93({
  __name: "ComboboxVirtualizer",
  props: {
    options: {
      type: Array,
      required: true
    },
    overscan: {
      type: Number,
      required: false
    },
    estimateSize: {
      type: Number,
      required: false
    },
    textContent: {
      type: Function,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectComboboxRootContext();
    rootContext.isVirtual.value = true;
    return (_ctx, _cache) => {
      return openBlock85(), createBlock81(ListboxVirtualizer_default, normalizeProps17(guardReactiveProps17(props2)), {
        default: withCtx81((slotProps) => [renderSlot85(_ctx.$slots, "default", normalizeProps17(guardReactiveProps17(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var ComboboxVirtualizer_default = ComboboxVirtualizer_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuAnchor.js
import { createBlock as createBlock82, defineComponent as defineComponent94, guardReactiveProps as guardReactiveProps18, normalizeProps as normalizeProps18, openBlock as openBlock86, renderSlot as renderSlot86, unref as unref89, withCtx as withCtx82 } from "vue";
var MenuAnchor_vue_vue_type_script_setup_true_lang_default = defineComponent94({
  __name: "MenuAnchor",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock86(), createBlock82(unref89(PopperAnchor_default), normalizeProps18(guardReactiveProps18(props2)), {
        default: withCtx82(() => [renderSlot86(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuAnchor_default = MenuAnchor_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuArrow.js
import { createBlock as createBlock83, defineComponent as defineComponent95, guardReactiveProps as guardReactiveProps19, normalizeProps as normalizeProps19, openBlock as openBlock87, renderSlot as renderSlot87, unref as unref90, withCtx as withCtx83 } from "vue";
var MenuArrow_vue_vue_type_script_setup_true_lang_default = defineComponent95({
  __name: "MenuArrow",
  props: {
    width: {
      type: Number,
      required: false
    },
    height: {
      type: Number,
      required: false
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock87(), createBlock83(unref90(PopperArrow_default), normalizeProps19(guardReactiveProps19(props2)), {
        default: withCtx83(() => [renderSlot87(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuArrow_default = MenuArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/shared/useIsUsingKeyboard.js
import { onMounted as onMounted20, ref as ref36 } from "vue";
function useIsUsingKeyboardImpl() {
  const isUsingKeyboard = ref36(false);
  onMounted20(() => {
    useEventListener("keydown", () => {
      isUsingKeyboard.value = true;
    }, {
      capture: true,
      passive: true
    });
    useEventListener(["pointerdown", "pointermove"], () => {
      isUsingKeyboard.value = false;
    }, {
      capture: true,
      passive: true
    });
  });
  return isUsingKeyboard;
}
var useIsUsingKeyboard = createSharedComposable(useIsUsingKeyboardImpl);

// node_modules/reka-ui/dist/Menu/MenuRoot.js
import { createBlock as createBlock84, defineComponent as defineComponent96, openBlock as openBlock88, ref as ref37, renderSlot as renderSlot88, toRefs as toRefs15, unref as unref91, withCtx as withCtx84 } from "vue";
var [injectMenuContext, provideMenuContext] = createContext(["MenuRoot", "MenuSub"], "MenuContext");
var [injectMenuRootContext, provideMenuRootContext] = createContext("MenuRoot");
var MenuRoot_vue_vue_type_script_setup_true_lang_default = defineComponent96({
  __name: "MenuRoot",
  props: {
    open: {
      type: Boolean,
      required: false,
      default: false
    },
    dir: {
      type: String,
      required: false
    },
    modal: {
      type: Boolean,
      required: false,
      default: true
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { modal, dir: propDir } = toRefs15(props2);
    const dir = useDirection(propDir);
    const open = useVModel(props2, "open", emits);
    const content = ref37();
    const isUsingKeyboardRef = useIsUsingKeyboard();
    provideMenuContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      content,
      onContentChange: (element) => {
        content.value = element;
      }
    });
    provideMenuRootContext({
      onClose: () => {
        open.value = false;
      },
      isUsingKeyboardRef,
      dir,
      modal
    });
    return (_ctx, _cache) => {
      return openBlock88(), createBlock84(unref91(PopperRoot_default), null, {
        default: withCtx84(() => [renderSlot88(_ctx.$slots, "default")]),
        _: 3
      });
    };
  }
});
var MenuRoot_default = MenuRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuContentImpl.js
import { createBlock as createBlock85, createVNode as createVNode17, defineComponent as defineComponent97, mergeDefaults as mergeDefaults2, onUnmounted as onUnmounted11, openBlock as openBlock89, ref as ref38, renderSlot as renderSlot89, toRefs as toRefs16, unref as unref92, watch as watch16, withCtx as withCtx85 } from "vue";
var [injectMenuContentContext, provideMenuContentContext] = createContext("MenuContent");
var MenuContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent97({
  __name: "MenuContentImpl",
  props: mergeDefaults2({
    loop: {
      type: Boolean,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    disableOutsideScroll: {
      type: Boolean,
      required: false
    },
    trapFocus: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  }, { ...PopperContentPropsDefaultValue }),
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus",
    "dismiss"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const { trapFocus, disableOutsidePointerEvents, loop } = toRefs16(props2);
    useFocusGuards();
    useBodyScrollLock(disableOutsidePointerEvents.value);
    const searchRef = ref38("");
    const timerRef = ref38(0);
    const pointerGraceTimerRef = ref38(0);
    const pointerGraceIntentRef = ref38(null);
    const pointerDirRef = ref38("right");
    const lastPointerXRef = ref38(0);
    const currentItemId = ref38(null);
    const rovingFocusGroupRef = ref38();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const { handleTypeaheadSearch } = useTypeahead();
    watch16(contentElement, (el) => {
      menuContext.onContentChange(el);
    });
    onUnmounted11(() => {
      window.clearTimeout(timerRef.value);
    });
    function isPointerMovingToSubmenu(event) {
      const isMovingTowards = pointerDirRef.value === pointerGraceIntentRef.value?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.value?.area);
    }
    async function handleMountAutoFocus(event) {
      emits("openAutoFocus", event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      contentElement.value?.focus({ preventScroll: true });
    }
    function handleKeyDown(event) {
      if (event.defaultPrevented) return;
      const target = event.target;
      const isKeyDownInside = target.closest("[data-reka-menu-content]") === event.currentTarget;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isCharacterKey = event.key.length === 1;
      const el = useArrowNavigation(event, getActiveElement(), contentElement.value, {
        loop: loop.value,
        arrowKeyOptions: "vertical",
        dir: rootContext?.dir.value,
        focus: true,
        attributeName: "[data-reka-collection-item]:not([data-disabled])"
      });
      if (el) return el?.focus();
      if (event.code === "Space") return;
      const collectionItems = rovingFocusGroupRef.value?.getItems() ?? [];
      if (isKeyDownInside) {
        if (event.key === "Tab") event.preventDefault();
        if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key, collectionItems);
      }
      if (event.target !== contentElement.value) return;
      if (!FIRST_LAST_KEYS.includes(event.key)) return;
      event.preventDefault();
      const candidateNodes = [...collectionItems.map((item) => item.ref)];
      if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
      focusFirst2(candidateNodes);
    }
    function handleBlur(event) {
      if (!event?.currentTarget?.contains?.(event.target)) {
        window.clearTimeout(timerRef.value);
        searchRef.value = "";
      }
    }
    function handlePointerMove2(event) {
      if (!isMouseEvent(event)) return;
      const target = event.target;
      const pointerXHasChanged = lastPointerXRef.value !== event.clientX;
      if (event?.currentTarget?.contains(target) && pointerXHasChanged) {
        const newDir = event.clientX > lastPointerXRef.value ? "right" : "left";
        pointerDirRef.value = newDir;
        lastPointerXRef.value = event.clientX;
      }
    }
    provideMenuContentContext({
      onItemEnter: (event) => {
        if (isPointerMovingToSubmenu(event)) return true;
        else return false;
      },
      onItemLeave: (event) => {
        if (isPointerMovingToSubmenu(event)) return;
        contentElement.value?.focus();
        currentItemId.value = null;
      },
      onTriggerLeave: (event) => {
        if (isPointerMovingToSubmenu(event)) return true;
        else return false;
      },
      searchRef,
      pointerGraceTimerRef,
      onPointerGraceIntentChange: (intent) => {
        pointerGraceIntentRef.value = intent;
      }
    });
    return (_ctx, _cache) => {
      return openBlock89(), createBlock85(unref92(FocusScope_default), {
        "as-child": "",
        trapped: unref92(trapFocus),
        onMountAutoFocus: handleMountAutoFocus,
        onUnmountAutoFocus: _cache[7] || (_cache[7] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx85(() => [createVNode17(unref92(DismissableLayer_default), {
          "as-child": "",
          "disable-outside-pointer-events": unref92(disableOutsidePointerEvents),
          onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
          onPointerDownOutside: _cache[3] || (_cache[3] = ($event) => emits("pointerDownOutside", $event)),
          onFocusOutside: _cache[4] || (_cache[4] = ($event) => emits("focusOutside", $event)),
          onInteractOutside: _cache[5] || (_cache[5] = ($event) => emits("interactOutside", $event)),
          onDismiss: _cache[6] || (_cache[6] = ($event) => emits("dismiss"))
        }, {
          default: withCtx85(() => [createVNode17(unref92(RovingFocusGroup_default), {
            ref_key: "rovingFocusGroupRef",
            ref: rovingFocusGroupRef,
            "current-tab-stop-id": currentItemId.value,
            "onUpdate:currentTabStopId": _cache[0] || (_cache[0] = ($event) => currentItemId.value = $event),
            "as-child": "",
            orientation: "vertical",
            dir: unref92(rootContext).dir.value,
            loop: unref92(loop),
            onEntryFocus: _cache[1] || (_cache[1] = (event) => {
              emits("entryFocus", event);
              if (!unref92(rootContext).isUsingKeyboardRef.value) event.preventDefault();
            })
          }, {
            default: withCtx85(() => [createVNode17(unref92(PopperContent_default), {
              ref: unref92(forwardRef),
              role: "menu",
              as: _ctx.as,
              "as-child": _ctx.asChild,
              "aria-orientation": "vertical",
              "data-reka-menu-content": "",
              "data-state": unref92(getOpenState)(unref92(menuContext).open.value),
              dir: unref92(rootContext).dir.value,
              side: _ctx.side,
              "side-offset": _ctx.sideOffset,
              align: _ctx.align,
              "align-offset": _ctx.alignOffset,
              "avoid-collisions": _ctx.avoidCollisions,
              "collision-boundary": _ctx.collisionBoundary,
              "collision-padding": _ctx.collisionPadding,
              "arrow-padding": _ctx.arrowPadding,
              "prioritize-position": _ctx.prioritizePosition,
              "position-strategy": _ctx.positionStrategy,
              "update-position-strategy": _ctx.updatePositionStrategy,
              sticky: _ctx.sticky,
              "hide-when-detached": _ctx.hideWhenDetached,
              reference: _ctx.reference,
              onKeydown: handleKeyDown,
              onBlur: handleBlur,
              onPointermove: handlePointerMove2
            }, {
              default: withCtx85(() => [renderSlot89(_ctx.$slots, "default")]),
              _: 3
            }, 8, [
              "as",
              "as-child",
              "data-state",
              "dir",
              "side",
              "side-offset",
              "align",
              "align-offset",
              "avoid-collisions",
              "collision-boundary",
              "collision-padding",
              "arrow-padding",
              "prioritize-position",
              "position-strategy",
              "update-position-strategy",
              "sticky",
              "hide-when-detached",
              "reference"
            ])]),
            _: 3
          }, 8, [
            "current-tab-stop-id",
            "dir",
            "loop"
          ])]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});
var MenuContentImpl_default = MenuContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuItemImpl.js
import { createBlock as createBlock86, createVNode as createVNode18, defineComponent as defineComponent98, mergeProps as mergeProps47, nextTick as nextTick15, openBlock as openBlock90, ref as ref39, renderSlot as renderSlot90, unref as unref93, withCtx as withCtx86 } from "vue";
var MenuItemImpl_vue_vue_type_script_setup_true_lang_default = defineComponent98({
  inheritAttrs: false,
  __name: "MenuItemImpl",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const contentContext = injectMenuContentContext();
    const { forwardRef } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const isFocused = ref39(false);
    async function handlePointerMove2(event) {
      if (event.defaultPrevented) return;
      if (!isMouseEvent(event)) return;
      if (props2.disabled) contentContext.onItemLeave(event);
      else {
        const defaultPrevented = contentContext.onItemEnter(event);
        if (!defaultPrevented) {
          const item = event.currentTarget;
          item?.focus({ preventScroll: true });
        }
      }
    }
    async function handlePointerLeave(event) {
      await nextTick15();
      if (event.defaultPrevented) return;
      if (!isMouseEvent(event)) return;
      contentContext.onItemLeave(event);
    }
    return (_ctx, _cache) => {
      return openBlock90(), createBlock86(unref93(CollectionItem), { value: { textValue: _ctx.textValue } }, {
        default: withCtx86(() => [createVNode18(unref93(Primitive), mergeProps47({
          ref: unref93(forwardRef),
          role: "menuitem",
          tabindex: "-1"
        }, _ctx.$attrs, {
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "aria-disabled": _ctx.disabled || void 0,
          "data-disabled": _ctx.disabled ? "" : void 0,
          "data-highlighted": isFocused.value ? "" : void 0,
          onPointermove: handlePointerMove2,
          onPointerleave: handlePointerLeave,
          onFocus: _cache[0] || (_cache[0] = async (event) => {
            await nextTick15();
            if (event.defaultPrevented || _ctx.disabled) return;
            isFocused.value = true;
          }),
          onBlur: _cache[1] || (_cache[1] = async (event) => {
            await nextTick15();
            if (event.defaultPrevented) return;
            isFocused.value = false;
          })
        }), {
          default: withCtx86(() => [renderSlot90(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "as",
          "as-child",
          "aria-disabled",
          "data-disabled",
          "data-highlighted"
        ])]),
        _: 3
      }, 8, ["value"]);
    };
  }
});
var MenuItemImpl_default = MenuItemImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuItem.js
import { createBlock as createBlock87, defineComponent as defineComponent99, mergeProps as mergeProps48, nextTick as nextTick16, openBlock as openBlock91, ref as ref40, renderSlot as renderSlot91, unref as unref94, withCtx as withCtx87 } from "vue";
var MenuItem_vue_vue_type_script_setup_true_lang_default = defineComponent99({
  __name: "MenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectMenuRootContext();
    const contentContext = injectMenuContentContext();
    const isPointerDownRef = ref40(false);
    async function handleSelect2() {
      const menuItem = currentElement.value;
      if (!props2.disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, {
          bubbles: true,
          cancelable: true
        });
        emits("select", itemSelectEvent);
        await nextTick16();
        if (itemSelectEvent.defaultPrevented) isPointerDownRef.value = false;
        else rootContext.onClose();
      }
    }
    return (_ctx, _cache) => {
      return openBlock91(), createBlock87(MenuItemImpl_default, mergeProps48(props2, {
        ref: unref94(forwardRef),
        onClick: handleSelect2,
        onPointerdown: _cache[0] || (_cache[0] = () => {
          isPointerDownRef.value = true;
        }),
        onPointerup: _cache[1] || (_cache[1] = async (event) => {
          await nextTick16();
          if (event.defaultPrevented) return;
          if (!isPointerDownRef.value) event.currentTarget?.click();
        }),
        onKeydown: _cache[2] || (_cache[2] = async (event) => {
          const isTypingAhead = unref94(contentContext).searchRef.value !== "";
          if (_ctx.disabled || isTypingAhead && event.key === " ") return;
          if (unref94(SELECTION_KEYS).includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }), {
        default: withCtx87(() => [renderSlot91(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuItem_default = MenuItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuItemIndicator.js
import { createBlock as createBlock88, createVNode as createVNode19, defineComponent as defineComponent100, openBlock as openBlock92, ref as ref41, renderSlot as renderSlot92, unref as unref95, withCtx as withCtx88 } from "vue";
var [injectMenuItemIndicatorContext, provideMenuItemIndicatorContext] = createContext(["MenuCheckboxItem", "MenuRadioItem"], "MenuItemIndicatorContext");
var MenuItemIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent100({
  __name: "MenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const indicatorContext = injectMenuItemIndicatorContext({ modelValue: ref41(false) });
    return (_ctx, _cache) => {
      return openBlock92(), createBlock88(unref95(Presence_default), { present: _ctx.forceMount || unref95(isIndeterminate)(unref95(indicatorContext).modelValue.value) || unref95(indicatorContext).modelValue.value === true }, {
        default: withCtx88(() => [createVNode19(unref95(Primitive), {
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-state": unref95(getCheckedState)(unref95(indicatorContext).modelValue.value)
        }, {
          default: withCtx88(() => [renderSlot92(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "data-state"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var MenuItemIndicator_default = MenuItemIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuCheckboxItem.js
import { createBlock as createBlock89, defineComponent as defineComponent101, mergeProps as mergeProps49, openBlock as openBlock93, renderSlot as renderSlot93, unref as unref96, withCtx as withCtx89 } from "vue";
var MenuCheckboxItem_vue_vue_type_script_setup_true_lang_default = defineComponent101({
  __name: "MenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: false,
      default: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const delegatedProps = reactiveOmit(props2, ["modelValue"]);
    const forwarded = useForwardProps(delegatedProps);
    const modelValue = useVModel(props2, "modelValue", emits);
    provideMenuItemIndicatorContext({ modelValue });
    return (_ctx, _cache) => {
      return openBlock93(), createBlock89(MenuItem_default, mergeProps49({ role: "menuitemcheckbox" }, unref96(forwarded), {
        "aria-checked": unref96(isIndeterminate)(unref96(modelValue)) ? "mixed" : unref96(modelValue),
        "data-state": unref96(getCheckedState)(unref96(modelValue)),
        onSelect: _cache[0] || (_cache[0] = async (event) => {
          emits("select", event);
          if (unref96(isIndeterminate)(unref96(modelValue))) modelValue.value = true;
          else modelValue.value = !unref96(modelValue);
        })
      }), {
        default: withCtx89(() => [renderSlot93(_ctx.$slots, "default", { modelValue: unref96(modelValue) })]),
        _: 3
      }, 16, ["aria-checked", "data-state"]);
    };
  }
});
var MenuCheckboxItem_default = MenuCheckboxItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuRootContentModal.js
import { createBlock as createBlock90, defineComponent as defineComponent102, mergeProps as mergeProps50, openBlock as openBlock94, renderSlot as renderSlot94, unref as unref97, withCtx as withCtx90, withModifiers as withModifiers8 } from "vue";
var MenuRootContentModal_vue_vue_type_script_setup_true_lang_default = defineComponent102({
  __name: "MenuRootContentModal",
  props: {
    loop: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock94(), createBlock90(MenuContentImpl_default, mergeProps50(unref97(forwarded), {
        ref: unref97(forwardRef),
        "trap-focus": unref97(menuContext).open.value,
        "disable-outside-pointer-events": unref97(menuContext).open.value,
        "disable-outside-scroll": true,
        onDismiss: _cache[0] || (_cache[0] = ($event) => unref97(menuContext).onOpenChange(false)),
        onFocusOutside: _cache[1] || (_cache[1] = withModifiers8(($event) => emits("focusOutside", $event), ["prevent"]))
      }), {
        default: withCtx90(() => [renderSlot94(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["trap-focus", "disable-outside-pointer-events"]);
    };
  }
});
var MenuRootContentModal_default = MenuRootContentModal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuRootContentNonModal.js
import { createBlock as createBlock91, defineComponent as defineComponent103, mergeProps as mergeProps51, openBlock as openBlock95, renderSlot as renderSlot95, unref as unref98, withCtx as withCtx91 } from "vue";
var MenuRootContentNonModal_vue_vue_type_script_setup_true_lang_default = defineComponent103({
  __name: "MenuRootContentNonModal",
  props: {
    loop: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    return (_ctx, _cache) => {
      return openBlock95(), createBlock91(MenuContentImpl_default, mergeProps51(unref98(forwarded), {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        "disable-outside-scroll": false,
        onDismiss: _cache[0] || (_cache[0] = ($event) => unref98(menuContext).onOpenChange(false))
      }), {
        default: withCtx91(() => [renderSlot95(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuRootContentNonModal_default = MenuRootContentNonModal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuContent.js
import { createBlock as createBlock92, createCommentVNode as createCommentVNode15, defineComponent as defineComponent104, guardReactiveProps as guardReactiveProps20, mergeProps as mergeProps52, normalizeProps as normalizeProps20, openBlock as openBlock96, renderSlot as renderSlot96, unref as unref99, withCtx as withCtx92 } from "vue";
var MenuContent_vue_vue_type_script_setup_true_lang_default = defineComponent104({
  __name: "MenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    return (_ctx, _cache) => {
      return openBlock96(), createBlock92(unref99(Presence_default), { present: _ctx.forceMount || unref99(menuContext).open.value }, {
        default: withCtx92(() => [unref99(rootContext).modal.value ? (openBlock96(), createBlock92(MenuRootContentModal_default, normalizeProps20(mergeProps52({ key: 0 }, {
          ..._ctx.$attrs,
          ...unref99(forwarded)
        })), {
          default: withCtx92(() => [renderSlot96(_ctx.$slots, "default")]),
          _: 3
        }, 16)) : (openBlock96(), createBlock92(MenuRootContentNonModal_default, normalizeProps20(mergeProps52({ key: 1 }, {
          ..._ctx.$attrs,
          ...unref99(forwarded)
        })), {
          default: withCtx92(() => [renderSlot96(_ctx.$slots, "default")]),
          _: 3
        }, 16))]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var MenuContent_default = MenuContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuGroup.js
import { createBlock as createBlock93, defineComponent as defineComponent105, mergeProps as mergeProps53, openBlock as openBlock97, renderSlot as renderSlot97, unref as unref100, withCtx as withCtx93 } from "vue";
var MenuGroup_vue_vue_type_script_setup_true_lang_default = defineComponent105({
  __name: "MenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock97(), createBlock93(unref100(Primitive), mergeProps53({ role: "group" }, props2), {
        default: withCtx93(() => [renderSlot97(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuGroup_default = MenuGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuLabel.js
import { createBlock as createBlock94, defineComponent as defineComponent106, guardReactiveProps as guardReactiveProps21, normalizeProps as normalizeProps21, openBlock as openBlock98, renderSlot as renderSlot98, unref as unref101, withCtx as withCtx94 } from "vue";
var MenuLabel_vue_vue_type_script_setup_true_lang_default = defineComponent106({
  __name: "MenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock98(), createBlock94(unref101(Primitive), normalizeProps21(guardReactiveProps21(props2)), {
        default: withCtx94(() => [renderSlot98(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuLabel_default = MenuLabel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuPortal.js
import { createBlock as createBlock95, defineComponent as defineComponent107, guardReactiveProps as guardReactiveProps22, normalizeProps as normalizeProps22, openBlock as openBlock99, renderSlot as renderSlot99, unref as unref102, withCtx as withCtx95 } from "vue";
var MenuPortal_vue_vue_type_script_setup_true_lang_default = defineComponent107({
  __name: "MenuPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock99(), createBlock95(unref102(Teleport_default), normalizeProps22(guardReactiveProps22(props2)), {
        default: withCtx95(() => [renderSlot99(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuPortal_default = MenuPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuRadioGroup.js
import { createBlock as createBlock96, defineComponent as defineComponent108, guardReactiveProps as guardReactiveProps23, normalizeProps as normalizeProps23, openBlock as openBlock100, renderSlot as renderSlot100, unref as unref103, withCtx as withCtx96 } from "vue";
var [injectMenuRadioGroupContext, provideMenuRadioGroupContext] = createContext("MenuRadioGroup");
var MenuRadioGroup_vue_vue_type_script_setup_true_lang_default = defineComponent108({
  __name: "MenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: false,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const delegatedProps = reactiveOmit(props2, ["modelValue"]);
    const forwarded = useForwardProps(delegatedProps);
    const modelValue = useVModel(props2, "modelValue", emits);
    provideMenuRadioGroupContext({
      modelValue,
      onValueChange: (payload) => {
        modelValue.value = payload;
      }
    });
    return (_ctx, _cache) => {
      return openBlock100(), createBlock96(MenuGroup_default, normalizeProps23(guardReactiveProps23(unref103(forwarded))), {
        default: withCtx96(() => [renderSlot100(_ctx.$slots, "default", { modelValue: unref103(modelValue) })]),
        _: 3
      }, 16);
    };
  }
});
var MenuRadioGroup_default = MenuRadioGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuRadioItem.js
import { computed as computed46, createBlock as createBlock97, defineComponent as defineComponent109, mergeProps as mergeProps54, openBlock as openBlock101, renderSlot as renderSlot101, toRefs as toRefs17, unref as unref104, withCtx as withCtx97 } from "vue";
var MenuRadioItem_vue_vue_type_script_setup_true_lang_default = defineComponent109({
  __name: "MenuRadioItem",
  props: {
    value: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const delegatedProps = reactiveOmit(props2, ["value"]);
    const forwarded = useForwardProps(delegatedProps);
    const { value } = toRefs17(props2);
    const radioGroupContext = injectMenuRadioGroupContext();
    const modelValue = computed46(() => radioGroupContext.modelValue.value === value?.value);
    provideMenuItemIndicatorContext({ modelValue });
    return (_ctx, _cache) => {
      return openBlock101(), createBlock97(MenuItem_default, mergeProps54({ role: "menuitemradio" }, unref104(forwarded), {
        "aria-checked": modelValue.value,
        "data-state": unref104(getCheckedState)(modelValue.value),
        onSelect: _cache[0] || (_cache[0] = async (event) => {
          emits("select", event);
          unref104(radioGroupContext).onValueChange(unref104(value));
        })
      }), {
        default: withCtx97(() => [renderSlot101(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["aria-checked", "data-state"]);
    };
  }
});
var MenuRadioItem_default = MenuRadioItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuSeparator.js
import { createBlock as createBlock98, defineComponent as defineComponent110, mergeProps as mergeProps55, openBlock as openBlock102, renderSlot as renderSlot102, unref as unref105, withCtx as withCtx98 } from "vue";
var MenuSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent110({
  __name: "MenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock102(), createBlock98(unref105(Primitive), mergeProps55(props2, {
        role: "separator",
        "aria-orientation": "horizontal"
      }), {
        default: withCtx98(() => [renderSlot102(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenuSeparator_default = MenuSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuSub.js
import { createBlock as createBlock99, defineComponent as defineComponent111, openBlock as openBlock103, ref as ref42, renderSlot as renderSlot103, unref as unref106, watchEffect as watchEffect12, withCtx as withCtx99 } from "vue";
var [injectMenuSubContext, provideMenuSubContext] = createContext("MenuSub");
var MenuSub_vue_vue_type_script_setup_true_lang_default = defineComponent111({
  __name: "MenuSub",
  props: { open: {
    type: Boolean,
    required: false,
    default: void 0
  } },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const open = useVModel(props2, "open", emits, {
      defaultValue: false,
      passive: props2.open === void 0
    });
    const parentMenuContext = injectMenuContext();
    const trigger = ref42();
    const content = ref42();
    watchEffect12((cleanupFn) => {
      if (parentMenuContext?.open.value === false) open.value = false;
      cleanupFn(() => open.value = false);
    });
    provideMenuContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      content,
      onContentChange: (element) => {
        content.value = element;
      }
    });
    provideMenuSubContext({
      triggerId: "",
      contentId: "",
      trigger,
      onTriggerChange: (element) => {
        trigger.value = element;
      }
    });
    return (_ctx, _cache) => {
      return openBlock103(), createBlock99(unref106(PopperRoot_default), null, {
        default: withCtx99(() => [renderSlot103(_ctx.$slots, "default")]),
        _: 3
      });
    };
  }
});
var MenuSub_default = MenuSub_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuSubContent.js
import { createBlock as createBlock100, createVNode as createVNode20, defineComponent as defineComponent112, mergeProps as mergeProps56, openBlock as openBlock104, renderSlot as renderSlot104, unref as unref107, withCtx as withCtx100, withModifiers as withModifiers9 } from "vue";
var MenuSubContent_vue_vue_type_script_setup_true_lang_default = defineComponent112({
  __name: "MenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false,
      default: true
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const menuSubContext = injectMenuSubContext();
    const { forwardRef, currentElement: subContentElement } = useForwardExpose();
    menuSubContext.contentId ||= useId2(void 0, "reka-menu-sub-content");
    return (_ctx, _cache) => {
      return openBlock104(), createBlock100(unref107(Presence_default), { present: _ctx.forceMount || unref107(menuContext).open.value }, {
        default: withCtx100(() => [createVNode20(MenuContentImpl_default, mergeProps56(unref107(forwarded), {
          id: unref107(menuSubContext).contentId,
          ref: unref107(forwardRef),
          "aria-labelledby": unref107(menuSubContext).triggerId,
          align: "start",
          side: unref107(rootContext).dir.value === "rtl" ? "left" : "right",
          "disable-outside-pointer-events": false,
          "disable-outside-scroll": false,
          "trap-focus": false,
          onOpenAutoFocus: _cache[0] || (_cache[0] = withModifiers9((event) => {
            if (unref107(rootContext).isUsingKeyboardRef.value) unref107(subContentElement)?.focus();
          }, ["prevent"])),
          onCloseAutoFocus: _cache[1] || (_cache[1] = withModifiers9(() => {
          }, ["prevent"])),
          onFocusOutside: _cache[2] || (_cache[2] = (event) => {
            if (event.defaultPrevented) return;
            if (event.target !== unref107(menuSubContext).trigger.value) unref107(menuContext).onOpenChange(false);
          }),
          onEscapeKeyDown: _cache[3] || (_cache[3] = (event) => {
            unref107(rootContext).onClose();
            event.preventDefault();
          }),
          onKeydown: _cache[4] || (_cache[4] = (event) => {
            const isKeyDownInside = event.currentTarget?.contains(event.target);
            const isCloseKey = unref107(SUB_CLOSE_KEYS)[unref107(rootContext).dir.value].includes(event.key);
            if (isKeyDownInside && isCloseKey) {
              unref107(menuContext).onOpenChange(false);
              unref107(menuSubContext).trigger.value?.focus();
              event.preventDefault();
            }
          })
        }), {
          default: withCtx100(() => [renderSlot104(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "aria-labelledby",
          "side"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var MenuSubContent_default = MenuSubContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menu/MenuSubTrigger.js
import { createBlock as createBlock101, createVNode as createVNode21, defineComponent as defineComponent113, mergeProps as mergeProps57, nextTick as nextTick17, onUnmounted as onUnmounted12, openBlock as openBlock105, ref as ref43, renderSlot as renderSlot105, unref as unref108, withCtx as withCtx101 } from "vue";
var MenuSubTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent113({
  __name: "MenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const menuContext = injectMenuContext();
    const rootContext = injectMenuRootContext();
    const subContext = injectMenuSubContext();
    const contentContext = injectMenuContentContext();
    const openTimerRef = ref43(null);
    subContext.triggerId ||= useId2(void 0, "reka-menu-sub-trigger");
    function clearOpenTimer() {
      if (openTimerRef.value) window.clearTimeout(openTimerRef.value);
      openTimerRef.value = null;
    }
    onUnmounted12(() => {
      clearOpenTimer();
    });
    function handlePointerMove2(event) {
      if (!isMouseEvent(event)) return;
      const defaultPrevented = contentContext.onItemEnter(event);
      if (defaultPrevented) return;
      if (!props2.disabled && !menuContext.open.value && !openTimerRef.value) {
        contentContext.onPointerGraceIntentChange(null);
        openTimerRef.value = window.setTimeout(() => {
          menuContext.onOpenChange(true);
          clearOpenTimer();
        }, 100);
      }
    }
    async function handlePointerLeave(event) {
      if (!isMouseEvent(event)) return;
      clearOpenTimer();
      const contentRect = menuContext.content.value?.getBoundingClientRect();
      if (contentRect?.width) {
        const side = menuContext.content.value?.dataset.side;
        const rightSide = side === "right";
        const bleed = rightSide ? -5 : 5;
        const contentNearEdge = contentRect[rightSide ? "left" : "right"];
        const contentFarEdge = contentRect[rightSide ? "right" : "left"];
        contentContext.onPointerGraceIntentChange({
          area: [
            {
              x: event.clientX + bleed,
              y: event.clientY
            },
            {
              x: contentNearEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.top
            },
            {
              x: contentFarEdge,
              y: contentRect.bottom
            },
            {
              x: contentNearEdge,
              y: contentRect.bottom
            }
          ],
          side
        });
        window.clearTimeout(contentContext.pointerGraceTimerRef.value);
        contentContext.pointerGraceTimerRef.value = window.setTimeout(() => contentContext.onPointerGraceIntentChange(null), 300);
      } else {
        const defaultPrevented = contentContext.onTriggerLeave(event);
        if (defaultPrevented) return;
        contentContext.onPointerGraceIntentChange(null);
      }
    }
    async function handleKeyDown(event) {
      const isTypingAhead = contentContext.searchRef.value !== "";
      if (props2.disabled || isTypingAhead && event.key === " ") return;
      if (SUB_OPEN_KEYS[rootContext.dir.value].includes(event.key)) {
        menuContext.onOpenChange(true);
        await nextTick17();
        menuContext.content.value?.focus();
        event.preventDefault();
      }
    }
    return (_ctx, _cache) => {
      return openBlock105(), createBlock101(MenuAnchor_default, { "as-child": "" }, {
        default: withCtx101(() => [createVNode21(MenuItemImpl_default, mergeProps57(props2, {
          id: unref108(subContext).triggerId,
          ref: (vnode) => {
            unref108(subContext)?.onTriggerChange(vnode?.$el);
            return void 0;
          },
          "aria-haspopup": "menu",
          "aria-expanded": unref108(menuContext).open.value,
          "aria-controls": unref108(subContext).contentId,
          "data-state": unref108(getOpenState)(unref108(menuContext).open.value),
          onClick: _cache[0] || (_cache[0] = async (event) => {
            if (props2.disabled || event.defaultPrevented) return;
            event.currentTarget.focus();
            if (!unref108(menuContext).open.value) unref108(menuContext).onOpenChange(true);
          }),
          onPointermove: handlePointerMove2,
          onPointerleave: handlePointerLeave,
          onKeydown: handleKeyDown
        }), {
          default: withCtx101(() => [renderSlot105(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "aria-expanded",
          "aria-controls",
          "data-state"
        ])]),
        _: 3
      });
    };
  }
});
var MenuSubTrigger_default = MenuSubTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuArrow.js
import { createBlock as createBlock102, defineComponent as defineComponent114, guardReactiveProps as guardReactiveProps24, normalizeProps as normalizeProps24, openBlock as openBlock106, renderSlot as renderSlot106, unref as unref109, withCtx as withCtx102 } from "vue";
var ContextMenuArrow_vue_vue_type_script_setup_true_lang_default = defineComponent114({
  __name: "ContextMenuArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock106(), createBlock102(unref109(MenuArrow_default), normalizeProps24(guardReactiveProps24(props2)), {
        default: withCtx102(() => [renderSlot106(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuArrow_default = ContextMenuArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuCheckboxItem.js
import { createBlock as createBlock103, defineComponent as defineComponent115, guardReactiveProps as guardReactiveProps25, normalizeProps as normalizeProps25, openBlock as openBlock107, renderSlot as renderSlot107, unref as unref110, withCtx as withCtx103 } from "vue";
var ContextMenuCheckboxItem_vue_vue_type_script_setup_true_lang_default = defineComponent115({
  __name: "ContextMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock107(), createBlock103(unref110(MenuCheckboxItem_default), normalizeProps25(guardReactiveProps25({
        ...props2,
        ...unref110(emitsAsProps)
      })), {
        default: withCtx103(() => [renderSlot107(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuCheckboxItem_default = ContextMenuCheckboxItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRoot.js
import { createBlock as createBlock104, defineComponent as defineComponent116, openBlock as openBlock108, ref as ref44, renderSlot as renderSlot108, toRefs as toRefs18, unref as unref111, watch as watch17, withCtx as withCtx104 } from "vue";
var [injectContextMenuRootContext, provideContextMenuRootContext] = createContext("ContextMenuRoot");
var ContextMenuRoot_vue_vue_type_script_setup_true_lang_default = defineComponent116({
  inheritAttrs: false,
  __name: "ContextMenuRoot",
  props: {
    pressOpenDelay: {
      type: Number,
      required: false,
      default: 700
    },
    dir: {
      type: String,
      required: false
    },
    modal: {
      type: Boolean,
      required: false,
      default: true
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { dir: propDir, modal, pressOpenDelay } = toRefs18(props2);
    useForwardExpose();
    const dir = useDirection(propDir);
    const open = ref44(false);
    const triggerElement = ref44();
    provideContextMenuRootContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      dir,
      modal,
      triggerElement,
      pressOpenDelay
    });
    watch17(open, (value) => {
      emits("update:open", value);
    });
    return (_ctx, _cache) => {
      return openBlock108(), createBlock104(unref111(MenuRoot_default), {
        open: open.value,
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => open.value = $event),
        dir: unref111(dir),
        modal: unref111(modal)
      }, {
        default: withCtx104(() => [renderSlot108(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "open",
        "dir",
        "modal"
      ]);
    };
  }
});
var ContextMenuRoot_default = ContextMenuRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuContent.js
import { createBlock as createBlock105, defineComponent as defineComponent117, mergeProps as mergeProps58, openBlock as openBlock109, ref as ref45, renderSlot as renderSlot109, unref as unref112, withCtx as withCtx105 } from "vue";
var ContextMenuContent_vue_vue_type_script_setup_true_lang_default = defineComponent117({
  __name: "ContextMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false,
      default: 0
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false,
      default: true
    },
    collisionBoundary: {
      type: null,
      required: false,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: false,
      default: 0
    },
    sticky: {
      type: String,
      required: false,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: false,
      default: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const rootContext = injectContextMenuRootContext();
    const hasInteractedOutside = ref45(false);
    return (_ctx, _cache) => {
      return openBlock109(), createBlock105(unref112(MenuContent_default), mergeProps58(unref112(forwarded), {
        side: "right",
        "side-offset": 2,
        align: "start",
        "update-position-strategy": "always",
        style: {
          "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
          "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
          "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          if (!event.defaultPrevented && hasInteractedOutside.value) event.preventDefault();
          hasInteractedOutside.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = (event) => {
          const originalEvent = event.detail.originalEvent;
          if (originalEvent.button === 2 && event.target === unref112(rootContext).triggerElement.value) event.preventDefault();
          if (!event.defaultPrevented && !unref112(rootContext).modal.value) hasInteractedOutside.value = true;
        })
      }), {
        default: withCtx105(() => [renderSlot109(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuContent_default = ContextMenuContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuGroup.js
import { createBlock as createBlock106, defineComponent as defineComponent118, guardReactiveProps as guardReactiveProps26, normalizeProps as normalizeProps26, openBlock as openBlock110, renderSlot as renderSlot110, unref as unref113, withCtx as withCtx106 } from "vue";
var ContextMenuGroup_vue_vue_type_script_setup_true_lang_default = defineComponent118({
  __name: "ContextMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock110(), createBlock106(unref113(MenuGroup_default), normalizeProps26(guardReactiveProps26(props2)), {
        default: withCtx106(() => [renderSlot110(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuGroup_default = ContextMenuGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuItem.js
import { createBlock as createBlock107, defineComponent as defineComponent119, guardReactiveProps as guardReactiveProps27, normalizeProps as normalizeProps27, openBlock as openBlock111, renderSlot as renderSlot111, unref as unref114, withCtx as withCtx107 } from "vue";
var ContextMenuItem_vue_vue_type_script_setup_true_lang_default = defineComponent119({
  __name: "ContextMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock111(), createBlock107(unref114(MenuItem_default), normalizeProps27(guardReactiveProps27({
        ...props2,
        ...unref114(emitsAsProps)
      })), {
        default: withCtx107(() => [renderSlot111(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuItem_default = ContextMenuItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuItemIndicator.js
import { createBlock as createBlock108, defineComponent as defineComponent120, guardReactiveProps as guardReactiveProps28, normalizeProps as normalizeProps28, openBlock as openBlock112, renderSlot as renderSlot112, unref as unref115, withCtx as withCtx108 } from "vue";
var ContextMenuItemIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent120({
  __name: "ContextMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock112(), createBlock108(unref115(MenuItemIndicator_default), normalizeProps28(guardReactiveProps28(props2)), {
        default: withCtx108(() => [renderSlot112(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuItemIndicator_default = ContextMenuItemIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuLabel.js
import { createBlock as createBlock109, defineComponent as defineComponent121, guardReactiveProps as guardReactiveProps29, normalizeProps as normalizeProps29, openBlock as openBlock113, renderSlot as renderSlot113, unref as unref116, withCtx as withCtx109 } from "vue";
var ContextMenuLabel_vue_vue_type_script_setup_true_lang_default = defineComponent121({
  __name: "ContextMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock113(), createBlock109(unref116(MenuLabel_default), normalizeProps29(guardReactiveProps29(props2)), {
        default: withCtx109(() => [renderSlot113(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuLabel_default = ContextMenuLabel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuPortal.js
import { createBlock as createBlock110, defineComponent as defineComponent122, guardReactiveProps as guardReactiveProps30, normalizeProps as normalizeProps30, openBlock as openBlock114, renderSlot as renderSlot114, unref as unref117, withCtx as withCtx110 } from "vue";
var ContextMenuPortal_vue_vue_type_script_setup_true_lang_default = defineComponent122({
  __name: "ContextMenuPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock114(), createBlock110(unref117(MenuPortal_default), normalizeProps30(guardReactiveProps30(props2)), {
        default: withCtx110(() => [renderSlot114(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuPortal_default = ContextMenuPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRadioGroup.js
import { createBlock as createBlock111, defineComponent as defineComponent123, guardReactiveProps as guardReactiveProps31, normalizeProps as normalizeProps31, openBlock as openBlock115, renderSlot as renderSlot115, unref as unref118, withCtx as withCtx111 } from "vue";
var ContextMenuRadioGroup_vue_vue_type_script_setup_true_lang_default = defineComponent123({
  __name: "ContextMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock115(), createBlock111(unref118(MenuRadioGroup_default), normalizeProps31(guardReactiveProps31({
        ...props2,
        ...unref118(emitsAsProps)
      })), {
        default: withCtx111(() => [renderSlot115(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuRadioGroup_default = ContextMenuRadioGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuRadioItem.js
import { createBlock as createBlock112, defineComponent as defineComponent124, guardReactiveProps as guardReactiveProps32, normalizeProps as normalizeProps32, openBlock as openBlock116, renderSlot as renderSlot116, unref as unref119, withCtx as withCtx112 } from "vue";
var ContextMenuRadioItem_vue_vue_type_script_setup_true_lang_default = defineComponent124({
  __name: "ContextMenuRadioItem",
  props: {
    value: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock116(), createBlock112(unref119(MenuRadioItem_default), normalizeProps32(guardReactiveProps32({
        ...props2,
        ...unref119(emitsAsProps)
      })), {
        default: withCtx112(() => [renderSlot116(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuRadioItem_default = ContextMenuRadioItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSeparator.js
import { createBlock as createBlock113, defineComponent as defineComponent125, guardReactiveProps as guardReactiveProps33, normalizeProps as normalizeProps33, openBlock as openBlock117, renderSlot as renderSlot117, unref as unref120, withCtx as withCtx113 } from "vue";
var ContextMenuSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent125({
  __name: "ContextMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock117(), createBlock113(unref120(MenuSeparator_default), normalizeProps33(guardReactiveProps33(props2)), {
        default: withCtx113(() => [renderSlot117(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuSeparator_default = ContextMenuSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSub.js
import { createBlock as createBlock114, defineComponent as defineComponent126, isRef as isRef5, openBlock as openBlock118, renderSlot as renderSlot118, unref as unref121, withCtx as withCtx114 } from "vue";
var ContextMenuSub_vue_vue_type_script_setup_true_lang_default = defineComponent126({
  __name: "ContextMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    return (_ctx, _cache) => {
      return openBlock118(), createBlock114(unref121(MenuSub_default), {
        open: unref121(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef5(open) ? open.value = $event : null)
      }, {
        default: withCtx114(() => [renderSlot118(_ctx.$slots, "default", { open: unref121(open) })]),
        _: 3
      }, 8, ["open"]);
    };
  }
});
var ContextMenuSub_default = ContextMenuSub_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSubContent.js
import { createBlock as createBlock115, defineComponent as defineComponent127, mergeProps as mergeProps59, openBlock as openBlock119, renderSlot as renderSlot119, unref as unref122, withCtx as withCtx115 } from "vue";
var ContextMenuSubContent_vue_vue_type_script_setup_true_lang_default = defineComponent127({
  __name: "ContextMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock119(), createBlock115(unref122(MenuSubContent_default), mergeProps59(unref122(forwarded), { style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: withCtx115(() => [renderSlot119(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuSubContent_default = ContextMenuSubContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/ContextMenuSubTrigger.js
import { createBlock as createBlock116, defineComponent as defineComponent128, guardReactiveProps as guardReactiveProps34, normalizeProps as normalizeProps34, openBlock as openBlock120, renderSlot as renderSlot120, unref as unref123, withCtx as withCtx116 } from "vue";
var ContextMenuSubTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent128({
  __name: "ContextMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock120(), createBlock116(unref123(MenuSubTrigger_default), normalizeProps34(guardReactiveProps34(props2)), {
        default: withCtx116(() => [renderSlot120(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ContextMenuSubTrigger_default = ContextMenuSubTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ContextMenu/utils.js
function isTouchOrPen(event) {
  return event.pointerType !== "mouse";
}

// node_modules/reka-ui/dist/ContextMenu/ContextMenuTrigger.js
import { Fragment as Fragment6, computed as computed47, createElementBlock as createElementBlock8, createVNode as createVNode22, defineComponent as defineComponent129, mergeProps as mergeProps60, nextTick as nextTick18, onMounted as onMounted21, openBlock as openBlock121, ref as ref46, renderSlot as renderSlot121, toRefs as toRefs19, unref as unref124, withCtx as withCtx117 } from "vue";
var ContextMenuTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent129({
  inheritAttrs: false,
  __name: "ContextMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { disabled } = toRefs19(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectContextMenuRootContext();
    const point = ref46({
      x: 0,
      y: 0
    });
    const virtualEl = computed47(() => ({ getBoundingClientRect: () => ({
      width: 0,
      height: 0,
      left: point.value.x,
      right: point.value.x,
      top: point.value.y,
      bottom: point.value.y,
      ...point.value
    }) }));
    const longPressTimer = ref46(0);
    function clearLongPress() {
      window.clearTimeout(longPressTimer.value);
    }
    function handleOpen(event) {
      point.value = {
        x: event.clientX,
        y: event.clientY
      };
      rootContext.onOpenChange(true);
    }
    async function handleContextMenu(event) {
      if (!disabled.value) {
        await nextTick18();
        if (!event.defaultPrevented) {
          clearLongPress();
          handleOpen(event);
          event.preventDefault();
        }
      }
    }
    async function handlePointerDown2(event) {
      if (!disabled.value) {
        await nextTick18();
        if (isTouchOrPen(event) && !event.defaultPrevented) {
          clearLongPress();
          longPressTimer.value = window.setTimeout(() => handleOpen(event), rootContext.pressOpenDelay.value);
        }
      }
    }
    async function handlePointerEvent(event) {
      if (!disabled.value) {
        await nextTick18();
        if (isTouchOrPen(event) && !event.defaultPrevented) clearLongPress();
      }
    }
    onMounted21(() => {
      if (currentElement.value) rootContext.triggerElement.value = currentElement.value;
    });
    return (_ctx, _cache) => {
      return openBlock121(), createElementBlock8(Fragment6, null, [createVNode22(unref124(MenuAnchor_default), {
        as: "template",
        reference: virtualEl.value
      }, null, 8, ["reference"]), createVNode22(unref124(Primitive), mergeProps60({
        ref: unref124(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-state": unref124(rootContext).open.value ? "open" : "closed",
        "data-disabled": unref124(disabled) ? "" : void 0,
        style: {
          WebkitTouchCallout: "none",
          pointerEvents: "auto"
        }
      }, _ctx.$attrs, {
        onContextmenu: handleContextMenu,
        onPointerdown: handlePointerDown2,
        onPointermove: handlePointerEvent,
        onPointercancel: handlePointerEvent,
        onPointerup: handlePointerEvent
      }), {
        default: withCtx117(() => [renderSlot121(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "data-state",
        "data-disabled"
      ])], 64);
    };
  }
});
var ContextMenuTrigger_default = ContextMenuTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateField/DateFieldRoot.js
import { computed as computed48, createBlock as createBlock117, createVNode as createVNode23, defineComponent as defineComponent130, mergeProps as mergeProps61, nextTick as nextTick19, onMounted as onMounted22, openBlock as openBlock122, ref as ref47, renderSlot as renderSlot122, toRefs as toRefs20, unref as unref125, watch as watch18, withCtx as withCtx118, withKeys as withKeys8 } from "vue";
var [injectDateFieldRootContext, provideDateFieldRootContext] = createContext("DateFieldRoot");
var DateFieldRoot_vue_vue_type_script_setup_true_lang_default = defineComponent130({
  inheritAttrs: false,
  __name: "DateFieldRoot",
  props: {
    defaultValue: {
      type: null,
      required: false,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: false
    },
    placeholder: {
      type: null,
      required: false,
      default: void 0
    },
    modelValue: {
      type: null,
      required: false
    },
    hourCycle: {
      type: null,
      required: false
    },
    step: {
      type: Object,
      required: false
    },
    granularity: {
      type: String,
      required: false
    },
    hideTimeZone: {
      type: Boolean,
      required: false
    },
    maxValue: {
      type: null,
      required: false
    },
    minValue: {
      type: null,
      required: false
    },
    locale: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateUnavailable: {
      type: Function,
      required: false,
      default: void 0
    },
    id: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, isDateUnavailable: propsIsDateUnavailable, granularity, defaultValue, dir: propDir, locale: propLocale } = toRefs20(props2);
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const formatter = useDateFormatter(locale.value, { hourCycle: normalizeHourCycle(props2.hourCycle) });
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const segmentElements = ref47(/* @__PURE__ */ new Set());
    onMounted22(() => {
      getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
    });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: granularity.value,
      defaultValue: modelValue.value,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const step = computed48(() => normalizeDateStep(props2));
    const inferredGranularity = computed48(() => {
      if (props2.granularity) return !hasTime(placeholder.value) ? "day" : props2.granularity;
      return hasTime(placeholder.value) ? "minute" : "day";
    });
    const isInvalid = computed48(() => {
      if (!modelValue.value) return false;
      if (propsIsDateUnavailable.value?.(modelValue.value)) return true;
      if (props2.minValue && isBefore(modelValue.value, props2.minValue)) return true;
      if (props2.maxValue && isBefore(props2.maxValue, modelValue.value)) return true;
      return false;
    });
    const initialSegments = initializeSegmentValues(inferredGranularity.value);
    const segmentValues = ref47(modelValue.value ? { ...syncSegmentValues({
      value: modelValue.value,
      formatter
    }) } : { ...initialSegments });
    const allSegmentContent = computed48(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: placeholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: segmentValues.value,
      locale
    }));
    const segmentContents = computed48(() => allSegmentContent.value.arr);
    const editableSegmentContents = computed48(() => segmentContents.value.filter(({ part }) => part !== "literal"));
    watch18(locale, (value) => {
      if (formatter.getLocale() !== value) {
        formatter.setLocale(value);
        nextTick19(() => {
          segmentElements.value.clear();
          getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
        });
      }
    });
    watch18(modelValue, (_modelValue) => {
      if (!isNullish(_modelValue) && placeholder.value.compare(_modelValue) !== 0) placeholder.value = _modelValue.copy();
    });
    watch18([modelValue, locale], ([_modelValue]) => {
      if (!isNullish(_modelValue)) segmentValues.value = { ...syncSegmentValues({
        value: _modelValue,
        formatter
      }) };
      else if (Object.values(segmentValues.value).every((value) => value !== null) && isNullish(_modelValue)) segmentValues.value = { ...initialSegments };
    });
    const currentFocusedElement = ref47(null);
    const currentSegmentIndex = computed48(() => Array.from(segmentElements.value).findIndex((el) => el.getAttribute("data-reka-date-field-segment") === currentFocusedElement.value?.getAttribute("data-reka-date-field-segment")));
    const nextFocusableSegment = computed48(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (nextCondition) return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign];
      return segmentToFocus;
    });
    const prevFocusableSegment = computed48(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (prevCondition) return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign];
      return segmentToFocus;
    });
    const kbd = useKbd();
    function handleKeydown(e) {
      if (!isSegmentNavigationKey(e.key)) return;
      if (e.key === kbd.ARROW_LEFT) prevFocusableSegment.value?.focus();
      if (e.key === kbd.ARROW_RIGHT) nextFocusableSegment.value?.focus();
    }
    function setFocusedElement(el) {
      currentFocusedElement.value = el;
    }
    provideDateFieldRootContext({
      isDateUnavailable: propsIsDateUnavailable.value,
      locale,
      modelValue,
      placeholder,
      disabled,
      formatter,
      hourCycle: props2.hourCycle,
      step,
      readonly: readonly3,
      segmentValues,
      isInvalid,
      segmentContents: editableSegmentContents,
      elements: segmentElements,
      setFocusedElement,
      focusNext() {
        nextFocusableSegment.value?.focus();
      }
    });
    __expose({ setFocusedElement });
    return (_ctx, _cache) => {
      return openBlock122(), createBlock117(unref125(Primitive), mergeProps61(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        "aria-disabled": unref125(disabled) ? true : void 0,
        "data-disabled": unref125(disabled) ? "" : void 0,
        "data-readonly": unref125(readonly3) ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        dir: unref125(dir),
        onKeydown: withKeys8(handleKeydown, ["left", "right"])
      }), {
        default: withCtx118(() => [renderSlot122(_ctx.$slots, "default", {
          modelValue: unref125(modelValue),
          segments: segmentContents.value,
          isInvalid: isInvalid.value
        }), createVNode23(unref125(VisuallyHidden_default), {
          id: _ctx.id,
          as: "input",
          feature: "focusable",
          tabindex: "-1",
          value: unref125(modelValue) ? unref125(modelValue).toString() : "",
          name: _ctx.name,
          disabled: unref125(disabled),
          required: _ctx.required,
          onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(segmentElements.value)?.[0]?.focus())
        }, null, 8, [
          "id",
          "value",
          "name",
          "disabled",
          "required"
        ])]),
        _: 3
      }, 16, [
        "aria-disabled",
        "data-disabled",
        "data-readonly",
        "data-invalid",
        "dir"
      ]);
    };
  }
});
var DateFieldRoot_default = DateFieldRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateField/DateFieldInput.js
import { computed as computed49, createBlock as createBlock118, defineComponent as defineComponent131, mergeProps as mergeProps62, openBlock as openBlock123, ref as ref48, renderSlot as renderSlot123, toHandlers, unref as unref126, withCtx as withCtx119 } from "vue";
var DateFieldInput_vue_vue_type_script_setup_true_lang_default = defineComponent131({
  __name: "DateFieldInput",
  props: {
    part: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDateFieldRootContext();
    const hasLeftFocus = ref48(true);
    const lastKeyZero = ref48(false);
    const { handleSegmentClick, handleSegmentKeydown, attributes } = useDateField({
      hasLeftFocus,
      lastKeyZero,
      placeholder: rootContext.placeholder,
      hourCycle: rootContext.hourCycle,
      step: rootContext.step,
      segmentValues: rootContext.segmentValues,
      formatter: rootContext.formatter,
      part: props2.part,
      disabled: rootContext.disabled,
      readonly: rootContext.readonly,
      focusNext: rootContext.focusNext,
      modelValue: rootContext.modelValue
    });
    const disabled = computed49(() => rootContext.disabled.value);
    const readonly3 = computed49(() => rootContext.readonly.value);
    const isInvalid = computed49(() => rootContext.isInvalid.value);
    return (_ctx, _cache) => {
      return openBlock123(), createBlock118(unref126(Primitive), mergeProps62({
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, unref126(attributes), {
        contenteditable: disabled.value || readonly3.value ? false : _ctx.part !== "literal",
        "data-reka-date-field-segment": _ctx.part,
        "aria-disabled": disabled.value ? true : void 0,
        "aria-readonly": readonly3.value ? true : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        "aria-invalid": isInvalid.value ? true : void 0
      }, toHandlers(_ctx.part !== "literal" ? {
        mousedown: unref126(handleSegmentClick),
        keydown: unref126(handleSegmentKeydown),
        focusout: () => {
          hasLeftFocus.value = true;
        },
        focusin: (e) => {
          unref126(rootContext).setFocusedElement(e.target);
        }
      } : {})), {
        default: withCtx119(() => [renderSlot123(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "contenteditable",
        "data-reka-date-field-segment",
        "aria-disabled",
        "aria-readonly",
        "data-disabled",
        "data-invalid",
        "aria-invalid"
      ]);
    };
  }
});
var DateFieldInput_default = DateFieldInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverRoot.js
import { createBlock as createBlock119, defineComponent as defineComponent132, openBlock as openBlock124, ref as ref49, renderSlot as renderSlot124, toRefs as toRefs21, unref as unref127, withCtx as withCtx120 } from "vue";
var [injectPopoverRootContext, providePopoverRootContext] = createContext("PopoverRoot");
var PopoverRoot_vue_vue_type_script_setup_true_lang_default = defineComponent132({
  __name: "PopoverRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false,
      default: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { modal } = toRefs21(props2);
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref49();
    const hasCustomAnchor = ref49(false);
    providePopoverRootContext({
      contentId: "",
      triggerId: "",
      modal,
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      triggerElement,
      hasCustomAnchor
    });
    return (_ctx, _cache) => {
      return openBlock124(), createBlock119(unref127(PopperRoot_default), null, {
        default: withCtx120(() => [renderSlot124(_ctx.$slots, "default", {
          open: unref127(open),
          close: () => open.value = false
        })]),
        _: 3
      });
    };
  }
});
var PopoverRoot_default = PopoverRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverAnchor.js
import { createBlock as createBlock120, defineComponent as defineComponent133, guardReactiveProps as guardReactiveProps35, normalizeProps as normalizeProps35, onBeforeMount as onBeforeMount2, onUnmounted as onUnmounted13, openBlock as openBlock125, renderSlot as renderSlot125, unref as unref128, withCtx as withCtx121 } from "vue";
var PopoverAnchor_vue_vue_type_script_setup_true_lang_default = defineComponent133({
  __name: "PopoverAnchor",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    onBeforeMount2(() => {
      rootContext.hasCustomAnchor.value = true;
    });
    onUnmounted13(() => {
      rootContext.hasCustomAnchor.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock125(), createBlock120(unref128(PopperAnchor_default), normalizeProps35(guardReactiveProps35(props2)), {
        default: withCtx121(() => [renderSlot125(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var PopoverAnchor_default = PopoverAnchor_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerAnchor.js
import { createBlock as createBlock121, defineComponent as defineComponent134, guardReactiveProps as guardReactiveProps36, normalizeProps as normalizeProps36, openBlock as openBlock126, renderSlot as renderSlot126, unref as unref129, withCtx as withCtx122 } from "vue";
var DatePickerAnchor_vue_vue_type_script_setup_true_lang_default = defineComponent134({
  __name: "DatePickerAnchor",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock126(), createBlock121(unref129(PopoverAnchor_default), normalizeProps36(guardReactiveProps36(props2)), {
        default: withCtx122(() => [renderSlot126(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerAnchor_default = DatePickerAnchor_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverArrow.js
import { createBlock as createBlock122, defineComponent as defineComponent135, guardReactiveProps as guardReactiveProps37, normalizeProps as normalizeProps37, openBlock as openBlock127, renderSlot as renderSlot127, unref as unref130, withCtx as withCtx123 } from "vue";
var PopoverArrow_vue_vue_type_script_setup_true_lang_default = defineComponent135({
  __name: "PopoverArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock127(), createBlock122(unref130(PopperArrow_default), normalizeProps37(guardReactiveProps37(props2)), {
        default: withCtx123(() => [renderSlot127(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var PopoverArrow_default = PopoverArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerArrow.js
import { createBlock as createBlock123, defineComponent as defineComponent136, guardReactiveProps as guardReactiveProps38, normalizeProps as normalizeProps38, openBlock as openBlock128, renderSlot as renderSlot128, unref as unref131, withCtx as withCtx124 } from "vue";
var DatePickerArrow_vue_vue_type_script_setup_true_lang_default = defineComponent136({
  __name: "DatePickerArrow",
  props: {
    width: {
      type: Number,
      required: false
    },
    height: {
      type: Number,
      required: false
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock128(), createBlock123(unref131(PopoverArrow_default), normalizeProps38(guardReactiveProps38(props2)), {
        default: withCtx124(() => [renderSlot128(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerArrow_default = DatePickerArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerRoot.js
import { computed as computed50, createBlock as createBlock124, defineComponent as defineComponent137, isRef as isRef6, openBlock as openBlock129, ref as ref50, renderSlot as renderSlot129, toRefs as toRefs22, unref as unref132, watch as watch19, withCtx as withCtx125 } from "vue";
var [injectDatePickerRootContext, provideDatePickerRootContext] = createContext("DatePickerRoot");
var DatePickerRoot_vue_vue_type_script_setup_true_lang_default = defineComponent137({
  inheritAttrs: false,
  __name: "DatePickerRoot",
  props: {
    defaultValue: {
      type: null,
      required: false,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: false
    },
    placeholder: {
      type: null,
      required: false,
      default: void 0
    },
    modelValue: {
      type: null,
      required: false
    },
    hourCycle: {
      type: null,
      required: false
    },
    step: {
      type: Object,
      required: false
    },
    granularity: {
      type: String,
      required: false
    },
    hideTimeZone: {
      type: Boolean,
      required: false
    },
    maxValue: {
      type: null,
      required: false
    },
    minValue: {
      type: null,
      required: false
    },
    locale: {
      type: String,
      required: false,
      default: "en"
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateUnavailable: {
      type: Function,
      required: false,
      default: void 0
    },
    id: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    },
    defaultOpen: {
      type: Boolean,
      required: false,
      default: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateDisabled: {
      type: Function,
      required: false,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: false,
      default: false
    },
    weekStartsOn: {
      type: Number,
      required: false,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: false,
      default: "narrow"
    },
    fixedWeeks: {
      type: Boolean,
      required: false,
      default: false
    },
    numberOfMonths: {
      type: Number,
      required: false,
      default: 1
    },
    preventDeselect: {
      type: Boolean,
      required: false,
      default: false
    },
    closeOnSelect: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: [
    "update:modelValue",
    "update:placeholder",
    "update:open"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { locale, disabled, readonly: readonly3, pagedNavigation, weekStartsOn, weekdayFormat, fixedWeeks, numberOfMonths, preventDeselect, isDateDisabled: propsIsDateDisabled, isDateUnavailable: propsIsDateUnavailable, defaultOpen, modal, id, name, required, minValue, maxValue, granularity, hideTimeZone, hourCycle, defaultValue, dir: propDir, step, closeOnSelect } = toRefs22(props2);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const defaultDate = computed50(() => getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: props2.granularity,
      defaultValue: modelValue.value,
      locale: props2.locale
    }));
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.value.copy(),
      passive: props2.placeholder === void 0
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: defaultOpen.value,
      passive: props2.open === void 0
    });
    const dateFieldRef = ref50();
    watch19(modelValue, (value) => {
      if (value && value.compare(placeholder.value) !== 0) placeholder.value = value.copy();
      if (closeOnSelect.value) open.value = false;
    });
    provideDatePickerRootContext({
      isDateUnavailable: propsIsDateUnavailable.value,
      isDateDisabled: propsIsDateDisabled.value,
      locale,
      disabled,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      modelValue,
      placeholder,
      defaultOpen,
      modal,
      open,
      id,
      name,
      required,
      minValue,
      maxValue,
      granularity,
      hideTimeZone,
      hourCycle,
      dateFieldRef,
      dir,
      step,
      onDateChange(date) {
        if (!date || !modelValue.value) modelValue.value = date?.copy() ?? void 0;
        else if (!preventDeselect.value && date && modelValue.value.compare(date) === 0) modelValue.value = void 0;
        else modelValue.value = date.copy();
      },
      onPlaceholderChange(date) {
        placeholder.value = date.copy();
      },
      closeOnSelect
    });
    return (_ctx, _cache) => {
      return openBlock129(), createBlock124(unref132(PopoverRoot_default), {
        open: unref132(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef6(open) ? open.value = $event : null),
        "default-open": unref132(defaultOpen),
        modal: unref132(modal)
      }, {
        default: withCtx125(() => [renderSlot129(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "open",
        "default-open",
        "modal"
      ]);
    };
  }
});
var DatePickerRoot_default = DatePickerRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerCalendar.js
import { createBlock as createBlock125, defineComponent as defineComponent138, mergeProps as mergeProps63, openBlock as openBlock130, renderSlot as renderSlot130, unref as unref133, withCtx as withCtx126 } from "vue";
var DatePickerCalendar_vue_vue_type_script_setup_true_lang_default = defineComponent138({
  __name: "DatePickerCalendar",
  setup(__props) {
    const rootContext = injectDatePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock130(), createBlock125(unref133(CalendarRoot_default), mergeProps63({
        isDateDisabled: unref133(rootContext).isDateDisabled,
        isDateUnavailable: unref133(rootContext).isDateUnavailable,
        minValue: unref133(rootContext).minValue.value,
        maxValue: unref133(rootContext).maxValue.value,
        locale: unref133(rootContext).locale.value,
        disabled: unref133(rootContext).disabled.value,
        pagedNavigation: unref133(rootContext).pagedNavigation.value,
        weekStartsOn: unref133(rootContext).weekStartsOn.value,
        weekdayFormat: unref133(rootContext).weekdayFormat.value,
        fixedWeeks: unref133(rootContext).fixedWeeks.value,
        numberOfMonths: unref133(rootContext).numberOfMonths.value,
        readonly: unref133(rootContext).readonly.value,
        preventDeselect: unref133(rootContext).preventDeselect.value,
        dir: unref133(rootContext).dir.value
      }, {
        "model-value": unref133(rootContext).modelValue.value,
        placeholder: unref133(rootContext).placeholder.value,
        multiple: false,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (date) => {
          if (date && unref133(rootContext).modelValue.value && unref133($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref133(rootContext).modelValue.value)) return;
          unref133(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[1] || (_cache[1] = (date) => {
          if (unref133($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref133(rootContext).placeholder.value)) return;
          unref133(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx126(({ weekDays, grid, date, weekStartsOn, locale, fixedWeeks }) => [renderSlot130(_ctx.$slots, "default", {
          date,
          grid,
          weekDays,
          weekStartsOn,
          locale,
          fixedWeeks
        })]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});
var DatePickerCalendar_default = DatePickerCalendar_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerCell.js
import { createBlock as createBlock126, defineComponent as defineComponent139, guardReactiveProps as guardReactiveProps39, normalizeProps as normalizeProps39, openBlock as openBlock131, renderSlot as renderSlot131, unref as unref134, withCtx as withCtx127 } from "vue";
var DatePickerCell_vue_vue_type_script_setup_true_lang_default = defineComponent139({
  __name: "DatePickerCell",
  props: {
    date: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock131(), createBlock126(unref134(CalendarCell_default), normalizeProps39(guardReactiveProps39(props2)), {
        default: withCtx127(() => [renderSlot131(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerCell_default = DatePickerCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerCellTrigger.js
import { createBlock as createBlock127, defineComponent as defineComponent140, guardReactiveProps as guardReactiveProps40, normalizeProps as normalizeProps40, openBlock as openBlock132, renderSlot as renderSlot132, unref as unref135, withCtx as withCtx128 } from "vue";
var DatePickerCellTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent140({
  __name: "DatePickerCellTrigger",
  props: {
    day: {
      type: null,
      required: true
    },
    month: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock132(), createBlock127(unref135(CalendarCellTrigger_default), normalizeProps40(guardReactiveProps40(props2)), {
        default: withCtx128((slotProps) => [renderSlot132(_ctx.$slots, "default", normalizeProps40(guardReactiveProps40(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerCellTrigger_default = DatePickerCellTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverClose.js
import { createBlock as createBlock128, defineComponent as defineComponent141, openBlock as openBlock133, renderSlot as renderSlot133, unref as unref136, withCtx as withCtx129 } from "vue";
var PopoverClose_vue_vue_type_script_setup_true_lang_default = defineComponent141({
  __name: "PopoverClose",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPopoverRootContext();
    return (_ctx, _cache) => {
      return openBlock133(), createBlock128(unref136(Primitive), {
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": props2.asChild,
        onClick: _cache[0] || (_cache[0] = ($event) => unref136(rootContext).onOpenChange(false))
      }, {
        default: withCtx129(() => [renderSlot133(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "as",
        "as-child"
      ]);
    };
  }
});
var PopoverClose_default = PopoverClose_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerClose.js
import { createBlock as createBlock129, defineComponent as defineComponent142, guardReactiveProps as guardReactiveProps41, normalizeProps as normalizeProps41, openBlock as openBlock134, renderSlot as renderSlot134, unref as unref137, withCtx as withCtx130 } from "vue";
var DatePickerClose_vue_vue_type_script_setup_true_lang_default = defineComponent142({
  __name: "DatePickerClose",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock134(), createBlock129(unref137(PopoverClose_default), normalizeProps41(guardReactiveProps41(props2)), {
        default: withCtx130(() => [renderSlot134(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerClose_default = DatePickerClose_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverContentImpl.js
import { createBlock as createBlock130, createVNode as createVNode24, defineComponent as defineComponent143, mergeProps as mergeProps64, openBlock as openBlock135, renderSlot as renderSlot135, unref as unref138, withCtx as withCtx131 } from "vue";
var PopoverContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent143({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardProps(reactiveOmit(props2, "trapFocus", "disableOutsidePointerEvents"));
    const { forwardRef } = useForwardExpose();
    const rootContext = injectPopoverRootContext();
    useFocusGuards();
    return (_ctx, _cache) => {
      return openBlock135(), createBlock130(unref138(FocusScope_default), {
        "as-child": "",
        loop: "",
        trapped: _ctx.trapFocus,
        onMountAutoFocus: _cache[5] || (_cache[5] = ($event) => emits("openAutoFocus", $event)),
        onUnmountAutoFocus: _cache[6] || (_cache[6] = ($event) => emits("closeAutoFocus", $event))
      }, {
        default: withCtx131(() => [createVNode24(unref138(DismissableLayer_default), {
          "as-child": "",
          "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
          onPointerDownOutside: _cache[0] || (_cache[0] = ($event) => emits("pointerDownOutside", $event)),
          onInteractOutside: _cache[1] || (_cache[1] = ($event) => emits("interactOutside", $event)),
          onEscapeKeyDown: _cache[2] || (_cache[2] = ($event) => emits("escapeKeyDown", $event)),
          onFocusOutside: _cache[3] || (_cache[3] = ($event) => emits("focusOutside", $event)),
          onDismiss: _cache[4] || (_cache[4] = ($event) => unref138(rootContext).onOpenChange(false))
        }, {
          default: withCtx131(() => [createVNode24(unref138(PopperContent_default), mergeProps64(unref138(forwarded), {
            id: unref138(rootContext).contentId,
            ref: unref138(forwardRef),
            "data-state": unref138(rootContext).open.value ? "open" : "closed",
            "aria-labelledby": unref138(rootContext).triggerId,
            style: {
              "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
              "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
              "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
              "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
              "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
            },
            role: "dialog"
          }), {
            default: withCtx131(() => [renderSlot135(_ctx.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "data-state",
            "aria-labelledby"
          ])]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])]),
        _: 3
      }, 8, ["trapped"]);
    };
  }
});
var PopoverContentImpl_default = PopoverContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverContentModal.js
import { createBlock as createBlock131, defineComponent as defineComponent144, mergeProps as mergeProps65, openBlock as openBlock136, ref as ref51, renderSlot as renderSlot136, unref as unref139, withCtx as withCtx132, withModifiers as withModifiers10 } from "vue";
var PopoverContentModal_vue_vue_type_script_setup_true_lang_default = defineComponent144({
  __name: "PopoverContentModal",
  props: {
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const isRightClickOutsideRef = ref51(false);
    useBodyScrollLock(true);
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef, currentElement } = useForwardExpose();
    useHideOthers(currentElement);
    return (_ctx, _cache) => {
      return openBlock136(), createBlock131(PopoverContentImpl_default, mergeProps65(unref139(forwarded), {
        ref: unref139(forwardRef),
        "trap-focus": unref139(rootContext).open.value,
        "disable-outside-pointer-events": "",
        onCloseAutoFocus: _cache[0] || (_cache[0] = withModifiers10((event) => {
          emits("closeAutoFocus", event);
          if (!isRightClickOutsideRef.value) unref139(rootContext).triggerElement.value?.focus();
        }, ["prevent"])),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          emits("pointerDownOutside", event);
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.value = isRightClick;
        }),
        onFocusOutside: _cache[2] || (_cache[2] = withModifiers10(() => {
        }, ["prevent"]))
      }), {
        default: withCtx132(() => [renderSlot136(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["trap-focus"]);
    };
  }
});
var PopoverContentModal_default = PopoverContentModal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverContentNonModal.js
import { createBlock as createBlock132, defineComponent as defineComponent145, mergeProps as mergeProps66, openBlock as openBlock137, ref as ref52, renderSlot as renderSlot137, unref as unref140, withCtx as withCtx133 } from "vue";
var PopoverContentNonModal_vue_vue_type_script_setup_true_lang_default = defineComponent145({
  __name: "PopoverContentNonModal",
  props: {
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const hasInteractedOutsideRef = ref52(false);
    const hasPointerDownOutsideRef = ref52(false);
    const forwarded = useForwardPropsEmits(props2, emits);
    return (_ctx, _cache) => {
      return openBlock137(), createBlock132(PopoverContentImpl_default, mergeProps66(unref140(forwarded), {
        "trap-focus": false,
        "disable-outside-pointer-events": false,
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          emits("closeAutoFocus", event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.value) unref140(rootContext).triggerElement.value?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.value = false;
          hasPointerDownOutsideRef.value = false;
        }),
        onInteractOutside: _cache[1] || (_cache[1] = async (event) => {
          emits("interactOutside", event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.value = true;
            if (event.detail.originalEvent.type === "pointerdown") hasPointerDownOutsideRef.value = true;
          }
          const target = event.target;
          const targetIsTrigger = unref140(rootContext).triggerElement.value?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) event.preventDefault();
        })
      }), {
        default: withCtx133(() => [renderSlot137(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var PopoverContentNonModal_default = PopoverContentNonModal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverContent.js
import { createBlock as createBlock133, createCommentVNode as createCommentVNode16, defineComponent as defineComponent146, mergeProps as mergeProps67, openBlock as openBlock138, renderSlot as renderSlot138, unref as unref141, withCtx as withCtx134 } from "vue";
var PopoverContent_vue_vue_type_script_setup_true_lang_default = defineComponent146({
  __name: "PopoverContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectPopoverRootContext();
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    rootContext.contentId ||= useId2(void 0, "reka-popover-content");
    return (_ctx, _cache) => {
      return openBlock138(), createBlock133(unref141(Presence_default), { present: _ctx.forceMount || unref141(rootContext).open.value }, {
        default: withCtx134(() => [unref141(rootContext).modal.value ? (openBlock138(), createBlock133(PopoverContentModal_default, mergeProps67({ key: 0 }, unref141(forwarded), { ref: unref141(forwardRef) }), {
          default: withCtx134(() => [renderSlot138(_ctx.$slots, "default")]),
          _: 3
        }, 16)) : (openBlock138(), createBlock133(PopoverContentNonModal_default, mergeProps67({ key: 1 }, unref141(forwarded), { ref: unref141(forwardRef) }), {
          default: withCtx134(() => [renderSlot138(_ctx.$slots, "default")]),
          _: 3
        }, 16))]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var PopoverContent_default = PopoverContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverPortal.js
import { createBlock as createBlock134, defineComponent as defineComponent147, guardReactiveProps as guardReactiveProps42, normalizeProps as normalizeProps42, openBlock as openBlock139, renderSlot as renderSlot139, unref as unref142, withCtx as withCtx135 } from "vue";
var PopoverPortal_vue_vue_type_script_setup_true_lang_default = defineComponent147({
  __name: "PopoverPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock139(), createBlock134(unref142(Teleport_default), normalizeProps42(guardReactiveProps42(props2)), {
        default: withCtx135(() => [renderSlot139(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var PopoverPortal_default = PopoverPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerContent.js
import { computed as computed51, createBlock as createBlock135, createVNode as createVNode25, defineComponent as defineComponent148, guardReactiveProps as guardReactiveProps43, mergeProps as mergeProps68, normalizeProps as normalizeProps43, openBlock as openBlock140, renderSlot as renderSlot140, unref as unref143, withCtx as withCtx136 } from "vue";
var DatePickerContent_vue_vue_type_script_setup_true_lang_default = defineComponent148({
  __name: "DatePickerContent",
  props: {
    portal: {
      type: Object,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const propsToForward = computed51(() => ({
      ...props2,
      portal: void 0
    }));
    const forwarded = useForwardPropsEmits(propsToForward, emits);
    return (_ctx, _cache) => {
      return openBlock140(), createBlock135(unref143(PopoverPortal_default), normalizeProps43(guardReactiveProps43(_ctx.portal)), {
        default: withCtx136(() => [createVNode25(unref143(PopoverContent_default), mergeProps68({
          ...unref143(forwarded),
          ..._ctx.$attrs
        }, { onOpenAutoFocus: _cache[0] || (_cache[0] = (event) => {
          emits("openAutoFocus", event);
          if (!event.defaultPrevented && event.target) {
            unref143(handleCalendarInitialFocus)(event.target);
            event.preventDefault();
          }
        }) }), {
          default: withCtx136(() => [renderSlot140(_ctx.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerContent_default = DatePickerContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerField.js
import { createBlock as createBlock136, defineComponent as defineComponent149, mergeProps as mergeProps69, openBlock as openBlock141, renderSlot as renderSlot141, unref as unref144, withCtx as withCtx137 } from "vue";
var DatePickerField_vue_vue_type_script_setup_true_lang_default = defineComponent149({
  __name: "DatePickerField",
  setup(__props) {
    const rootContext = injectDatePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock141(), createBlock136(unref144(DateFieldRoot_default), mergeProps69({
        ref: unref144(rootContext).dateFieldRef,
        "model-value": unref144(rootContext).modelValue.value,
        placeholder: unref144(rootContext).placeholder.value
      }, {
        id: unref144(rootContext).id.value,
        name: unref144(rootContext).name.value,
        disabled: unref144(rootContext).disabled.value,
        minValue: unref144(rootContext).minValue.value,
        maxValue: unref144(rootContext).maxValue.value,
        readonly: unref144(rootContext).readonly.value,
        hourCycle: unref144(rootContext).hourCycle.value,
        granularity: unref144(rootContext).granularity.value,
        hideTimeZone: unref144(rootContext).hideTimeZone.value,
        locale: unref144(rootContext).locale.value,
        isDateUnavailable: unref144(rootContext).isDateUnavailable,
        required: unref144(rootContext).required.value,
        dir: unref144(rootContext).dir.value,
        step: unref144(rootContext).step.value
      }, {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (date) => {
          if (date && unref144(rootContext).modelValue.value && date.compare(unref144(rootContext).modelValue.value) === 0) return;
          unref144(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[1] || (_cache[1] = (date) => {
          if (date.compare(unref144(rootContext).placeholder.value) === 0) return;
          unref144(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx137(({ segments, modelValue }) => [renderSlot141(_ctx.$slots, "default", {
          segments,
          modelValue
        })]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});
var DatePickerField_default = DatePickerField_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerGrid.js
import { createBlock as createBlock137, defineComponent as defineComponent150, guardReactiveProps as guardReactiveProps44, normalizeProps as normalizeProps44, openBlock as openBlock142, renderSlot as renderSlot142, unref as unref145, withCtx as withCtx138 } from "vue";
var DatePickerGrid_vue_vue_type_script_setup_true_lang_default = defineComponent150({
  __name: "DatePickerGrid",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock142(), createBlock137(unref145(CalendarGrid_default), normalizeProps44(guardReactiveProps44(props2)), {
        default: withCtx138(() => [renderSlot142(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerGrid_default = DatePickerGrid_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerGridBody.js
import { createBlock as createBlock138, defineComponent as defineComponent151, guardReactiveProps as guardReactiveProps45, normalizeProps as normalizeProps45, openBlock as openBlock143, renderSlot as renderSlot143, unref as unref146, withCtx as withCtx139 } from "vue";
var DatePickerGridBody_vue_vue_type_script_setup_true_lang_default = defineComponent151({
  __name: "DatePickerGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock143(), createBlock138(unref146(CalendarGridBody_default), normalizeProps45(guardReactiveProps45(props2)), {
        default: withCtx139(() => [renderSlot143(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerGridBody_default = DatePickerGridBody_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerGridHead.js
import { createBlock as createBlock139, defineComponent as defineComponent152, guardReactiveProps as guardReactiveProps46, normalizeProps as normalizeProps46, openBlock as openBlock144, renderSlot as renderSlot144, unref as unref147, withCtx as withCtx140 } from "vue";
var DatePickerGridHead_vue_vue_type_script_setup_true_lang_default = defineComponent152({
  __name: "DatePickerGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock144(), createBlock139(unref147(CalendarGridHead_default), normalizeProps46(guardReactiveProps46(props2)), {
        default: withCtx140(() => [renderSlot144(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerGridHead_default = DatePickerGridHead_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerGridRow.js
import { createBlock as createBlock140, defineComponent as defineComponent153, guardReactiveProps as guardReactiveProps47, normalizeProps as normalizeProps47, openBlock as openBlock145, renderSlot as renderSlot145, unref as unref148, withCtx as withCtx141 } from "vue";
var DatePickerGridRow_vue_vue_type_script_setup_true_lang_default = defineComponent153({
  __name: "DatePickerGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock145(), createBlock140(unref148(CalendarGridRow_default), normalizeProps47(guardReactiveProps47(props2)), {
        default: withCtx141(() => [renderSlot145(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerGridRow_default = DatePickerGridRow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerHeadCell.js
import { createBlock as createBlock141, defineComponent as defineComponent154, guardReactiveProps as guardReactiveProps48, normalizeProps as normalizeProps48, openBlock as openBlock146, renderSlot as renderSlot146, unref as unref149, withCtx as withCtx142 } from "vue";
var DatePickerHeadCell_vue_vue_type_script_setup_true_lang_default = defineComponent154({
  __name: "DatePickerHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock146(), createBlock141(unref149(CalendarHeadCell_default), normalizeProps48(guardReactiveProps48(props2)), {
        default: withCtx142(() => [renderSlot146(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerHeadCell_default = DatePickerHeadCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerHeader.js
import { createBlock as createBlock142, defineComponent as defineComponent155, guardReactiveProps as guardReactiveProps49, normalizeProps as normalizeProps49, openBlock as openBlock147, renderSlot as renderSlot147, unref as unref150, withCtx as withCtx143 } from "vue";
var DatePickerHeader_vue_vue_type_script_setup_true_lang_default = defineComponent155({
  __name: "DatePickerHeader",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock147(), createBlock142(unref150(CalendarHeader_default), normalizeProps49(guardReactiveProps49(props2)), {
        default: withCtx143(() => [renderSlot147(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerHeader_default = DatePickerHeader_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerHeading.js
import { createBlock as createBlock143, createTextVNode as createTextVNode8, defineComponent as defineComponent156, guardReactiveProps as guardReactiveProps50, normalizeProps as normalizeProps50, openBlock as openBlock148, renderSlot as renderSlot148, toDisplayString as toDisplayString5, unref as unref151, withCtx as withCtx144 } from "vue";
var DatePickerHeading_vue_vue_type_script_setup_true_lang_default = defineComponent156({
  __name: "DatePickerHeading",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock148(), createBlock143(unref151(CalendarHeading_default), normalizeProps50(guardReactiveProps50(props2)), {
        default: withCtx144(({ headingValue }) => [renderSlot148(_ctx.$slots, "default", { headingValue }, () => [createTextVNode8(toDisplayString5(headingValue), 1)])]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerHeading_default = DatePickerHeading_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerInput.js
import { createBlock as createBlock144, defineComponent as defineComponent157, guardReactiveProps as guardReactiveProps51, normalizeProps as normalizeProps51, openBlock as openBlock149, renderSlot as renderSlot149, unref as unref152, withCtx as withCtx145 } from "vue";
var DatePickerInput_vue_vue_type_script_setup_true_lang_default = defineComponent157({
  __name: "DatePickerInput",
  props: {
    part: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock149(), createBlock144(unref152(DateFieldInput_default), normalizeProps51(guardReactiveProps51(props2)), {
        default: withCtx145(() => [renderSlot149(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerInput_default = DatePickerInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerNext.js
import { createBlock as createBlock145, defineComponent as defineComponent158, guardReactiveProps as guardReactiveProps52, normalizeProps as normalizeProps52, openBlock as openBlock150, renderSlot as renderSlot150, unref as unref153, withCtx as withCtx146 } from "vue";
var DatePickerNext_vue_vue_type_script_setup_true_lang_default = defineComponent158({
  __name: "DatePickerNext",
  props: {
    nextPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock150(), createBlock145(unref153(CalendarNext_default), normalizeProps52(guardReactiveProps52(props2)), {
        default: withCtx146((slotProps) => [renderSlot150(_ctx.$slots, "default", normalizeProps52(guardReactiveProps52(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerNext_default = DatePickerNext_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerPrev.js
import { createBlock as createBlock146, defineComponent as defineComponent159, guardReactiveProps as guardReactiveProps53, normalizeProps as normalizeProps53, openBlock as openBlock151, renderSlot as renderSlot151, unref as unref154, withCtx as withCtx147 } from "vue";
var DatePickerPrev_vue_vue_type_script_setup_true_lang_default = defineComponent159({
  __name: "DatePickerPrev",
  props: {
    prevPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock151(), createBlock146(unref154(CalendarPrev_default), normalizeProps53(guardReactiveProps53(props2)), {
        default: withCtx147((slotProps) => [renderSlot151(_ctx.$slots, "default", normalizeProps53(guardReactiveProps53(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var DatePickerPrev_default = DatePickerPrev_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Popover/PopoverTrigger.js
import { createBlock as createBlock147, createVNode as createVNode26, defineComponent as defineComponent160, onMounted as onMounted23, openBlock as openBlock152, renderSlot as renderSlot152, resolveDynamicComponent as resolveDynamicComponent5, unref as unref155, withCtx as withCtx148 } from "vue";
var PopoverTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent160({
  __name: "PopoverTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectPopoverRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    rootContext.triggerId ||= useId2(void 0, "reka-popover-trigger");
    onMounted23(() => {
      rootContext.triggerElement.value = triggerElement.value;
    });
    return (_ctx, _cache) => {
      return openBlock152(), createBlock147(resolveDynamicComponent5(unref155(rootContext).hasCustomAnchor.value ? unref155(Primitive) : unref155(PopperAnchor_default)), { "as-child": "" }, {
        default: withCtx148(() => [createVNode26(unref155(Primitive), {
          id: unref155(rootContext).triggerId,
          ref: unref155(forwardRef),
          type: _ctx.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": unref155(rootContext).open.value,
          "aria-controls": unref155(rootContext).contentId,
          "data-state": unref155(rootContext).open.value ? "open" : "closed",
          as: _ctx.as,
          "as-child": props2.asChild,
          onClick: unref155(rootContext).onOpenToggle
        }, {
          default: withCtx148(() => [renderSlot152(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "id",
          "type",
          "aria-expanded",
          "aria-controls",
          "data-state",
          "as",
          "as-child",
          "onClick"
        ])]),
        _: 3
      });
    };
  }
});
var PopoverTrigger_default = PopoverTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DatePicker/DatePickerTrigger.js
import { createBlock as createBlock148, defineComponent as defineComponent161, mergeProps as mergeProps70, openBlock as openBlock153, renderSlot as renderSlot153, unref as unref156, withCtx as withCtx149 } from "vue";
var DatePickerTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent161({
  __name: "DatePickerTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDatePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock153(), createBlock148(unref156(PopoverTrigger_default), mergeProps70({ "data-reka-date-field-segment": "trigger" }, props2, {
        disabled: unref156(rootContext).disabled.value,
        onFocusin: _cache[0] || (_cache[0] = (e) => {
          unref156(rootContext).dateFieldRef.value?.setFocusedElement(e.target);
        })
      }), {
        default: withCtx149(() => [renderSlot153(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["disabled"]);
    };
  }
});
var DatePickerTrigger_default = DatePickerTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangeField/DateRangeFieldRoot.js
import { computed as computed52, createBlock as createBlock149, createVNode as createVNode27, defineComponent as defineComponent162, mergeProps as mergeProps71, nextTick as nextTick20, onMounted as onMounted24, openBlock as openBlock154, ref as ref53, renderSlot as renderSlot154, toRefs as toRefs23, unref as unref157, watch as watch20, withCtx as withCtx150, withKeys as withKeys9 } from "vue";
var [injectDateRangeFieldRootContext, provideDateRangeFieldRootContext] = createContext("DateRangeFieldRoot");
var DateRangeFieldRoot_vue_vue_type_script_setup_true_lang_default = defineComponent162({
  inheritAttrs: false,
  __name: "DateRangeFieldRoot",
  props: {
    defaultValue: {
      type: Object,
      required: false,
      default: void 0
    },
    defaultPlaceholder: {
      type: null,
      required: false
    },
    placeholder: {
      type: null,
      required: false,
      default: void 0
    },
    modelValue: {
      type: [Object, null],
      required: false
    },
    hourCycle: {
      type: null,
      required: false
    },
    step: {
      type: Object,
      required: false
    },
    granularity: {
      type: String,
      required: false
    },
    hideTimeZone: {
      type: Boolean,
      required: false
    },
    maxValue: {
      type: null,
      required: false
    },
    minValue: {
      type: null,
      required: false
    },
    locale: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateUnavailable: {
      type: Function,
      required: false,
      default: void 0
    },
    id: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, isDateUnavailable: propsIsDateUnavailable, dir: propDir, locale: propLocale } = toRefs23(props2);
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const formatter = useDateFormatter(locale.value, { hourCycle: normalizeHourCycle(props2.hourCycle) });
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const segmentElements = ref53(/* @__PURE__ */ new Set());
    onMounted24(() => {
      getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
    });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: props2.granularity,
      defaultValue: modelValue.value?.start,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const step = computed52(() => normalizeDateStep(props2));
    const inferredGranularity = computed52(() => {
      if (props2.granularity) return !hasTime(placeholder.value) ? "day" : props2.granularity;
      return hasTime(placeholder.value) ? "minute" : "day";
    });
    const isStartInvalid = computed52(() => {
      if (!modelValue.value?.start) return false;
      if (propsIsDateUnavailable.value?.(modelValue.value.start)) return true;
      if (props2.minValue && isBefore(modelValue.value.start, props2.minValue)) return true;
      if (props2.maxValue && isBefore(props2.maxValue, modelValue.value.start)) return true;
      return false;
    });
    const isEndInvalid = computed52(() => {
      if (!modelValue.value?.end) return false;
      if (propsIsDateUnavailable.value?.(modelValue.value.end)) return true;
      if (props2.minValue && isBefore(modelValue.value.end, props2.minValue)) return true;
      if (props2.maxValue && isBefore(props2.maxValue, modelValue.value.end)) return true;
      return false;
    });
    const isInvalid = computed52(() => {
      if (isStartInvalid.value || isEndInvalid.value) return true;
      if (!modelValue.value?.start || !modelValue.value?.end) return false;
      if (!isBeforeOrSame(modelValue.value.start, modelValue.value.end)) return true;
      if (propsIsDateUnavailable.value !== void 0) {
        const allValid = areAllDaysBetweenValid(modelValue.value.start, modelValue.value.end, propsIsDateUnavailable.value, void 0);
        if (!allValid) return true;
      }
      return false;
    });
    const initialSegments = initializeSegmentValues(inferredGranularity.value);
    const startSegmentValues = ref53(modelValue.value?.start ? { ...syncSegmentValues({
      value: modelValue.value.start,
      formatter
    }) } : { ...initialSegments });
    const endSegmentValues = ref53(modelValue.value?.end ? { ...syncSegmentValues({
      value: modelValue.value.end,
      formatter
    }) } : { ...initialSegments });
    const startSegmentContent = computed52(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: placeholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: startSegmentValues.value,
      locale
    }));
    const endSegmentContent = computed52(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: placeholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: endSegmentValues.value,
      locale
    }));
    const segmentContents = computed52(() => ({
      start: startSegmentContent.value.arr,
      end: endSegmentContent.value.arr
    }));
    const editableSegmentContents = computed52(() => ({
      start: segmentContents.value.start.filter(({ part }) => part !== "literal"),
      end: segmentContents.value.end.filter(({ part }) => part !== "literal")
    }));
    const startValue = ref53(modelValue.value?.start?.copy());
    const endValue = ref53(modelValue.value?.end?.copy());
    watch20([startValue, endValue], ([_startValue, _endValue]) => {
      modelValue.value = {
        start: _startValue?.copy(),
        end: _endValue?.copy()
      };
    });
    watch20(modelValue, (_modelValue) => {
      const isStartChanged = _modelValue?.start && startValue.value ? _modelValue.start.compare(startValue.value) !== 0 : _modelValue?.start !== startValue.value;
      if (isStartChanged) startValue.value = _modelValue?.start?.copy();
      const isEndChanged = _modelValue?.end && endValue.value ? _modelValue.end.compare(endValue.value) !== 0 : _modelValue?.end !== endValue.value;
      if (isEndChanged) endValue.value = _modelValue?.end?.copy();
    });
    watch20([startValue, locale], ([_startValue]) => {
      if (_startValue !== void 0) startSegmentValues.value = { ...syncSegmentValues({
        value: _startValue,
        formatter
      }) };
      else if (Object.values(startSegmentValues.value).every((value) => value !== null) && _startValue === void 0) startSegmentValues.value = { ...initialSegments };
    });
    watch20(locale, (value) => {
      if (formatter.getLocale() !== value) {
        formatter.setLocale(value);
        nextTick20(() => {
          segmentElements.value.clear();
          getSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
        });
      }
    });
    watch20(modelValue, (_modelValue) => {
      if (_modelValue && _modelValue.start !== void 0 && placeholder.value.compare(_modelValue.start) !== 0) placeholder.value = _modelValue.start.copy();
    });
    watch20([endValue, locale], ([_endValue]) => {
      if (_endValue !== void 0) endSegmentValues.value = { ...syncSegmentValues({
        value: _endValue,
        formatter
      }) };
      else if (Object.values(endSegmentValues.value).every((value) => value !== null) && _endValue === void 0) endSegmentValues.value = { ...initialSegments };
    });
    const currentFocusedElement = ref53(null);
    const currentSegmentIndex = computed52(() => Array.from(segmentElements.value).findIndex((el) => el.getAttribute("data-reka-date-field-segment") === currentFocusedElement.value?.getAttribute("data-reka-date-field-segment") && el.getAttribute("data-reka-date-range-field-segment-type") === currentFocusedElement.value?.getAttribute("data-reka-date-range-field-segment-type")));
    const nextFocusableSegment = computed52(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (nextCondition) return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign];
      return segmentToFocus;
    });
    const prevFocusableSegment = computed52(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (prevCondition) return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign];
      return segmentToFocus;
    });
    const kbd = useKbd();
    function handleKeydown(e) {
      if (!isSegmentNavigationKey(e.key)) return;
      if (e.key === kbd.ARROW_LEFT) prevFocusableSegment.value?.focus();
      if (e.key === kbd.ARROW_RIGHT) nextFocusableSegment.value?.focus();
    }
    function setFocusedElement(el) {
      currentFocusedElement.value = el;
    }
    provideDateRangeFieldRootContext({
      isDateUnavailable: propsIsDateUnavailable.value,
      locale,
      startValue,
      endValue,
      placeholder,
      disabled,
      formatter,
      hourCycle: props2.hourCycle,
      step,
      readonly: readonly3,
      segmentValues: {
        start: startSegmentValues,
        end: endSegmentValues
      },
      isInvalid,
      segmentContents: editableSegmentContents,
      elements: segmentElements,
      setFocusedElement,
      focusNext() {
        nextFocusableSegment.value?.focus();
      }
    });
    __expose({ setFocusedElement });
    return (_ctx, _cache) => {
      return openBlock154(), createBlock149(unref157(Primitive), mergeProps71(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        "aria-disabled": unref157(disabled) ? true : void 0,
        "data-disabled": unref157(disabled) ? "" : void 0,
        "data-readonly": unref157(readonly3) ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        dir: unref157(dir),
        onKeydown: withKeys9(handleKeydown, ["left", "right"])
      }), {
        default: withCtx150(() => [renderSlot154(_ctx.$slots, "default", {
          modelValue: unref157(modelValue),
          segments: segmentContents.value
        }), createVNode27(unref157(VisuallyHidden_default), {
          id: _ctx.id,
          as: "input",
          feature: "focusable",
          tabindex: "-1",
          value: `${unref157(modelValue)?.start?.toString()} - ${unref157(modelValue)?.end?.toString()}`,
          name: _ctx.name,
          disabled: unref157(disabled),
          required: _ctx.required,
          onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(segmentElements.value)?.[0]?.focus())
        }, null, 8, [
          "id",
          "value",
          "name",
          "disabled",
          "required"
        ])]),
        _: 3
      }, 16, [
        "aria-disabled",
        "data-disabled",
        "data-readonly",
        "data-invalid",
        "dir"
      ]);
    };
  }
});
var DateRangeFieldRoot_default = DateRangeFieldRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangeField/DateRangeFieldInput.js
import { computed as computed53, createBlock as createBlock150, defineComponent as defineComponent163, mergeProps as mergeProps72, openBlock as openBlock155, ref as ref54, renderSlot as renderSlot155, toHandlers as toHandlers2, unref as unref158, withCtx as withCtx151 } from "vue";
var DateRangeFieldInput_vue_vue_type_script_setup_true_lang_default = defineComponent163({
  __name: "DateRangeFieldInput",
  props: {
    part: {
      type: null,
      required: true
    },
    type: {
      type: String,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDateRangeFieldRootContext();
    const hasLeftFocus = ref54(true);
    const lastKeyZero = ref54(false);
    const { handleSegmentClick, handleSegmentKeydown, attributes } = useDateField({
      hasLeftFocus,
      lastKeyZero,
      placeholder: rootContext.placeholder,
      hourCycle: rootContext.hourCycle,
      step: rootContext.step,
      segmentValues: rootContext.segmentValues[props2.type],
      formatter: rootContext.formatter,
      part: props2.part,
      disabled: rootContext.disabled,
      readonly: rootContext.readonly,
      focusNext: rootContext.focusNext,
      modelValue: props2.type === "start" ? rootContext.startValue : rootContext.endValue
    });
    const disabled = computed53(() => rootContext.disabled.value);
    const readonly3 = computed53(() => rootContext.readonly.value);
    const isInvalid = computed53(() => rootContext.isInvalid.value);
    return (_ctx, _cache) => {
      return openBlock155(), createBlock150(unref158(Primitive), mergeProps72({
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, unref158(attributes), {
        contenteditable: disabled.value || readonly3.value ? false : _ctx.part !== "literal",
        "data-reka-date-field-segment": _ctx.part,
        "aria-disabled": disabled.value ? true : void 0,
        "aria-readonly": readonly3.value ? true : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "data-reka-date-range-field-segment-type": _ctx.type,
        "data-invalid": isInvalid.value ? "" : void 0,
        "aria-invalid": isInvalid.value ? true : void 0
      }, toHandlers2(_ctx.part !== "literal" ? {
        mousedown: unref158(handleSegmentClick),
        keydown: unref158(handleSegmentKeydown),
        focusout: () => {
          hasLeftFocus.value = true;
        },
        focusin: (e) => {
          unref158(rootContext).setFocusedElement(e.target);
        }
      } : {})), {
        default: withCtx151(() => [renderSlot155(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "contenteditable",
        "data-reka-date-field-segment",
        "aria-disabled",
        "aria-readonly",
        "data-disabled",
        "data-reka-date-range-field-segment-type",
        "data-invalid",
        "aria-invalid"
      ]);
    };
  }
});
var DateRangeFieldInput_default = DateRangeFieldInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerAnchor.js
import { createBlock as createBlock151, defineComponent as defineComponent164, guardReactiveProps as guardReactiveProps54, normalizeProps as normalizeProps54, openBlock as openBlock156, renderSlot as renderSlot156, unref as unref159, withCtx as withCtx152 } from "vue";
var DateRangePickerAnchor_vue_vue_type_script_setup_true_lang_default = defineComponent164({
  __name: "DateRangePickerAnchor",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock156(), createBlock151(unref159(PopoverAnchor_default), normalizeProps54(guardReactiveProps54(props2)), {
        default: withCtx152(() => [renderSlot156(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerAnchor_default = DateRangePickerAnchor_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerArrow.js
import { createBlock as createBlock152, defineComponent as defineComponent165, guardReactiveProps as guardReactiveProps55, normalizeProps as normalizeProps55, openBlock as openBlock157, renderSlot as renderSlot157, unref as unref160, withCtx as withCtx153 } from "vue";
var DateRangePickerArrow_vue_vue_type_script_setup_true_lang_default = defineComponent165({
  __name: "DateRangePickerArrow",
  props: {
    width: {
      type: Number,
      required: false
    },
    height: {
      type: Number,
      required: false
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock157(), createBlock152(unref160(PopoverArrow_default), normalizeProps55(guardReactiveProps55(props2)), {
        default: withCtx153(() => [renderSlot157(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerArrow_default = DateRangePickerArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerRoot.js
import { createBlock as createBlock153, defineComponent as defineComponent166, isRef as isRef7, openBlock as openBlock158, ref as ref55, renderSlot as renderSlot158, toRefs as toRefs24, unref as unref161, watch as watch21, withCtx as withCtx154 } from "vue";
var [injectDateRangePickerRootContext, provideDateRangePickerRootContext] = createContext("DateRangePickerRoot");
var DateRangePickerRoot_vue_vue_type_script_setup_true_lang_default = defineComponent166({
  inheritAttrs: false,
  __name: "DateRangePickerRoot",
  props: {
    defaultValue: {
      type: Object,
      required: false,
      default: () => ({
        start: void 0,
        end: void 0
      })
    },
    defaultPlaceholder: {
      type: null,
      required: false
    },
    placeholder: {
      type: null,
      required: false,
      default: void 0
    },
    modelValue: {
      type: [Object, null],
      required: false
    },
    hourCycle: {
      type: null,
      required: false
    },
    step: {
      type: Object,
      required: false
    },
    granularity: {
      type: String,
      required: false
    },
    hideTimeZone: {
      type: Boolean,
      required: false
    },
    maxValue: {
      type: null,
      required: false
    },
    minValue: {
      type: null,
      required: false
    },
    locale: {
      type: String,
      required: false,
      default: "en"
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateUnavailable: {
      type: Function,
      required: false,
      default: void 0
    },
    id: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    },
    defaultOpen: {
      type: Boolean,
      required: false,
      default: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    modal: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateDisabled: {
      type: Function,
      required: false,
      default: void 0
    },
    pagedNavigation: {
      type: Boolean,
      required: false,
      default: false
    },
    weekStartsOn: {
      type: Number,
      required: false,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: false,
      default: "narrow"
    },
    fixedWeeks: {
      type: Boolean,
      required: false,
      default: false
    },
    numberOfMonths: {
      type: Number,
      required: false,
      default: 1
    },
    preventDeselect: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateHighlightable: {
      type: Function,
      required: false,
      default: void 0
    },
    allowNonContiguousRanges: {
      type: Boolean,
      required: false,
      default: false
    },
    fixedDate: {
      type: String,
      required: false
    },
    maximumDays: {
      type: Number,
      required: false,
      default: void 0
    },
    closeOnSelect: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: [
    "update:modelValue",
    "update:placeholder",
    "update:startValue",
    "update:open"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { locale, disabled, readonly: readonly3, pagedNavigation, weekStartsOn, weekdayFormat, fixedWeeks, numberOfMonths, preventDeselect, isDateDisabled: propsIsDateDisabled, isDateUnavailable: propsIsDateUnavailable, isDateHighlightable: propsIsDateHighlightable, defaultOpen, modal, id, name, required, minValue, maxValue, granularity, hideTimeZone, hourCycle, dir: propsDir, allowNonContiguousRanges, fixedDate, maximumDays, step, closeOnSelect } = toRefs24(props2);
    const dir = useDirection(propsDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: props2.modelValue === void 0
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      granularity: props2.granularity,
      defaultValue: modelValue.value?.start,
      locale: props2.locale
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: defaultOpen.value,
      passive: props2.open === void 0
    });
    const dateFieldRef = ref55();
    watch21(modelValue, (value) => {
      if (value && value.start && value.start.compare(placeholder.value) !== 0) placeholder.value = value.start.copy();
      if (value.start && value.end) {
        if (closeOnSelect.value) open.value = false;
      }
    });
    provideDateRangePickerRootContext({
      allowNonContiguousRanges,
      isDateUnavailable: propsIsDateUnavailable.value,
      isDateDisabled: propsIsDateDisabled.value,
      isDateHighlightable: propsIsDateHighlightable.value,
      locale,
      disabled,
      pagedNavigation,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      modelValue,
      placeholder,
      defaultOpen,
      modal,
      open,
      id,
      name,
      required,
      minValue,
      maxValue,
      granularity,
      hideTimeZone,
      hourCycle,
      dateFieldRef,
      dir,
      fixedDate,
      maximumDays,
      step,
      onStartValueChange(date) {
        emits("update:startValue", date);
      },
      onDateChange(date) {
        modelValue.value = {
          start: date.start?.copy(),
          end: date.end?.copy()
        };
      },
      onPlaceholderChange(date) {
        placeholder.value = date.copy();
      },
      closeOnSelect
    });
    return (_ctx, _cache) => {
      return openBlock158(), createBlock153(unref161(PopoverRoot_default), {
        open: unref161(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef7(open) ? open.value = $event : null),
        "default-open": unref161(defaultOpen),
        modal: unref161(modal)
      }, {
        default: withCtx154(() => [renderSlot158(_ctx.$slots, "default", {
          modelValue: unref161(modelValue),
          open: unref161(open)
        })]),
        _: 3
      }, 8, [
        "open",
        "default-open",
        "modal"
      ]);
    };
  }
});
var DateRangePickerRoot_default = DateRangePickerRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/useRangeCalendar.js
import { computed as computed54 } from "vue";
function useRangeCalendarState(props2) {
  const isStartInvalid = computed54(() => {
    if (!props2.start.value) return false;
    if (props2.isDateDisabled(props2.start.value)) return true;
    return false;
  });
  const isEndInvalid = computed54(() => {
    if (!props2.end.value) return false;
    if (props2.isDateDisabled(props2.end.value)) return true;
    return false;
  });
  const isInvalid = computed54(() => {
    if (isStartInvalid.value || isEndInvalid.value) return false;
    if (props2.start.value && props2.end.value && isBefore(props2.end.value, props2.start.value)) return true;
    return false;
  });
  const isSelectionStart = (date) => {
    if (!props2.start.value) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.start.value, date);
  };
  const isSelectionEnd = (date) => {
    if (!props2.end.value) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.end.value, date);
  };
  const isSelected = (date) => {
    if (props2.start.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.start.value, date)) return true;
    if (props2.end.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.end.value, date)) return true;
    if (props2.end.value && props2.start.value) return isBetween(date, props2.start.value, props2.end.value);
    return false;
  };
  const rangeIsDateDisabled = (date) => {
    if (props2.isDateDisabled(date)) return true;
    if (props2.maximumDays?.value) {
      if (props2.start.value && props2.end.value) {
        if (props2.fixedDate.value) {
          const diff = getDaysBetween(props2.start.value, props2.end.value).length;
          if (diff <= props2.maximumDays.value) {
            const daysLeft = props2.maximumDays.value - diff - 1;
            const startLimit = props2.start.value.subtract({ days: daysLeft });
            const endLimit = props2.end.value.add({ days: daysLeft });
            return !isBetween(date, startLimit, endLimit);
          }
        }
        return false;
      }
      if (props2.start.value) {
        const maxDate = props2.start.value.add({ days: props2.maximumDays.value });
        const minDate = props2.start.value.subtract({ days: props2.maximumDays.value });
        return !isBetween(date, minDate, maxDate);
      }
    }
    if (!props2.start.value || props2.end.value || $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.start.value, date)) return false;
    return false;
  };
  const isDateHighlightable = (date) => {
    if (props2.isDateHighlightable?.(date)) return true;
    return false;
  };
  const highlightedRange = computed54(() => {
    if (props2.start.value && props2.end.value && !props2.fixedDate.value) return null;
    if (!props2.start.value || !props2.focusedValue.value) return null;
    const isStartBeforeFocused = isBefore(props2.start.value, props2.focusedValue.value);
    const start = isStartBeforeFocused ? props2.start.value : props2.focusedValue.value;
    const end = isStartBeforeFocused ? props2.focusedValue.value : props2.start.value;
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) return {
      start,
      end
    };
    if (props2.maximumDays?.value && !props2.end.value) {
      const cappedEnd = isStartBeforeFocused ? start.add({ days: props2.maximumDays.value }) : start.subtract({ days: props2.maximumDays.value });
      return {
        start,
        end: cappedEnd
      };
    }
    const isValid = areAllDaysBetweenValid(start, end, props2.allowNonContiguousRanges.value ? () => false : props2.isDateUnavailable, rangeIsDateDisabled, props2.isDateHighlightable);
    if (isValid) return {
      start,
      end
    };
    return null;
  });
  const isHighlightedStart = (date) => {
    if (!highlightedRange.value || !highlightedRange.value.start) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(highlightedRange.value.start, date);
  };
  const isHighlightedEnd = (date) => {
    if (!highlightedRange.value || !highlightedRange.value.end) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(highlightedRange.value.end, date);
  };
  return {
    isInvalid,
    isSelected,
    isDateHighlightable,
    highlightedRange,
    isSelectionStart,
    isSelectionEnd,
    isHighlightedStart,
    isHighlightedEnd,
    isDateDisabled: rangeIsDateDisabled
  };
}

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarRoot.js
import { createBlock as createBlock154, createElementVNode as createElementVNode2, defineComponent as defineComponent167, onMounted as onMounted25, openBlock as openBlock159, ref as ref56, renderSlot as renderSlot159, toDisplayString as toDisplayString6, toRefs as toRefs25, unref as unref162, watch as watch22, withCtx as withCtx155 } from "vue";
var _hoisted_13 = { style: {
  "border": "0px",
  "clip": "rect(0px, 0px, 0px, 0px)",
  "clip-path": "inset(50%)",
  "height": "1px",
  "margin": "-1px",
  "overflow": "hidden",
  "padding": "0px",
  "position": "absolute",
  "white-space": "nowrap",
  "width": "1px"
} };
var _hoisted_23 = {
  role: "heading",
  "aria-level": "2"
};
var [injectRangeCalendarRootContext, provideRangeCalendarRootContext] = createContext("RangeCalendarRoot");
var RangeCalendarRoot_vue_vue_type_script_setup_true_lang_default = defineComponent167({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {
      type: null,
      required: false
    },
    defaultValue: {
      type: Object,
      required: false,
      default: () => ({
        start: void 0,
        end: void 0
      })
    },
    modelValue: {
      type: [Object, null],
      required: false
    },
    placeholder: {
      type: null,
      required: false,
      default: void 0
    },
    allowNonContiguousRanges: {
      type: Boolean,
      required: false,
      default: false
    },
    pagedNavigation: {
      type: Boolean,
      required: false,
      default: false
    },
    preventDeselect: {
      type: Boolean,
      required: false,
      default: false
    },
    maximumDays: {
      type: Number,
      required: false,
      default: void 0
    },
    weekStartsOn: {
      type: Number,
      required: false,
      default: 0
    },
    weekdayFormat: {
      type: String,
      required: false,
      default: "narrow"
    },
    calendarLabel: {
      type: String,
      required: false
    },
    fixedWeeks: {
      type: Boolean,
      required: false,
      default: false
    },
    maxValue: {
      type: null,
      required: false
    },
    minValue: {
      type: null,
      required: false
    },
    locale: {
      type: String,
      required: false
    },
    numberOfMonths: {
      type: Number,
      required: false,
      default: 1
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false,
      default: false
    },
    initialFocus: {
      type: Boolean,
      required: false,
      default: false
    },
    isDateDisabled: {
      type: Function,
      required: false,
      default: void 0
    },
    isDateUnavailable: {
      type: Function,
      required: false,
      default: void 0
    },
    isDateHighlightable: {
      type: Function,
      required: false,
      default: void 0
    },
    dir: {
      type: String,
      required: false
    },
    nextPage: {
      type: Function,
      required: false
    },
    prevPage: {
      type: Function,
      required: false
    },
    disableDaysOutsideCurrentView: {
      type: Boolean,
      required: false,
      default: false
    },
    fixedDate: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  emits: [
    "update:modelValue",
    "update:validModelValue",
    "update:placeholder",
    "update:startValue"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, initialFocus, pagedNavigation, weekStartsOn, weekdayFormat, fixedWeeks, numberOfMonths, preventDeselect, isDateUnavailable: propsIsDateUnavailable, isDateHighlightable: propsIsDateHighlightable, isDateDisabled: propsIsDateDisabled, calendarLabel, maxValue, minValue, dir: propDir, locale: propLocale, nextPage: propsNextPage, prevPage: propsPrevPage, allowNonContiguousRanges, disableDaysOutsideCurrentView, fixedDate, maximumDays } = toRefs25(props2);
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const dir = useDirection(propDir);
    const locale = useLocale(propLocale);
    const lastPressedDateValue = ref56();
    const focusedValue = ref56();
    const isEditing = ref56(false);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? {
        start: void 0,
        end: void 0
      },
      passive: props2.modelValue === void 0
    });
    const validModelValue = ref56(modelValue.value);
    watch22(validModelValue, (value) => {
      emits("update:validModelValue", value);
    });
    const defaultDate = getDefaultDate({
      defaultPlaceholder: props2.placeholder,
      defaultValue: modelValue.value.start,
      locale: props2.locale
    });
    const startValue = ref56(modelValue.value.start);
    const endValue = ref56(modelValue.value.end);
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    function onPlaceholderChange(value) {
      placeholder.value = value.copy();
    }
    const { fullCalendarLabel, headingValue, isDateDisabled, isDateUnavailable, isNextButtonDisabled, isPrevButtonDisabled, grid, weekdays, isOutsideVisibleView, nextPage, prevPage, formatter } = useCalendar({
      locale,
      placeholder,
      weekStartsOn,
      fixedWeeks,
      numberOfMonths,
      minValue,
      maxValue,
      disabled,
      weekdayFormat,
      pagedNavigation,
      isDateDisabled: propsIsDateDisabled.value,
      isDateUnavailable: propsIsDateUnavailable.value,
      calendarLabel,
      nextPage: propsNextPage,
      prevPage: propsPrevPage
    });
    const { isInvalid, isSelected, isDateHighlightable, highlightedRange, isSelectionStart, isSelectionEnd, isHighlightedStart, isHighlightedEnd, isDateDisabled: rangeIsDateDisabled } = useRangeCalendarState({
      start: startValue,
      end: endValue,
      isDateDisabled,
      isDateUnavailable,
      isDateHighlightable: propsIsDateHighlightable.value,
      focusedValue,
      allowNonContiguousRanges,
      fixedDate,
      maximumDays
    });
    watch22(modelValue, (_modelValue, _prevValue) => {
      if (!_prevValue?.start && _modelValue?.start || !_modelValue || !_modelValue.start || startValue.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_modelValue.start, startValue.value)) startValue.value = _modelValue?.start?.copy?.();
      if (!_prevValue?.end && _modelValue.end || !_modelValue || !_modelValue.end || endValue.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_modelValue.end, endValue.value)) endValue.value = _modelValue?.end?.copy?.();
    });
    watch22(startValue, (_startValue) => {
      if (_startValue && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(_startValue, placeholder.value)) onPlaceholderChange(_startValue);
      emits("update:startValue", _startValue);
    });
    watch22([startValue, endValue], ([_startValue, _endValue]) => {
      const value = modelValue.value;
      if (value && value.start && value.end && _startValue && _endValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.start, _startValue) && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value.end, _endValue)) return;
      isEditing.value = true;
      if (_endValue && _startValue) {
        if (isBefore(_endValue, _startValue)) modelValue.value = {
          start: _endValue.copy(),
          end: _startValue.copy()
        };
        else modelValue.value = {
          start: _startValue.copy(),
          end: _endValue.copy()
        };
        isEditing.value = false;
        validModelValue.value = {
          start: modelValue.value.start?.copy(),
          end: modelValue.value.end?.copy()
        };
      } else if (_startValue) modelValue.value = {
        start: _startValue.copy(),
        end: void 0
      };
      else modelValue.value = {
        start: _endValue?.copy(),
        end: void 0
      };
    });
    const kbd = useKbd();
    useEventListener("keydown", (ev) => {
      if (ev.key === kbd.ESCAPE && isEditing.value) {
        startValue.value = validModelValue.value.start?.copy();
        endValue.value = validModelValue.value.end?.copy();
      }
    });
    provideRangeCalendarRootContext({
      isDateUnavailable,
      isDateHighlightable,
      startValue,
      endValue,
      formatter,
      modelValue,
      placeholder,
      disabled,
      initialFocus,
      pagedNavigation,
      grid,
      weekDays: weekdays,
      weekStartsOn,
      weekdayFormat,
      fixedWeeks,
      numberOfMonths,
      readonly: readonly3,
      preventDeselect,
      fullCalendarLabel,
      headingValue,
      isInvalid,
      isDateDisabled: rangeIsDateDisabled,
      allowNonContiguousRanges,
      highlightedRange,
      focusedValue,
      lastPressedDateValue,
      isSelected,
      isSelectionEnd,
      isSelectionStart,
      isNextButtonDisabled,
      isPrevButtonDisabled,
      isOutsideVisibleView,
      nextPage,
      prevPage,
      parentElement,
      onPlaceholderChange,
      locale,
      dir,
      isHighlightedStart,
      isHighlightedEnd,
      disableDaysOutsideCurrentView,
      fixedDate,
      maximumDays,
      minValue,
      maxValue
    });
    onMounted25(() => {
      if (initialFocus.value) handleCalendarInitialFocus(parentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock159(), createBlock154(unref162(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "application",
        "aria-label": unref162(fullCalendarLabel),
        "data-readonly": unref162(readonly3) ? "" : void 0,
        "data-disabled": unref162(disabled) ? "" : void 0,
        "data-invalid": unref162(isInvalid) ? "" : void 0,
        dir: unref162(dir)
      }, {
        default: withCtx155(() => [createElementVNode2("div", _hoisted_13, [createElementVNode2("div", _hoisted_23, toDisplayString6(unref162(fullCalendarLabel)), 1)]), renderSlot159(_ctx.$slots, "default", {
          date: unref162(placeholder),
          grid: unref162(grid),
          weekDays: unref162(weekdays),
          weekStartsOn: unref162(weekStartsOn),
          locale: unref162(locale),
          fixedWeeks: unref162(fixedWeeks),
          modelValue: unref162(modelValue)
        })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-label",
        "data-readonly",
        "data-disabled",
        "data-invalid",
        "dir"
      ]);
    };
  }
});
var RangeCalendarRoot_default = RangeCalendarRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCalendar.js
import { createBlock as createBlock155, defineComponent as defineComponent168, mergeProps as mergeProps73, openBlock as openBlock160, renderSlot as renderSlot160, unref as unref163, withCtx as withCtx156 } from "vue";
var DateRangePickerCalendar_vue_vue_type_script_setup_true_lang_default = defineComponent168({
  __name: "DateRangePickerCalendar",
  setup(__props) {
    const rootContext = injectDateRangePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock160(), createBlock155(unref163(RangeCalendarRoot_default), mergeProps73({
        allowNonContiguousRanges: unref163(rootContext).allowNonContiguousRanges.value,
        isDateDisabled: unref163(rootContext).isDateDisabled,
        isDateUnavailable: unref163(rootContext).isDateUnavailable,
        isDateHighlightable: unref163(rootContext).isDateHighlightable,
        locale: unref163(rootContext).locale.value,
        disabled: unref163(rootContext).disabled.value,
        pagedNavigation: unref163(rootContext).pagedNavigation.value,
        weekStartsOn: unref163(rootContext).weekStartsOn.value,
        weekdayFormat: unref163(rootContext).weekdayFormat.value,
        fixedWeeks: unref163(rootContext).fixedWeeks.value,
        numberOfMonths: unref163(rootContext).numberOfMonths.value,
        readonly: unref163(rootContext).readonly.value,
        preventDeselect: unref163(rootContext).preventDeselect.value,
        minValue: unref163(rootContext).minValue.value,
        maxValue: unref163(rootContext).maxValue.value,
        dir: unref163(rootContext).dir.value,
        fixedDate: unref163(rootContext).fixedDate.value,
        maximumDays: unref163(rootContext).maximumDays?.value
      }, {
        "model-value": unref163(rootContext).modelValue.value,
        placeholder: unref163(rootContext).placeholder.value,
        "onUpdate:startValue": _cache[0] || (_cache[0] = (date) => {
          unref163(rootContext).onStartValueChange(date);
        }),
        "onUpdate:modelValue": _cache[1] || (_cache[1] = (date) => {
          if (date.start && unref163(rootContext).modelValue.value?.start && date.end && unref163(rootContext).modelValue.value?.end && unref163($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date.start, unref163(rootContext).modelValue.value?.start) && unref163($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date.end, unref163(rootContext).modelValue.value?.end)) return;
          unref163(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[2] || (_cache[2] = (date) => {
          if (unref163($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref163(rootContext).placeholder.value)) return;
          unref163(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx156(({ weekDays, grid, date, weekStartsOn, locale, fixedWeeks }) => [renderSlot160(_ctx.$slots, "default", {
          date,
          grid,
          weekDays,
          weekStartsOn,
          locale,
          fixedWeeks
        })]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});
var DateRangePickerCalendar_default = DateRangePickerCalendar_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarCell.js
import { createBlock as createBlock156, defineComponent as defineComponent169, openBlock as openBlock161, renderSlot as renderSlot161, unref as unref164, withCtx as withCtx157 } from "vue";
var RangeCalendarCell_vue_vue_type_script_setup_true_lang_default = defineComponent169({
  __name: "RangeCalendarCell",
  props: {
    date: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "td"
    }
  },
  setup(__props) {
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock161(), createBlock156(unref164(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "gridcell",
        "aria-selected": unref164(rootContext).isSelected(_ctx.date) ? true : void 0,
        "aria-disabled": unref164(rootContext).isDateDisabled(_ctx.date) || unref164(rootContext).isDateUnavailable?.(_ctx.date) || unref164(rootContext).disableDaysOutsideCurrentView.value,
        "data-disabled": unref164(rootContext).isDateDisabled(_ctx.date) || unref164(rootContext).disableDaysOutsideCurrentView.value ? "" : void 0
      }, {
        default: withCtx157(() => [renderSlot161(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-selected",
        "aria-disabled",
        "data-disabled"
      ]);
    };
  }
});
var RangeCalendarCell_default = RangeCalendarCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCell.js
import { createBlock as createBlock157, defineComponent as defineComponent170, guardReactiveProps as guardReactiveProps56, normalizeProps as normalizeProps56, openBlock as openBlock162, renderSlot as renderSlot162, unref as unref165, withCtx as withCtx158 } from "vue";
var DateRangePickerCell_vue_vue_type_script_setup_true_lang_default = defineComponent170({
  __name: "DateRangePickerCell",
  props: {
    date: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock162(), createBlock157(unref165(RangeCalendarCell_default), normalizeProps56(guardReactiveProps56(props2)), {
        default: withCtx158(() => [renderSlot162(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerCell_default = DateRangePickerCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarCellTrigger.js
import { computed as computed55, createBlock as createBlock158, createTextVNode as createTextVNode9, defineComponent as defineComponent171, nextTick as nextTick21, openBlock as openBlock163, renderSlot as renderSlot163, toDisplayString as toDisplayString7, unref as unref166, withCtx as withCtx159, withKeys as withKeys10 } from "vue";
var RangeCalendarCellTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent171({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {
      type: null,
      required: true
    },
    month: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectRangeCalendarRootContext();
    const kbd = useKbd();
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const labelText = computed55(() => rootContext.formatter.custom(toDate(props2.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    }));
    const isUnavailable = computed55(() => rootContext.isDateUnavailable?.(props2.day) ?? false);
    const isSelectedDate = computed55(() => rootContext.isSelected(props2.day));
    const isSelectionStart = computed55(() => rootContext.isSelectionStart(props2.day));
    const isSelectionEnd = computed55(() => rootContext.isSelectionEnd(props2.day));
    const isHighlightStart = computed55(() => rootContext.isHighlightedStart(props2.day));
    const isHighlightEnd = computed55(() => rootContext.isHighlightedEnd(props2.day));
    const isHighlighted = computed55(() => rootContext.highlightedRange.value ? isBetweenInclusive(props2.day, rootContext.highlightedRange.value.start, rootContext.highlightedRange.value.end) : false);
    const allowNonContiguousRanges = computed55(() => rootContext.allowNonContiguousRanges.value);
    const isDateToday = computed55(() => {
      return $14e0f24ef4ac5c92$export$629b0a497aa65267(props2.day, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    });
    const isOutsideView = computed55(() => {
      return !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(props2.day, props2.month);
    });
    const isOutsideVisibleView = computed55(() => rootContext.isOutsideVisibleView(props2.day));
    const isDisabled = computed55(() => rootContext.isDateDisabled(props2.day) || rootContext.disableDaysOutsideCurrentView.value && isOutsideView.value);
    const dayValue = computed55(() => props2.day.day.toLocaleString(rootContext.locale.value));
    const isFocusedDate = computed55(() => {
      return !rootContext.disabled.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(props2.day, rootContext.placeholder.value);
    });
    function changeDate(e, date) {
      if (rootContext.readonly.value) return;
      if (rootContext.isDateDisabled(date) || rootContext.isDateUnavailable?.(date)) return;
      rootContext.lastPressedDateValue.value = date.copy();
      if (rootContext.startValue.value && rootContext.highlightedRange.value === null) {
        if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date, rootContext.startValue.value) && !rootContext.preventDeselect.value && !rootContext.endValue.value) {
          rootContext.startValue.value = void 0;
          rootContext.onPlaceholderChange(date);
          return;
        } else if (!rootContext.endValue.value) {
          e.preventDefault();
          if (rootContext.lastPressedDateValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(rootContext.lastPressedDateValue.value, date)) rootContext.startValue.value = date.copy();
          return;
        }
      }
      if (rootContext.startValue.value && rootContext.endValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(rootContext.endValue.value, date) && !rootContext.preventDeselect.value) {
        rootContext.startValue.value = void 0;
        rootContext.endValue.value = void 0;
        rootContext.onPlaceholderChange(date);
        return;
      }
      if (!rootContext.startValue.value) rootContext.startValue.value = date.copy();
      else if (!rootContext.endValue.value) rootContext.endValue.value = date.copy();
      else if (rootContext.endValue.value && rootContext.startValue.value) {
        if (!rootContext.fixedDate.value) {
          rootContext.endValue.value = void 0;
          rootContext.startValue.value = date.copy();
        } else if (rootContext.fixedDate.value === "start") if (date.compare(rootContext.startValue.value) < 0) rootContext.startValue.value = date.copy();
        else rootContext.endValue.value = date.copy();
        else if (rootContext.fixedDate.value === "end") if (date.compare(rootContext.endValue.value) > 0) rootContext.endValue.value = date.copy();
        else rootContext.startValue.value = date.copy();
      }
    }
    function handleClick(e) {
      if (isDisabled.value) return;
      changeDate(e, props2.day);
    }
    function handleFocus() {
      if (isDisabled.value || rootContext.isDateUnavailable?.(props2.day)) return;
      rootContext.focusedValue.value = props2.day.copy();
    }
    function handleArrowKey(e) {
      if (isDisabled.value) return;
      e.preventDefault();
      e.stopPropagation();
      const parentElement = rootContext.parentElement.value;
      const indexIncrementation = 7;
      const sign = rootContext.dir.value === "rtl" ? -1 : 1;
      switch (e.code) {
        case kbd.ARROW_RIGHT:
          shiftFocus(currentElement.value, sign);
          break;
        case kbd.ARROW_LEFT:
          shiftFocus(currentElement.value, -sign);
          break;
        case kbd.ARROW_UP:
          shiftFocus(currentElement.value, -indexIncrementation);
          break;
        case kbd.ARROW_DOWN:
          shiftFocus(currentElement.value, indexIncrementation);
          break;
        case kbd.ENTER:
        case kbd.SPACE_CODE:
          changeDate(e, props2.day);
      }
      function shiftFocus(node, add) {
        const allCollectionItems = getSelectableCells(parentElement);
        if (!allCollectionItems.length) return;
        const index = allCollectionItems.indexOf(node);
        const newIndex = index + add;
        if (newIndex >= 0 && newIndex < allCollectionItems.length) {
          const newDate = allCollectionItems[newIndex].getAttribute("data-value");
          const newDateValue = parseStringToDateValue(newDate, rootContext.placeholder.value);
          const minValue = rootContext.minValue.value;
          const maxValue = rootContext.maxValue.value;
          if (minValue && newDateValue.compare(minValue) < 0 || maxValue && newDateValue.compare(maxValue) > 0) return;
          if (allCollectionItems[newIndex].hasAttribute("data-disabled")) shiftFocus(allCollectionItems[newIndex], add);
          rootContext.onPlaceholderChange(newDateValue);
          allCollectionItems[newIndex].focus();
          return;
        }
        if (newIndex < 0) {
          if (rootContext.isPrevButtonDisabled()) return;
          rootContext.prevPage();
          nextTick21(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length) return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(rootContext.placeholder.value);
              const computedIndex$1 = numberOfDays - Math.abs(newIndex);
              if (newCollectionItems[computedIndex$1].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex$1], add);
              const newDate$1 = newCollectionItems[computedIndex$1].getAttribute("data-value");
              rootContext.onPlaceholderChange(parseStringToDateValue(newDate$1, rootContext.placeholder.value));
              newCollectionItems[computedIndex$1].focus();
              return;
            }
            const computedIndex = newCollectionItems.length - Math.abs(newIndex);
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex], add);
            const newDate = newCollectionItems[computedIndex].getAttribute("data-value");
            rootContext.onPlaceholderChange(parseStringToDateValue(newDate, rootContext.placeholder.value));
            newCollectionItems[computedIndex].focus();
          });
          return;
        }
        if (newIndex >= allCollectionItems.length) {
          if (rootContext.isNextButtonDisabled()) return;
          rootContext.nextPage();
          nextTick21(() => {
            const newCollectionItems = getSelectableCells(parentElement);
            if (!newCollectionItems.length) return;
            if (!rootContext.pagedNavigation.value && rootContext.numberOfMonths.value > 1) {
              const numberOfDays = getDaysInMonth(rootContext.placeholder.value.add({ months: rootContext.numberOfMonths.value - 1 }));
              const computedIndex$1 = newIndex - allCollectionItems.length + (newCollectionItems.length - numberOfDays);
              if (newCollectionItems[computedIndex$1].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex$1], add);
              const newDate$1 = newCollectionItems[computedIndex$1].getAttribute("data-value");
              rootContext.onPlaceholderChange(parseStringToDateValue(newDate$1, rootContext.placeholder.value));
              newCollectionItems[computedIndex$1].focus();
              return;
            }
            const computedIndex = newIndex - allCollectionItems.length;
            if (newCollectionItems[computedIndex].hasAttribute("data-disabled")) shiftFocus(newCollectionItems[computedIndex], add);
            const newDate = newCollectionItems[computedIndex].getAttribute("data-value");
            rootContext.onPlaceholderChange(parseStringToDateValue(newDate, rootContext.placeholder.value));
            newCollectionItems[computedIndex].focus();
          });
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock163(), createBlock158(unref166(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "button",
        "aria-label": labelText.value,
        "data-reka-calendar-cell-trigger": "",
        "aria-selected": isSelectedDate.value && (allowNonContiguousRanges.value || !isUnavailable.value) ? true : void 0,
        "aria-disabled": isDisabled.value || isUnavailable.value ? true : void 0,
        "data-highlighted": isHighlighted.value && (allowNonContiguousRanges.value || !isUnavailable.value) ? "" : void 0,
        "data-selection-start": isSelectionStart.value ? true : void 0,
        "data-selection-end": isSelectionEnd.value ? true : void 0,
        "data-highlighted-start": isHighlightStart.value ? true : void 0,
        "data-highlighted-end": isHighlightEnd.value ? true : void 0,
        "data-selected": isSelectedDate.value && (allowNonContiguousRanges.value || !isUnavailable.value) ? true : void 0,
        "data-outside-visible-view": isOutsideVisibleView.value ? "" : void 0,
        "data-value": _ctx.day.toString(),
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-unavailable": isUnavailable.value ? "" : void 0,
        "data-today": isDateToday.value ? "" : void 0,
        "data-outside-view": isOutsideView.value ? "" : void 0,
        "data-focused": isFocusedDate.value ? "" : void 0,
        tabindex: isFocusedDate.value ? 0 : isOutsideView.value || isDisabled.value ? void 0 : -1,
        onClick: handleClick,
        onFocusin: handleFocus,
        onMouseenter: handleFocus,
        onKeydown: withKeys10(handleArrowKey, [
          "up",
          "down",
          "left",
          "right",
          "enter",
          "space"
        ])
      }, {
        default: withCtx159(() => [renderSlot163(_ctx.$slots, "default", {
          dayValue: dayValue.value,
          disabled: isDisabled.value,
          today: isDateToday.value,
          selected: isSelectedDate.value,
          outsideView: isOutsideView.value,
          outsideVisibleView: isOutsideVisibleView.value,
          unavailable: isUnavailable.value,
          highlighted: isHighlighted.value && (allowNonContiguousRanges.value || !isUnavailable.value),
          highlightedStart: isHighlightStart.value,
          highlightedEnd: isHighlightEnd.value,
          selectionStart: isSelectionStart.value,
          selectionEnd: isSelectionEnd.value
        }, () => [createTextVNode9(toDisplayString7(dayValue.value), 1)])]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-label",
        "aria-selected",
        "aria-disabled",
        "data-highlighted",
        "data-selection-start",
        "data-selection-end",
        "data-highlighted-start",
        "data-highlighted-end",
        "data-selected",
        "data-outside-visible-view",
        "data-value",
        "data-disabled",
        "data-unavailable",
        "data-today",
        "data-outside-view",
        "data-focused",
        "tabindex"
      ]);
    };
  }
});
var RangeCalendarCellTrigger_default = RangeCalendarCellTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerCellTrigger.js
import { createBlock as createBlock159, defineComponent as defineComponent172, guardReactiveProps as guardReactiveProps57, normalizeProps as normalizeProps57, openBlock as openBlock164, renderSlot as renderSlot164, unref as unref167, withCtx as withCtx160 } from "vue";
var DateRangePickerCellTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent172({
  __name: "DateRangePickerCellTrigger",
  props: {
    day: {
      type: null,
      required: true
    },
    month: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock164(), createBlock159(unref167(RangeCalendarCellTrigger_default), normalizeProps57(guardReactiveProps57(props2)), {
        default: withCtx160((slotProps) => [renderSlot164(_ctx.$slots, "default", normalizeProps57(guardReactiveProps57(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerCellTrigger_default = DateRangePickerCellTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerClose.js
import { createBlock as createBlock160, defineComponent as defineComponent173, guardReactiveProps as guardReactiveProps58, normalizeProps as normalizeProps58, openBlock as openBlock165, renderSlot as renderSlot165, unref as unref168, withCtx as withCtx161 } from "vue";
var DateRangePickerClose_vue_vue_type_script_setup_true_lang_default = defineComponent173({
  __name: "DateRangePickerClose",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock165(), createBlock160(unref168(PopoverClose_default), normalizeProps58(guardReactiveProps58(props2)), {
        default: withCtx161(() => [renderSlot165(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerClose_default = DateRangePickerClose_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerContent.js
import { computed as computed56, createBlock as createBlock161, createVNode as createVNode28, defineComponent as defineComponent174, guardReactiveProps as guardReactiveProps59, mergeProps as mergeProps74, normalizeProps as normalizeProps59, openBlock as openBlock166, renderSlot as renderSlot166, unref as unref169, withCtx as withCtx162 } from "vue";
var DateRangePickerContent_vue_vue_type_script_setup_true_lang_default = defineComponent174({
  __name: "DateRangePickerContent",
  props: {
    portal: {
      type: Object,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const propsToForward = computed56(() => ({
      ...props2,
      portal: void 0
    }));
    const forwarded = useForwardPropsEmits(propsToForward, emits);
    return (_ctx, _cache) => {
      return openBlock166(), createBlock161(unref169(PopoverPortal_default), normalizeProps59(guardReactiveProps59(_ctx.portal)), {
        default: withCtx162(() => [createVNode28(unref169(PopoverContent_default), mergeProps74({
          ...unref169(forwarded),
          ..._ctx.$attrs
        }, { onOpenAutoFocus: _cache[0] || (_cache[0] = (event) => {
          emits("openAutoFocus", event);
          if (!event.defaultPrevented && event.target) {
            unref169(handleCalendarInitialFocus)(event.target);
            event.preventDefault();
          }
        }) }), {
          default: withCtx162(() => [renderSlot166(_ctx.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerContent_default = DateRangePickerContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerField.js
import { createBlock as createBlock162, defineComponent as defineComponent175, mergeProps as mergeProps75, openBlock as openBlock167, renderSlot as renderSlot167, unref as unref170, withCtx as withCtx163 } from "vue";
var DateRangePickerField_vue_vue_type_script_setup_true_lang_default = defineComponent175({
  __name: "DateRangePickerField",
  setup(__props) {
    const rootContext = injectDateRangePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock167(), createBlock162(unref170(DateRangeFieldRoot_default), mergeProps75({
        ref: unref170(rootContext).dateFieldRef,
        "model-value": unref170(rootContext).modelValue.value,
        placeholder: unref170(rootContext).placeholder.value
      }, {
        id: unref170(rootContext).id.value,
        name: unref170(rootContext).name.value,
        disabled: unref170(rootContext).disabled.value,
        minValue: unref170(rootContext).minValue.value,
        maxValue: unref170(rootContext).maxValue.value,
        readonly: unref170(rootContext).readonly.value,
        hourCycle: unref170(rootContext).hourCycle.value,
        granularity: unref170(rootContext).granularity.value,
        hideTimeZone: unref170(rootContext).hideTimeZone.value,
        locale: unref170(rootContext).locale.value,
        isDateUnavailable: unref170(rootContext).isDateUnavailable,
        required: unref170(rootContext).required.value,
        dir: unref170(rootContext).dir.value,
        step: unref170(rootContext).step.value
      }, {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (date) => {
          if (date.start && unref170(rootContext).modelValue.value.start && date.end && unref170(rootContext).modelValue.value.end && date.start.compare(unref170(rootContext).modelValue.value.start) === 0 && date.end.compare(unref170(rootContext).modelValue.value.end) === 0) return;
          unref170(rootContext).onDateChange(date);
        }),
        "onUpdate:placeholder": _cache[1] || (_cache[1] = (date) => {
          if (unref170($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(date, unref170(rootContext).placeholder.value) && date.compare(unref170(rootContext).placeholder.value) === 0) return;
          unref170(rootContext).onPlaceholderChange(date);
        })
      }), {
        default: withCtx163(({ segments, modelValue }) => [renderSlot167(_ctx.$slots, "default", {
          segments,
          modelValue
        })]),
        _: 3
      }, 16, ["model-value", "placeholder"]);
    };
  }
});
var DateRangePickerField_default = DateRangePickerField_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGrid.js
import { computed as computed57, createBlock as createBlock163, defineComponent as defineComponent176, mergeProps as mergeProps76, openBlock as openBlock168, renderSlot as renderSlot168, unref as unref171, withCtx as withCtx164 } from "vue";
var RangeCalendarGrid_vue_vue_type_script_setup_true_lang_default = defineComponent176({
  __name: "RangeCalendarGrid",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "table"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectRangeCalendarRootContext();
    const disabled = computed57(() => rootContext.disabled.value ? true : void 0);
    const readonly3 = computed57(() => rootContext.readonly.value ? true : void 0);
    return (_ctx, _cache) => {
      return openBlock168(), createBlock163(unref171(Primitive), mergeProps76(props2, {
        tabindex: "-1",
        role: "grid",
        "aria-readonly": readonly3.value,
        "aria-disabled": disabled.value,
        "data-readonly": readonly3.value && "",
        "data-disabled": disabled.value && ""
      }), {
        default: withCtx164(() => [renderSlot168(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-readonly",
        "aria-disabled",
        "data-readonly",
        "data-disabled"
      ]);
    };
  }
});
var RangeCalendarGrid_default = RangeCalendarGrid_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGrid.js
import { createBlock as createBlock164, defineComponent as defineComponent177, guardReactiveProps as guardReactiveProps60, normalizeProps as normalizeProps60, openBlock as openBlock169, renderSlot as renderSlot169, unref as unref172, withCtx as withCtx165 } from "vue";
var DateRangePickerGrid_vue_vue_type_script_setup_true_lang_default = defineComponent177({
  __name: "DateRangePickerGrid",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock169(), createBlock164(unref172(RangeCalendarGrid_default), normalizeProps60(guardReactiveProps60(props2)), {
        default: withCtx165(() => [renderSlot169(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerGrid_default = DateRangePickerGrid_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGridBody.js
import { createBlock as createBlock165, defineComponent as defineComponent178, guardReactiveProps as guardReactiveProps61, normalizeProps as normalizeProps61, openBlock as openBlock170, renderSlot as renderSlot170, unref as unref173, withCtx as withCtx166 } from "vue";
var RangeCalendarGridBody_vue_vue_type_script_setup_true_lang_default = defineComponent178({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "tbody"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock170(), createBlock165(unref173(Primitive), normalizeProps61(guardReactiveProps61(props2)), {
        default: withCtx166(() => [renderSlot170(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var RangeCalendarGridBody_default = RangeCalendarGridBody_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridBody.js
import { createBlock as createBlock166, defineComponent as defineComponent179, guardReactiveProps as guardReactiveProps62, normalizeProps as normalizeProps62, openBlock as openBlock171, renderSlot as renderSlot171, unref as unref174, withCtx as withCtx167 } from "vue";
var DateRangePickerGridBody_vue_vue_type_script_setup_true_lang_default = defineComponent179({
  __name: "DateRangePickerGridBody",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock171(), createBlock166(unref174(RangeCalendarGridBody_default), normalizeProps62(guardReactiveProps62(props2)), {
        default: withCtx167(() => [renderSlot171(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerGridBody_default = DateRangePickerGridBody_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGridHead.js
import { createBlock as createBlock167, defineComponent as defineComponent180, mergeProps as mergeProps77, openBlock as openBlock172, renderSlot as renderSlot172, unref as unref175, withCtx as withCtx168 } from "vue";
var RangeCalendarGridHead_vue_vue_type_script_setup_true_lang_default = defineComponent180({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "thead"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock172(), createBlock167(unref175(Primitive), mergeProps77(props2, { "aria-hidden": "true" }), {
        default: withCtx168(() => [renderSlot172(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var RangeCalendarGridHead_default = RangeCalendarGridHead_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridHead.js
import { createBlock as createBlock168, defineComponent as defineComponent181, guardReactiveProps as guardReactiveProps63, normalizeProps as normalizeProps63, openBlock as openBlock173, renderSlot as renderSlot173, unref as unref176, withCtx as withCtx169 } from "vue";
var DateRangePickerGridHead_vue_vue_type_script_setup_true_lang_default = defineComponent181({
  __name: "DateRangePickerGridHead",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock173(), createBlock168(unref176(RangeCalendarGridHead_default), normalizeProps63(guardReactiveProps63(props2)), {
        default: withCtx169(() => [renderSlot173(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerGridHead_default = DateRangePickerGridHead_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarGridRow.js
import { createBlock as createBlock169, defineComponent as defineComponent182, guardReactiveProps as guardReactiveProps64, normalizeProps as normalizeProps64, openBlock as openBlock174, renderSlot as renderSlot174, unref as unref177, withCtx as withCtx170 } from "vue";
var RangeCalendarGridRow_vue_vue_type_script_setup_true_lang_default = defineComponent182({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "tr"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock174(), createBlock169(unref177(Primitive), normalizeProps64(guardReactiveProps64(props2)), {
        default: withCtx170(() => [renderSlot174(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var RangeCalendarGridRow_default = RangeCalendarGridRow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerGridRow.js
import { createBlock as createBlock170, defineComponent as defineComponent183, guardReactiveProps as guardReactiveProps65, normalizeProps as normalizeProps65, openBlock as openBlock175, renderSlot as renderSlot175, unref as unref178, withCtx as withCtx171 } from "vue";
var DateRangePickerGridRow_vue_vue_type_script_setup_true_lang_default = defineComponent183({
  __name: "DateRangePickerGridRow",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock175(), createBlock170(unref178(RangeCalendarGridRow_default), normalizeProps65(guardReactiveProps65(props2)), {
        default: withCtx171(() => [renderSlot175(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerGridRow_default = DateRangePickerGridRow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarHeadCell.js
import { createBlock as createBlock171, defineComponent as defineComponent184, guardReactiveProps as guardReactiveProps66, normalizeProps as normalizeProps66, openBlock as openBlock176, renderSlot as renderSlot176, unref as unref179, withCtx as withCtx172 } from "vue";
var RangeCalendarHeadCell_vue_vue_type_script_setup_true_lang_default = defineComponent184({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "th"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock176(), createBlock171(unref179(Primitive), normalizeProps66(guardReactiveProps66(props2)), {
        default: withCtx172(() => [renderSlot176(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var RangeCalendarHeadCell_default = RangeCalendarHeadCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeadCell.js
import { createBlock as createBlock172, defineComponent as defineComponent185, guardReactiveProps as guardReactiveProps67, normalizeProps as normalizeProps67, openBlock as openBlock177, renderSlot as renderSlot177, unref as unref180, withCtx as withCtx173 } from "vue";
var DateRangePickerHeadCell_vue_vue_type_script_setup_true_lang_default = defineComponent185({
  __name: "DateRangePickerHeadCell",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock177(), createBlock172(unref180(RangeCalendarHeadCell_default), normalizeProps67(guardReactiveProps67(props2)), {
        default: withCtx173(() => [renderSlot177(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerHeadCell_default = DateRangePickerHeadCell_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarHeader.js
import { createBlock as createBlock173, defineComponent as defineComponent186, guardReactiveProps as guardReactiveProps68, normalizeProps as normalizeProps68, openBlock as openBlock178, renderSlot as renderSlot178, unref as unref181, withCtx as withCtx174 } from "vue";
var RangeCalendarHeader_vue_vue_type_script_setup_true_lang_default = defineComponent186({
  __name: "RangeCalendarHeader",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock178(), createBlock173(unref181(Primitive), normalizeProps68(guardReactiveProps68(props2)), {
        default: withCtx174(() => [renderSlot178(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var RangeCalendarHeader_default = RangeCalendarHeader_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeader.js
import { createBlock as createBlock174, defineComponent as defineComponent187, guardReactiveProps as guardReactiveProps69, normalizeProps as normalizeProps69, openBlock as openBlock179, renderSlot as renderSlot179, unref as unref182, withCtx as withCtx175 } from "vue";
var DateRangePickerHeader_vue_vue_type_script_setup_true_lang_default = defineComponent187({
  __name: "DateRangePickerHeader",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock179(), createBlock174(unref182(RangeCalendarHeader_default), normalizeProps69(guardReactiveProps69(props2)), {
        default: withCtx175(() => [renderSlot179(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerHeader_default = DateRangePickerHeader_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarHeading.js
import { createBlock as createBlock175, createTextVNode as createTextVNode10, defineComponent as defineComponent188, mergeProps as mergeProps78, openBlock as openBlock180, renderSlot as renderSlot180, toDisplayString as toDisplayString8, unref as unref183, withCtx as withCtx176 } from "vue";
var RangeCalendarHeading_vue_vue_type_script_setup_true_lang_default = defineComponent188({
  __name: "RangeCalendarHeading",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock180(), createBlock175(unref183(Primitive), mergeProps78(props2, { "data-disabled": unref183(rootContext).disabled.value ? "" : void 0 }), {
        default: withCtx176(() => [renderSlot180(_ctx.$slots, "default", { headingValue: unref183(rootContext).headingValue.value }, () => [createTextVNode10(toDisplayString8(unref183(rootContext).headingValue.value), 1)])]),
        _: 3
      }, 16, ["data-disabled"]);
    };
  }
});
var RangeCalendarHeading_default = RangeCalendarHeading_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerHeading.js
import { createBlock as createBlock176, createTextVNode as createTextVNode11, defineComponent as defineComponent189, guardReactiveProps as guardReactiveProps70, normalizeProps as normalizeProps70, openBlock as openBlock181, renderSlot as renderSlot181, toDisplayString as toDisplayString9, unref as unref184, withCtx as withCtx177 } from "vue";
var DateRangePickerHeading_vue_vue_type_script_setup_true_lang_default = defineComponent189({
  __name: "DateRangePickerHeading",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock181(), createBlock176(unref184(RangeCalendarHeading_default), normalizeProps70(guardReactiveProps70(props2)), {
        default: withCtx177(({ headingValue }) => [renderSlot181(_ctx.$slots, "default", { headingValue }, () => [createTextVNode11(toDisplayString9(headingValue), 1)])]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerHeading_default = DateRangePickerHeading_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerInput.js
import { createBlock as createBlock177, defineComponent as defineComponent190, guardReactiveProps as guardReactiveProps71, normalizeProps as normalizeProps71, openBlock as openBlock182, renderSlot as renderSlot182, unref as unref185, withCtx as withCtx178 } from "vue";
var DateRangePickerInput_vue_vue_type_script_setup_true_lang_default = defineComponent190({
  __name: "DateRangePickerInput",
  props: {
    part: {
      type: null,
      required: true
    },
    type: {
      type: String,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock182(), createBlock177(unref185(DateRangeFieldInput_default), normalizeProps71(guardReactiveProps71(props2)), {
        default: withCtx178(() => [renderSlot182(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerInput_default = DateRangePickerInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarNext.js
import { computed as computed58, createBlock as createBlock178, createTextVNode as createTextVNode12, defineComponent as defineComponent191, openBlock as openBlock183, renderSlot as renderSlot183, unref as unref186, withCtx as withCtx179 } from "vue";
var RangeCalendarNext_vue_vue_type_script_setup_true_lang_default = defineComponent191({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed58(() => rootContext.disabled.value || rootContext.isNextButtonDisabled(props2.nextPage));
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock183(), createBlock178(unref186(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-label": "Next page",
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref186(rootContext).nextPage(props2.nextPage))
      }, {
        default: withCtx179(() => [renderSlot183(_ctx.$slots, "default", { disabled: disabled.value }, () => [_cache[1] || (_cache[1] = createTextVNode12(" Next page "))])]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "type",
        "aria-disabled",
        "data-disabled",
        "disabled"
      ]);
    };
  }
});
var RangeCalendarNext_default = RangeCalendarNext_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerNext.js
import { createBlock as createBlock179, defineComponent as defineComponent192, guardReactiveProps as guardReactiveProps72, normalizeProps as normalizeProps72, openBlock as openBlock184, renderSlot as renderSlot184, unref as unref187, withCtx as withCtx180 } from "vue";
var DateRangePickerNext_vue_vue_type_script_setup_true_lang_default = defineComponent192({
  __name: "DateRangePickerNext",
  props: {
    nextPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock184(), createBlock179(unref187(RangeCalendarNext_default), normalizeProps72(guardReactiveProps72(props2)), {
        default: withCtx180((slotProps) => [renderSlot184(_ctx.$slots, "default", normalizeProps72(guardReactiveProps72(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerNext_default = DateRangePickerNext_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RangeCalendar/RangeCalendarPrev.js
import { computed as computed59, createBlock as createBlock180, createTextVNode as createTextVNode13, defineComponent as defineComponent193, openBlock as openBlock185, renderSlot as renderSlot185, unref as unref188, withCtx as withCtx181 } from "vue";
var RangeCalendarPrev_vue_vue_type_script_setup_true_lang_default = defineComponent193({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const disabled = computed59(() => rootContext.disabled.value || rootContext.isPrevButtonDisabled(props2.prevPage));
    const rootContext = injectRangeCalendarRootContext();
    return (_ctx, _cache) => {
      return openBlock185(), createBlock180(unref188(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-label": "Previous page",
        type: _ctx.as === "button" ? "button" : void 0,
        "aria-disabled": disabled.value || void 0,
        "data-disabled": disabled.value || void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => unref188(rootContext).prevPage(props2.prevPage))
      }, {
        default: withCtx181(() => [renderSlot185(_ctx.$slots, "default", { disabled: disabled.value }, () => [_cache[1] || (_cache[1] = createTextVNode13(" Prev page "))])]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "type",
        "aria-disabled",
        "data-disabled",
        "disabled"
      ]);
    };
  }
});
var RangeCalendarPrev_default = RangeCalendarPrev_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerPrev.js
import { createBlock as createBlock181, defineComponent as defineComponent194, guardReactiveProps as guardReactiveProps73, normalizeProps as normalizeProps73, openBlock as openBlock186, renderSlot as renderSlot186, unref as unref189, withCtx as withCtx182 } from "vue";
var DateRangePickerPrev_vue_vue_type_script_setup_true_lang_default = defineComponent194({
  __name: "DateRangePickerPrev",
  props: {
    prevPage: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock186(), createBlock181(unref189(RangeCalendarPrev_default), normalizeProps73(guardReactiveProps73(props2)), {
        default: withCtx182((slotProps) => [renderSlot186(_ctx.$slots, "default", normalizeProps73(guardReactiveProps73(slotProps)))]),
        _: 3
      }, 16);
    };
  }
});
var DateRangePickerPrev_default = DateRangePickerPrev_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DateRangePicker/DateRangePickerTrigger.js
import { createBlock as createBlock182, defineComponent as defineComponent195, mergeProps as mergeProps79, openBlock as openBlock187, renderSlot as renderSlot187, unref as unref190, withCtx as withCtx183 } from "vue";
var DateRangePickerTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent195({
  __name: "DateRangePickerTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDateRangePickerRootContext();
    return (_ctx, _cache) => {
      return openBlock187(), createBlock182(unref190(PopoverTrigger_default), mergeProps79({ "data-reka-date-field-segment": "trigger" }, props2, {
        disabled: unref190(rootContext).disabled.value,
        onFocusin: _cache[0] || (_cache[0] = (e) => {
          unref190(rootContext).dateFieldRef.value?.setFocusedElement(e.target);
        })
      }), {
        default: withCtx183(() => [renderSlot187(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["disabled"]);
    };
  }
});
var DateRangePickerTrigger_default = DateRangePickerTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuArrow.js
import { createBlock as createBlock183, defineComponent as defineComponent196, guardReactiveProps as guardReactiveProps74, normalizeProps as normalizeProps74, openBlock as openBlock188, renderSlot as renderSlot188, unref as unref191, withCtx as withCtx184 } from "vue";
var DropdownMenuArrow_vue_vue_type_script_setup_true_lang_default = defineComponent196({
  __name: "DropdownMenuArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock188(), createBlock183(unref191(MenuArrow_default), normalizeProps74(guardReactiveProps74(props2)), {
        default: withCtx184(() => [renderSlot188(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuArrow_default = DropdownMenuArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuCheckboxItem.js
import { createBlock as createBlock184, defineComponent as defineComponent197, guardReactiveProps as guardReactiveProps75, normalizeProps as normalizeProps75, openBlock as openBlock189, renderSlot as renderSlot189, unref as unref192, withCtx as withCtx185 } from "vue";
var DropdownMenuCheckboxItem_vue_vue_type_script_setup_true_lang_default = defineComponent197({
  __name: "DropdownMenuCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock189(), createBlock184(unref192(MenuCheckboxItem_default), normalizeProps75(guardReactiveProps75({
        ...props2,
        ...unref192(emitsAsProps)
      })), {
        default: withCtx185(() => [renderSlot189(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuCheckboxItem_default = DropdownMenuCheckboxItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuRoot.js
import { createBlock as createBlock185, defineComponent as defineComponent198, isRef as isRef8, openBlock as openBlock190, ref as ref57, renderSlot as renderSlot190, toRefs as toRefs26, unref as unref193, withCtx as withCtx186 } from "vue";
var [injectDropdownMenuRootContext, provideDropdownMenuRootContext] = createContext("DropdownMenuRoot");
var DropdownMenuRoot_vue_vue_type_script_setup_true_lang_default = defineComponent198({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    dir: {
      type: String,
      required: false
    },
    modal: {
      type: Boolean,
      required: false,
      default: true
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref57();
    const { modal, dir: propDir } = toRefs26(props2);
    const dir = useDirection(propDir);
    provideDropdownMenuRootContext({
      open,
      onOpenChange: (value) => {
        open.value = value;
      },
      onOpenToggle: () => {
        open.value = !open.value;
      },
      triggerId: "",
      triggerElement,
      contentId: "",
      modal,
      dir
    });
    return (_ctx, _cache) => {
      return openBlock190(), createBlock185(unref193(MenuRoot_default), {
        open: unref193(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef8(open) ? open.value = $event : null),
        dir: unref193(dir),
        modal: unref193(modal)
      }, {
        default: withCtx186(() => [renderSlot190(_ctx.$slots, "default", { open: unref193(open) })]),
        _: 3
      }, 8, [
        "open",
        "dir",
        "modal"
      ]);
    };
  }
});
var DropdownMenuRoot_default = DropdownMenuRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuContent.js
import { createBlock as createBlock186, defineComponent as defineComponent199, mergeProps as mergeProps80, openBlock as openBlock191, ref as ref58, renderSlot as renderSlot191, unref as unref194, withCtx as withCtx187 } from "vue";
var DropdownMenuContent_vue_vue_type_script_setup_true_lang_default = defineComponent199({
  __name: "DropdownMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const rootContext = injectDropdownMenuRootContext();
    const hasInteractedOutsideRef = ref58(false);
    function handleCloseAutoFocus(event) {
      if (event.defaultPrevented) return;
      if (!hasInteractedOutsideRef.value) setTimeout(() => {
        rootContext.triggerElement.value?.focus();
      }, 0);
      hasInteractedOutsideRef.value = false;
      event.preventDefault();
    }
    rootContext.contentId ||= useId2(void 0, "reka-dropdown-menu-content");
    return (_ctx, _cache) => {
      return openBlock191(), createBlock186(unref194(MenuContent_default), mergeProps80(unref194(forwarded), {
        id: unref194(rootContext).contentId,
        "aria-labelledby": unref194(rootContext)?.triggerId,
        style: {
          "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
          "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
          "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: handleCloseAutoFocus,
        onInteractOutside: _cache[0] || (_cache[0] = (event) => {
          if (event.defaultPrevented) return;
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!unref194(rootContext).modal.value || isRightClick) hasInteractedOutsideRef.value = true;
          if (unref194(rootContext).triggerElement.value?.contains(event.target)) event.preventDefault();
        })
      }), {
        default: withCtx187(() => [renderSlot191(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
});
var DropdownMenuContent_default = DropdownMenuContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuGroup.js
import { createBlock as createBlock187, defineComponent as defineComponent200, guardReactiveProps as guardReactiveProps76, normalizeProps as normalizeProps76, openBlock as openBlock192, renderSlot as renderSlot192, unref as unref195, withCtx as withCtx188 } from "vue";
var DropdownMenuGroup_vue_vue_type_script_setup_true_lang_default = defineComponent200({
  __name: "DropdownMenuGroup",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock192(), createBlock187(unref195(MenuGroup_default), normalizeProps76(guardReactiveProps76(props2)), {
        default: withCtx188(() => [renderSlot192(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuGroup_default = DropdownMenuGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuItem.js
import { createBlock as createBlock188, defineComponent as defineComponent201, guardReactiveProps as guardReactiveProps77, normalizeProps as normalizeProps77, openBlock as openBlock193, renderSlot as renderSlot193, unref as unref196, withCtx as withCtx189 } from "vue";
var DropdownMenuItem_vue_vue_type_script_setup_true_lang_default = defineComponent201({
  __name: "DropdownMenuItem",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock193(), createBlock188(unref196(MenuItem_default), normalizeProps77(guardReactiveProps77({
        ...props2,
        ...unref196(emitsAsProps)
      })), {
        default: withCtx189(() => [renderSlot193(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuItem_default = DropdownMenuItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuItemIndicator.js
import { createBlock as createBlock189, defineComponent as defineComponent202, guardReactiveProps as guardReactiveProps78, normalizeProps as normalizeProps78, openBlock as openBlock194, renderSlot as renderSlot194, unref as unref197, withCtx as withCtx190 } from "vue";
var DropdownMenuItemIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent202({
  __name: "DropdownMenuItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock194(), createBlock189(unref197(MenuItemIndicator_default), normalizeProps78(guardReactiveProps78(props2)), {
        default: withCtx190(() => [renderSlot194(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuItemIndicator_default = DropdownMenuItemIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuLabel.js
import { createBlock as createBlock190, defineComponent as defineComponent203, guardReactiveProps as guardReactiveProps79, normalizeProps as normalizeProps79, openBlock as openBlock195, renderSlot as renderSlot195, unref as unref198, withCtx as withCtx191 } from "vue";
var DropdownMenuLabel_vue_vue_type_script_setup_true_lang_default = defineComponent203({
  __name: "DropdownMenuLabel",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock195(), createBlock190(unref198(MenuLabel_default), normalizeProps79(guardReactiveProps79(props2)), {
        default: withCtx191(() => [renderSlot195(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuLabel_default = DropdownMenuLabel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuPortal.js
import { createBlock as createBlock191, defineComponent as defineComponent204, guardReactiveProps as guardReactiveProps80, normalizeProps as normalizeProps80, openBlock as openBlock196, renderSlot as renderSlot196, unref as unref199, withCtx as withCtx192 } from "vue";
var DropdownMenuPortal_vue_vue_type_script_setup_true_lang_default = defineComponent204({
  __name: "DropdownMenuPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock196(), createBlock191(unref199(MenuPortal_default), normalizeProps80(guardReactiveProps80(props2)), {
        default: withCtx192(() => [renderSlot196(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuPortal_default = DropdownMenuPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuRadioGroup.js
import { createBlock as createBlock192, defineComponent as defineComponent205, guardReactiveProps as guardReactiveProps81, normalizeProps as normalizeProps81, openBlock as openBlock197, renderSlot as renderSlot197, unref as unref200, withCtx as withCtx193 } from "vue";
var DropdownMenuRadioGroup_vue_vue_type_script_setup_true_lang_default = defineComponent205({
  __name: "DropdownMenuRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock197(), createBlock192(unref200(MenuRadioGroup_default), normalizeProps81(guardReactiveProps81({
        ...props2,
        ...unref200(emitsAsProps)
      })), {
        default: withCtx193(() => [renderSlot197(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuRadioGroup_default = DropdownMenuRadioGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuRadioItem.js
import { createBlock as createBlock193, defineComponent as defineComponent206, guardReactiveProps as guardReactiveProps82, normalizeProps as normalizeProps82, openBlock as openBlock198, renderSlot as renderSlot198, unref as unref201, withCtx as withCtx194 } from "vue";
var DropdownMenuRadioItem_vue_vue_type_script_setup_true_lang_default = defineComponent206({
  __name: "DropdownMenuRadioItem",
  props: {
    value: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock198(), createBlock193(unref201(MenuRadioItem_default), normalizeProps82(guardReactiveProps82(unref201(forwarded))), {
        default: withCtx194(() => [renderSlot198(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuRadioItem_default = DropdownMenuRadioItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSeparator.js
import { createBlock as createBlock194, defineComponent as defineComponent207, guardReactiveProps as guardReactiveProps83, normalizeProps as normalizeProps83, openBlock as openBlock199, renderSlot as renderSlot199, unref as unref202, withCtx as withCtx195 } from "vue";
var DropdownMenuSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent207({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock199(), createBlock194(unref202(MenuSeparator_default), normalizeProps83(guardReactiveProps83(props2)), {
        default: withCtx195(() => [renderSlot199(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuSeparator_default = DropdownMenuSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSub.js
import { createBlock as createBlock195, defineComponent as defineComponent208, isRef as isRef9, openBlock as openBlock200, renderSlot as renderSlot200, unref as unref203, withCtx as withCtx196 } from "vue";
var DropdownMenuSub_vue_vue_type_script_setup_true_lang_default = defineComponent208({
  __name: "DropdownMenuSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const open = useVModel(props2, "open", emit, {
      passive: props2.open === void 0,
      defaultValue: props2.defaultOpen ?? false
    });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock200(), createBlock195(unref203(MenuSub_default), {
        open: unref203(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef9(open) ? open.value = $event : null)
      }, {
        default: withCtx196(() => [renderSlot200(_ctx.$slots, "default", { open: unref203(open) })]),
        _: 3
      }, 8, ["open"]);
    };
  }
});
var DropdownMenuSub_default = DropdownMenuSub_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSubContent.js
import { createBlock as createBlock196, defineComponent as defineComponent209, mergeProps as mergeProps81, openBlock as openBlock201, renderSlot as renderSlot201, unref as unref204, withCtx as withCtx197 } from "vue";
var DropdownMenuSubContent_vue_vue_type_script_setup_true_lang_default = defineComponent209({
  __name: "DropdownMenuSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock201(), createBlock196(unref204(MenuSubContent_default), mergeProps81(unref204(forwarded), { style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: withCtx197(() => [renderSlot201(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuSubContent_default = DropdownMenuSubContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuSubTrigger.js
import { createBlock as createBlock197, defineComponent as defineComponent210, guardReactiveProps as guardReactiveProps84, normalizeProps as normalizeProps84, openBlock as openBlock202, renderSlot as renderSlot202, unref as unref205, withCtx as withCtx198 } from "vue";
var DropdownMenuSubTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent210({
  __name: "DropdownMenuSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock202(), createBlock197(unref205(MenuSubTrigger_default), normalizeProps84(guardReactiveProps84(props2)), {
        default: withCtx198(() => [renderSlot202(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DropdownMenuSubTrigger_default = DropdownMenuSubTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/DropdownMenu/DropdownMenuTrigger.js
import { createBlock as createBlock198, createVNode as createVNode29, defineComponent as defineComponent211, nextTick as nextTick22, onMounted as onMounted26, openBlock as openBlock203, renderSlot as renderSlot203, unref as unref206, withCtx as withCtx199, withKeys as withKeys11 } from "vue";
var DropdownMenuTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent211({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectDropdownMenuRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    onMounted26(() => {
      rootContext.triggerElement = triggerElement;
    });
    rootContext.triggerId ||= useId2(void 0, "reka-dropdown-menu-trigger");
    return (_ctx, _cache) => {
      return openBlock203(), createBlock198(unref206(MenuAnchor_default), { "as-child": "" }, {
        default: withCtx199(() => [createVNode29(unref206(Primitive), {
          id: unref206(rootContext).triggerId,
          ref: unref206(forwardRef),
          type: _ctx.as === "button" ? "button" : void 0,
          "as-child": props2.asChild,
          as: _ctx.as,
          "aria-haspopup": "menu",
          "aria-expanded": unref206(rootContext).open.value,
          "aria-controls": unref206(rootContext).open.value ? unref206(rootContext).contentId : void 0,
          "data-disabled": _ctx.disabled ? "" : void 0,
          disabled: _ctx.disabled,
          "data-state": unref206(rootContext).open.value ? "open" : "closed",
          onClick: _cache[0] || (_cache[0] = async (event) => {
            if (!_ctx.disabled && event.button === 0 && event.ctrlKey === false) {
              unref206(rootContext)?.onOpenToggle();
              await nextTick22();
              if (unref206(rootContext).open.value) event.preventDefault();
            }
          }),
          onKeydown: _cache[1] || (_cache[1] = withKeys11((event) => {
            if (_ctx.disabled) return;
            if (["Enter", " "].includes(event.key)) unref206(rootContext).onOpenToggle();
            if (event.key === "ArrowDown") unref206(rootContext).onOpenChange(true);
            if ([
              "Enter",
              " ",
              "ArrowDown"
            ].includes(event.key)) event.preventDefault();
          }, [
            "enter",
            "space",
            "arrow-down"
          ]))
        }, {
          default: withCtx199(() => [renderSlot203(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "id",
          "type",
          "as-child",
          "as",
          "aria-expanded",
          "aria-controls",
          "data-disabled",
          "disabled",
          "data-state"
        ])]),
        _: 3
      });
    };
  }
});
var DropdownMenuTrigger_default = DropdownMenuTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Editable/EditableRoot.js
import { computed as computed60, createBlock as createBlock199, createCommentVNode as createCommentVNode17, defineComponent as defineComponent212, mergeProps as mergeProps82, openBlock as openBlock204, ref as ref59, renderSlot as renderSlot204, toRefs as toRefs27, unref as unref207, watch as watch23, withCtx as withCtx200 } from "vue";
var [injectEditableRootContext, provideEditableRootContext] = createContext("EditableRoot");
var EditableRoot_vue_vue_type_script_setup_true_lang_default = defineComponent212({
  inheritAttrs: false,
  __name: "EditableRoot",
  props: {
    defaultValue: {
      type: String,
      required: false
    },
    modelValue: {
      type: [String, null],
      required: false
    },
    placeholder: {
      type: [String, Object],
      required: false,
      default: "Enter text..."
    },
    dir: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false
    },
    activationMode: {
      type: String,
      required: false,
      default: "focus"
    },
    selectOnFocus: {
      type: Boolean,
      required: false,
      default: false
    },
    submitMode: {
      type: String,
      required: false,
      default: "blur"
    },
    startWithEditMode: {
      type: Boolean,
      required: false
    },
    maxLength: {
      type: Number,
      required: false
    },
    autoResize: {
      type: Boolean,
      required: false,
      default: false
    },
    id: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: [
    "update:modelValue",
    "submit",
    "update:state"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { id, name, defaultValue, startWithEditMode, placeholder: propPlaceholder, maxLength, disabled, dir: propDir, submitMode, activationMode, selectOnFocus, readonly: readonly3, autoResize, required } = toRefs27(props2);
    const inputRef = ref59();
    const dir = useDirection(propDir);
    const isEditing = ref59(startWithEditMode.value ?? false);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value ?? "",
      passive: props2.modelValue === void 0
    });
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const isFormControl = useFormControl(currentElement);
    const placeholder = computed60(() => {
      return typeof propPlaceholder.value === "string" ? {
        edit: propPlaceholder.value,
        preview: propPlaceholder.value
      } : propPlaceholder.value;
    });
    const inputValue = ref59(modelValue.value);
    watch23(() => modelValue.value, () => {
      inputValue.value = modelValue.value;
    }, {
      immediate: true,
      deep: true
    });
    function cancel() {
      isEditing.value = false;
      emits("update:state", "cancel");
    }
    function edit() {
      isEditing.value = true;
      inputValue.value = modelValue.value;
      emits("update:state", "edit");
    }
    function submit() {
      modelValue.value = inputValue.value;
      isEditing.value = false;
      emits("update:state", "submit");
      emits("submit", modelValue.value);
    }
    function handleDismiss() {
      if (isEditing.value) if (submitMode.value === "blur" || submitMode.value === "both") submit();
      else cancel();
    }
    const pointerDownOutside = usePointerDownOutside(() => handleDismiss(), currentElement, isEditing);
    const focusOutside = useFocusOutside(() => handleDismiss(), currentElement, isEditing);
    const isEmpty = computed60(() => modelValue.value === "");
    __expose({
      submit,
      cancel,
      edit
    });
    provideEditableRootContext({
      id,
      name,
      disabled,
      isEditing,
      maxLength,
      modelValue,
      inputValue,
      placeholder,
      edit,
      cancel,
      submit,
      activationMode,
      submitMode,
      selectOnFocus,
      inputRef,
      startWithEditMode,
      isEmpty,
      readonly: readonly3,
      autoResize
    });
    return (_ctx, _cache) => {
      return openBlock204(), createBlock199(unref207(Primitive), mergeProps82(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        dir: unref207(dir),
        "data-dismissable-layer": "",
        onFocusCapture: unref207(focusOutside).onFocusCapture,
        onBlurCapture: unref207(focusOutside).onBlurCapture,
        onPointerdownCapture: unref207(pointerDownOutside).onPointerDownCapture
      }), {
        default: withCtx200(() => [renderSlot204(_ctx.$slots, "default", {
          modelValue: unref207(modelValue),
          isEditing: isEditing.value,
          isEmpty: isEmpty.value,
          submit,
          cancel,
          edit
        }), unref207(isFormControl) && unref207(name) ? (openBlock204(), createBlock199(unref207(VisuallyHiddenInput_default), {
          key: 0,
          type: "text",
          value: unref207(modelValue),
          name: unref207(name),
          disabled: unref207(disabled),
          required: unref207(required)
        }, null, 8, [
          "value",
          "name",
          "disabled",
          "required"
        ])) : createCommentVNode17("v-if", true)]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "dir",
        "onFocusCapture",
        "onBlurCapture",
        "onPointerdownCapture"
      ]);
    };
  }
});
var EditableRoot_default = EditableRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Editable/EditableArea.js
import { createBlock as createBlock200, defineComponent as defineComponent213, mergeProps as mergeProps83, openBlock as openBlock205, renderSlot as renderSlot205, unref as unref208, withCtx as withCtx201 } from "vue";
var EditableArea_vue_vue_type_script_setup_true_lang_default = defineComponent213({
  __name: "EditableArea",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock205(), createBlock200(unref208(Primitive), mergeProps83(props2, {
        "data-placeholder-shown": unref208(context2).isEditing.value ? void 0 : "",
        "data-focus": unref208(context2).isEditing.value ? "" : void 0,
        "data-focused": unref208(context2).isEditing.value ? "" : void 0,
        "data-empty": unref208(context2).isEmpty.value ? "" : void 0,
        "data-readonly": unref208(context2).readonly.value ? "" : void 0,
        "data-disabled": unref208(context2).disabled.value ? "" : void 0,
        style: unref208(context2).autoResize.value ? { display: "inline-grid" } : void 0
      }), {
        default: withCtx201(() => [renderSlot205(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "data-placeholder-shown",
        "data-focus",
        "data-focused",
        "data-empty",
        "data-readonly",
        "data-disabled",
        "style"
      ]);
    };
  }
});
var EditableArea_default = EditableArea_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Editable/EditableCancelTrigger.js
import { createBlock as createBlock201, createTextVNode as createTextVNode14, defineComponent as defineComponent214, mergeProps as mergeProps84, openBlock as openBlock206, renderSlot as renderSlot206, unref as unref209, withCtx as withCtx202 } from "vue";
var EditableCancelTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent214({
  __name: "EditableCancelTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock206(), createBlock201(unref209(Primitive), mergeProps84(props2, {
        "aria-label": "cancel",
        "aria-disabled": unref209(context2).disabled.value ? "" : void 0,
        "data-disabled": unref209(context2).disabled.value ? "" : void 0,
        disabled: unref209(context2).disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        hidden: unref209(context2).isEditing.value ? void 0 : "",
        onClick: unref209(context2).cancel
      }), {
        default: withCtx202(() => [renderSlot206(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createTextVNode14("Cancel"))])]),
        _: 3
      }, 16, [
        "aria-disabled",
        "data-disabled",
        "disabled",
        "type",
        "hidden",
        "onClick"
      ]);
    };
  }
});
var EditableCancelTrigger_default = EditableCancelTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Editable/EditableEditTrigger.js
import { createBlock as createBlock202, createTextVNode as createTextVNode15, defineComponent as defineComponent215, mergeProps as mergeProps85, openBlock as openBlock207, renderSlot as renderSlot207, unref as unref210, withCtx as withCtx203 } from "vue";
var EditableEditTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent215({
  __name: "EditableEditTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock207(), createBlock202(unref210(Primitive), mergeProps85(props2, {
        "aria-label": "edit",
        "aria-disabled": unref210(context2).disabled.value ? "" : void 0,
        "data-disabled": unref210(context2).disabled.value ? "" : void 0,
        disabled: unref210(context2).disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        hidden: unref210(context2).isEditing.value ? "" : void 0,
        onClick: unref210(context2).edit
      }), {
        default: withCtx203(() => [renderSlot207(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createTextVNode15("Edit"))])]),
        _: 3
      }, 16, [
        "aria-disabled",
        "data-disabled",
        "disabled",
        "type",
        "hidden",
        "onClick"
      ]);
    };
  }
});
var EditableEditTrigger_default = EditableEditTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Editable/EditableInput.js
import { computed as computed61, createBlock as createBlock203, defineComponent as defineComponent216, mergeProps as mergeProps86, nextTick as nextTick23, onMounted as onMounted27, openBlock as openBlock208, renderSlot as renderSlot208, unref as unref211, watch as watch24, withCtx as withCtx204, withKeys as withKeys12 } from "vue";
var EditableInput_vue_vue_type_script_setup_true_lang_default = defineComponent216({
  __name: "EditableInput",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "input"
    }
  },
  setup(__props) {
    const props2 = __props;
    const kbd = useKbd();
    const context2 = injectEditableRootContext();
    const disabled = computed61(() => context2.disabled.value);
    const placeholder = computed61(() => context2.placeholder.value?.edit);
    const { primitiveElement, currentElement: inputRef } = usePrimitiveElement();
    onMounted27(() => {
      context2.inputRef.value = inputRef.value;
      if (context2.startWithEditMode.value) {
        context2.inputRef.value?.focus({ preventScroll: true });
        if (context2.selectOnFocus.value) context2.inputRef.value?.select();
      }
    });
    watch24(context2.isEditing, (value) => {
      if (value) nextTick23(() => {
        context2.inputRef.value?.focus({ preventScroll: true });
        if (context2.selectOnFocus.value) context2.inputRef.value?.select();
      });
    });
    function handleSubmitKeyDown(event) {
      if ((context2.submitMode.value === "enter" || context2.submitMode.value === "both") && event.key === kbd.ENTER && !event.shiftKey && !event.metaKey) context2.submit();
    }
    return (_ctx, _cache) => {
      return openBlock208(), createBlock203(unref211(Primitive), mergeProps86({
        ref_key: "primitiveElement",
        ref: primitiveElement
      }, props2, {
        value: unref211(context2).inputValue.value,
        placeholder: placeholder.value,
        disabled: disabled.value,
        maxlength: unref211(context2).maxLength.value,
        "data-disabled": disabled.value ? "" : void 0,
        "data-readonly": unref211(context2).readonly.value ? "" : void 0,
        readonly: unref211(context2).readonly.value,
        "aria-label": "editable input",
        hidden: unref211(context2).autoResize.value ? void 0 : !unref211(context2).isEditing.value,
        style: unref211(context2).autoResize.value ? {
          all: "unset",
          gridArea: "1 / 1 / auto / auto",
          visibility: !unref211(context2).isEditing.value ? "hidden" : void 0
        } : void 0,
        onInput: _cache[0] || (_cache[0] = ($event) => unref211(context2).inputValue.value = $event.target.value),
        onKeydown: [withKeys12(handleSubmitKeyDown, ["enter", "space"]), withKeys12(unref211(context2).cancel, ["esc"])]
      }), {
        default: withCtx204(() => [renderSlot208(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "value",
        "placeholder",
        "disabled",
        "maxlength",
        "data-disabled",
        "data-readonly",
        "readonly",
        "hidden",
        "style",
        "onKeydown"
      ]);
    };
  }
});
var EditableInput_default = EditableInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Editable/EditablePreview.js
import { computed as computed62, createBlock as createBlock204, createTextVNode as createTextVNode16, defineComponent as defineComponent217, mergeProps as mergeProps87, openBlock as openBlock209, renderSlot as renderSlot209, toDisplayString as toDisplayString10, unref as unref212, withCtx as withCtx205 } from "vue";
var EditablePreview_vue_vue_type_script_setup_true_lang_default = defineComponent217({
  __name: "EditablePreview",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    const placeholder = computed62(() => context2.placeholder.value?.preview);
    function handleFocus() {
      if (context2.activationMode.value === "focus") context2.edit();
    }
    function handleDoubleClick() {
      if (context2.activationMode.value === "dblclick") context2.edit();
    }
    return (_ctx, _cache) => {
      return openBlock209(), createBlock204(unref212(Primitive), mergeProps87(props2, {
        tabindex: "0",
        "data-placeholder-shown": unref212(context2).isEditing.value ? void 0 : "",
        hidden: unref212(context2).autoResize.value ? void 0 : unref212(context2).isEditing.value,
        style: unref212(context2).autoResize.value ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: unref212(context2).isEditing.value ? "hidden" : void 0,
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0,
        onFocusin: handleFocus,
        onDblclick: handleDoubleClick
      }), {
        default: withCtx205(() => [renderSlot209(_ctx.$slots, "default", {}, () => [createTextVNode16(toDisplayString10(unref212(context2).modelValue.value || placeholder.value), 1)])]),
        _: 3
      }, 16, [
        "data-placeholder-shown",
        "hidden",
        "style"
      ]);
    };
  }
});
var EditablePreview_default = EditablePreview_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Editable/EditableSubmitTrigger.js
import { createBlock as createBlock205, createTextVNode as createTextVNode17, defineComponent as defineComponent218, mergeProps as mergeProps88, openBlock as openBlock210, renderSlot as renderSlot210, unref as unref213, withCtx as withCtx206 } from "vue";
var EditableSubmitTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent218({
  __name: "EditableSubmitTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectEditableRootContext();
    return (_ctx, _cache) => {
      return openBlock210(), createBlock205(unref213(Primitive), mergeProps88(props2, {
        "aria-label": "submit",
        "aria-disabled": unref213(context2).disabled.value ? "" : void 0,
        "data-disabled": unref213(context2).disabled.value ? "" : void 0,
        disabled: unref213(context2).disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        hidden: unref213(context2).isEditing.value ? void 0 : "",
        onClick: unref213(context2).submit
      }), {
        default: withCtx206(() => [renderSlot210(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createTextVNode17("Submit"))])]),
        _: 3
      }, 16, [
        "aria-disabled",
        "data-disabled",
        "disabled",
        "type",
        "hidden",
        "onClick"
      ]);
    };
  }
});
var EditableSubmitTrigger_default = EditableSubmitTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/HoverCard/HoverCardArrow.js
import { createBlock as createBlock206, defineComponent as defineComponent219, guardReactiveProps as guardReactiveProps85, normalizeProps as normalizeProps85, openBlock as openBlock211, renderSlot as renderSlot211, unref as unref214, withCtx as withCtx207 } from "vue";
var HoverCardArrow_vue_vue_type_script_setup_true_lang_default = defineComponent219({
  __name: "HoverCardArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock211(), createBlock206(unref214(PopperArrow_default), normalizeProps85(guardReactiveProps85(props2)), {
        default: withCtx207(() => [renderSlot211(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var HoverCardArrow_default = HoverCardArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/HoverCard/HoverCardRoot.js
import { createBlock as createBlock207, defineComponent as defineComponent220, openBlock as openBlock212, ref as ref60, renderSlot as renderSlot212, toRefs as toRefs28, unref as unref215, withCtx as withCtx208 } from "vue";
var [injectHoverCardRootContext, provideHoverCardRootContext] = createContext("HoverCardRoot");
var HoverCardRoot_vue_vue_type_script_setup_true_lang_default = defineComponent220({
  __name: "HoverCardRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false,
      default: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    openDelay: {
      type: Number,
      required: false,
      default: 700
    },
    closeDelay: {
      type: Number,
      required: false,
      default: 300
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { openDelay, closeDelay } = toRefs28(props2);
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const openTimerRef = ref60(0);
    const closeTimerRef = ref60(0);
    const hasSelectionRef = ref60(false);
    const isPointerDownOnContentRef = ref60(false);
    const isPointerInTransitRef = ref60(false);
    const triggerElement = ref60();
    function handleOpen() {
      clearTimeout(closeTimerRef.value);
      openTimerRef.value = window.setTimeout(() => open.value = true, openDelay.value);
    }
    function handleClose() {
      clearTimeout(openTimerRef.value);
      if (!hasSelectionRef.value && !isPointerDownOnContentRef.value) closeTimerRef.value = window.setTimeout(() => open.value = false, closeDelay.value);
    }
    function handleDismiss() {
      open.value = false;
    }
    provideHoverCardRootContext({
      open,
      onOpenChange(value) {
        open.value = value;
      },
      onOpen: handleOpen,
      onClose: handleClose,
      onDismiss: handleDismiss,
      hasSelectionRef,
      isPointerDownOnContentRef,
      isPointerInTransitRef,
      triggerElement
    });
    return (_ctx, _cache) => {
      return openBlock212(), createBlock207(unref215(PopperRoot_default), null, {
        default: withCtx208(() => [renderSlot212(_ctx.$slots, "default", { open: unref215(open) })]),
        _: 3
      });
    };
  }
});
var HoverCardRoot_default = HoverCardRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/HoverCard/utils.js
function excludeTouch(eventHandler) {
  return (event) => event.pointerType === "touch" ? void 0 : eventHandler();
}
function getTabbableNodes(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
    return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}

// node_modules/reka-ui/dist/HoverCard/HoverCardContentImpl.js
import { createBlock as createBlock208, createVNode as createVNode30, defineComponent as defineComponent221, mergeProps as mergeProps89, nextTick as nextTick24, onMounted as onMounted28, onUnmounted as onUnmounted14, openBlock as openBlock213, ref as ref61, renderSlot as renderSlot213, unref as unref216, watchEffect as watchEffect13, withCtx as withCtx209, withModifiers as withModifiers11 } from "vue";
var HoverCardContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent221({
  __name: "HoverCardContentImpl",
  props: {
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardProps(props2);
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    const { isPointerInTransit, onPointerExit } = useGraceArea(rootContext.triggerElement, contentElement);
    syncRef(rootContext.isPointerInTransitRef, isPointerInTransit, { direction: "rtl" });
    onPointerExit(() => {
      rootContext.onClose();
    });
    const containSelection = ref61(false);
    let originalBodyUserSelect;
    watchEffect13((cleanupFn) => {
      if (containSelection.value) {
        const body = document.body;
        originalBodyUserSelect = body.style.userSelect || body.style.webkitUserSelect;
        body.style.userSelect = "none";
        body.style.webkitUserSelect = "none";
        cleanupFn(() => {
          body.style.userSelect = originalBodyUserSelect;
          body.style.webkitUserSelect = originalBodyUserSelect;
        });
      }
    });
    function handlePointerUp2() {
      containSelection.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
      nextTick24(() => {
        const hasSelection = document.getSelection()?.toString() !== "";
        if (hasSelection) rootContext.hasSelectionRef.value = true;
      });
    }
    onMounted28(() => {
      if (contentElement.value) {
        document.addEventListener("pointerup", handlePointerUp2);
        const tabbables = getTabbableNodes(contentElement.value);
        tabbables.forEach((tabbable) => tabbable.setAttribute("tabindex", "-1"));
      }
    });
    onUnmounted14(() => {
      document.removeEventListener("pointerup", handlePointerUp2);
      rootContext.hasSelectionRef.value = false;
      rootContext.isPointerDownOnContentRef.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock213(), createBlock208(unref216(DismissableLayer_default), {
        "as-child": "",
        "disable-outside-pointer-events": false,
        onEscapeKeyDown: _cache[1] || (_cache[1] = ($event) => emits("escapeKeyDown", $event)),
        onPointerDownOutside: _cache[2] || (_cache[2] = ($event) => emits("pointerDownOutside", $event)),
        onFocusOutside: _cache[3] || (_cache[3] = withModifiers11(($event) => emits("focusOutside", $event), ["prevent"])),
        onDismiss: unref216(rootContext).onDismiss
      }, {
        default: withCtx209(() => [createVNode30(unref216(PopperContent_default), mergeProps89({
          ...unref216(forwarded),
          ..._ctx.$attrs
        }, {
          ref: unref216(forwardRef),
          "data-state": unref216(rootContext).open.value ? "open" : "closed",
          style: {
            "userSelect": containSelection.value ? "text" : void 0,
            "WebkitUserSelect": containSelection.value ? "text" : void 0,
            "--reka-hover-card-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-hover-card-content-available-width": "var(--reka-popper-available-width)",
            "--reka-hover-card-content-available-height": "var(--reka-popper-available-height)",
            "--reka-hover-card-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-hover-card-trigger-height": "var(--reka-popper-anchor-height)"
          },
          onPointerdown: _cache[0] || (_cache[0] = (event) => {
            if (event.currentTarget.contains(event.target)) containSelection.value = true;
            unref216(rootContext).hasSelectionRef.value = false;
            unref216(rootContext).isPointerDownOnContentRef.value = true;
          })
        }), {
          default: withCtx209(() => [renderSlot213(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["data-state", "style"])]),
        _: 3
      }, 8, ["onDismiss"]);
    };
  }
});
var HoverCardContentImpl_default = HoverCardContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/HoverCard/HoverCardContent.js
import { createBlock as createBlock209, createVNode as createVNode31, defineComponent as defineComponent222, mergeProps as mergeProps90, openBlock as openBlock214, renderSlot as renderSlot214, unref as unref217, withCtx as withCtx210 } from "vue";
var HoverCardContent_vue_vue_type_script_setup_true_lang_default = defineComponent222({
  __name: "HoverCardContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    return (_ctx, _cache) => {
      return openBlock214(), createBlock209(unref217(Presence_default), { present: _ctx.forceMount || unref217(rootContext).open.value }, {
        default: withCtx210(() => [createVNode31(HoverCardContentImpl_default, mergeProps90(unref217(forwarded), {
          ref: unref217(forwardRef),
          onPointerenter: _cache[0] || (_cache[0] = ($event) => unref217(excludeTouch)(unref217(rootContext).onOpen)($event))
        }), {
          default: withCtx210(() => [renderSlot214(_ctx.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var HoverCardContent_default = HoverCardContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/HoverCard/HoverCardPortal.js
import { createBlock as createBlock210, defineComponent as defineComponent223, guardReactiveProps as guardReactiveProps86, normalizeProps as normalizeProps86, openBlock as openBlock215, renderSlot as renderSlot215, unref as unref218, withCtx as withCtx211 } from "vue";
var HoverCardPortal_vue_vue_type_script_setup_true_lang_default = defineComponent223({
  __name: "HoverCardPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock215(), createBlock210(unref218(Teleport_default), normalizeProps86(guardReactiveProps86(props2)), {
        default: withCtx211(() => [renderSlot215(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var HoverCardPortal_default = HoverCardPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/HoverCard/HoverCardTrigger.js
import { createBlock as createBlock211, createVNode as createVNode32, defineComponent as defineComponent224, openBlock as openBlock216, renderSlot as renderSlot216, unref as unref219, withCtx as withCtx212 } from "vue";
var HoverCardTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent224({
  __name: "HoverCardTrigger",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "a"
    }
  },
  setup(__props) {
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectHoverCardRootContext();
    rootContext.triggerElement = currentElement;
    function handleLeave() {
      setTimeout(() => {
        if (!rootContext.isPointerInTransitRef.value && !rootContext.open.value) rootContext.onClose();
      }, 0);
    }
    return (_ctx, _cache) => {
      return openBlock216(), createBlock211(unref219(PopperAnchor_default), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx212(() => [createVNode32(unref219(Primitive), {
          ref: unref219(forwardRef),
          "as-child": _ctx.asChild,
          as: _ctx.as,
          "data-state": unref219(rootContext).open.value ? "open" : "closed",
          "data-grace-area-trigger": "",
          onPointerenter: _cache[0] || (_cache[0] = ($event) => unref219(excludeTouch)(unref219(rootContext).onOpen)($event)),
          onPointerleave: _cache[1] || (_cache[1] = ($event) => unref219(excludeTouch)(handleLeave)($event)),
          onFocus: _cache[2] || (_cache[2] = ($event) => unref219(rootContext).onOpen()),
          onBlur: _cache[3] || (_cache[3] = ($event) => unref219(rootContext).onClose())
        }, {
          default: withCtx212(() => [renderSlot216(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as-child",
          "as",
          "data-state"
        ])]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});
var HoverCardTrigger_default = HoverCardTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Label/Label.js
import { createBlock as createBlock212, defineComponent as defineComponent225, mergeProps as mergeProps91, openBlock as openBlock217, renderSlot as renderSlot217, unref as unref220, withCtx as withCtx213 } from "vue";
var Label_vue_vue_type_script_setup_true_lang_default = defineComponent225({
  __name: "Label",
  props: {
    for: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "label"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock217(), createBlock212(unref220(Primitive), mergeProps91(props2, { onMousedown: _cache[0] || (_cache[0] = (event) => {
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }) }), {
        default: withCtx213(() => [renderSlot217(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var Label_default = Label_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarArrow.js
import { createBlock as createBlock213, defineComponent as defineComponent226, guardReactiveProps as guardReactiveProps87, normalizeProps as normalizeProps87, openBlock as openBlock218, renderSlot as renderSlot218, unref as unref221, withCtx as withCtx214 } from "vue";
var MenubarArrow_vue_vue_type_script_setup_true_lang_default = defineComponent226({
  __name: "MenubarArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock218(), createBlock213(unref221(MenuArrow_default), normalizeProps87(guardReactiveProps87(props2)), {
        default: withCtx214(() => [renderSlot218(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarArrow_default = MenubarArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarCheckboxItem.js
import { createBlock as createBlock214, defineComponent as defineComponent227, guardReactiveProps as guardReactiveProps88, normalizeProps as normalizeProps88, openBlock as openBlock219, renderSlot as renderSlot219, unref as unref222, withCtx as withCtx215 } from "vue";
var MenubarCheckboxItem_vue_vue_type_script_setup_true_lang_default = defineComponent227({
  __name: "MenubarCheckboxItem",
  props: {
    modelValue: {
      type: [Boolean, String],
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock219(), createBlock214(unref222(MenuCheckboxItem_default), normalizeProps88(guardReactiveProps88({
        ...props2,
        ...unref222(emitsAsProps)
      })), {
        default: withCtx215(() => [renderSlot219(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarCheckboxItem_default = MenubarCheckboxItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarRoot.js
import { createBlock as createBlock215, createVNode as createVNode33, defineComponent as defineComponent228, openBlock as openBlock220, ref as ref62, renderSlot as renderSlot220, toRefs as toRefs29, unref as unref223, withCtx as withCtx216 } from "vue";
var [injectMenubarRootContext, provideMenubarRootContext] = createContext("MenubarRoot");
var MenubarRoot_vue_vue_type_script_setup_true_lang_default = defineComponent228({
  __name: "MenubarRoot",
  props: {
    modelValue: {
      type: String,
      required: false
    },
    defaultValue: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    loop: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { forwardRef } = useForwardExpose();
    const { CollectionSlot } = useCollection({
      key: "Menubar",
      isProvider: true
    });
    const modelValue = useVModel(props2, "modelValue", emit, {
      defaultValue: props2.defaultValue ?? "",
      passive: props2.modelValue === void 0
    });
    const currentTabStopId = ref62(null);
    const { dir: propDir, loop } = toRefs29(props2);
    const dir = useDirection(propDir);
    provideMenubarRootContext({
      modelValue,
      dir,
      loop,
      onMenuOpen: (value) => {
        modelValue.value = value;
        currentTabStopId.value = value;
      },
      onMenuClose: () => {
        modelValue.value = "";
      },
      onMenuToggle: (value) => {
        modelValue.value = modelValue.value ? "" : value;
        currentTabStopId.value = value;
      }
    });
    return (_ctx, _cache) => {
      return openBlock220(), createBlock215(unref223(CollectionSlot), null, {
        default: withCtx216(() => [createVNode33(unref223(RovingFocusGroup_default), {
          "current-tab-stop-id": currentTabStopId.value,
          "onUpdate:currentTabStopId": _cache[0] || (_cache[0] = ($event) => currentTabStopId.value = $event),
          orientation: "horizontal",
          loop: unref223(loop),
          dir: unref223(dir),
          "as-child": ""
        }, {
          default: withCtx216(() => [createVNode33(unref223(Primitive), {
            ref: unref223(forwardRef),
            role: "menubar"
          }, {
            default: withCtx216(() => [renderSlot220(_ctx.$slots, "default", { modelValue: unref223(modelValue) })]),
            _: 3
          }, 512)]),
          _: 3
        }, 8, [
          "current-tab-stop-id",
          "loop",
          "dir"
        ])]),
        _: 3
      });
    };
  }
});
var MenubarRoot_default = MenubarRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarMenu.js
import { computed as computed63, createBlock as createBlock216, defineComponent as defineComponent229, openBlock as openBlock221, ref as ref63, renderSlot as renderSlot221, unref as unref224, watch as watch25, withCtx as withCtx217 } from "vue";
var [injectMenubarMenuContext, provideMenubarMenuContext] = createContext("MenubarMenu");
var MenubarMenu_vue_vue_type_script_setup_true_lang_default = defineComponent229({
  __name: "MenubarMenu",
  props: { value: {
    type: String,
    required: false
  } },
  setup(__props) {
    const props2 = __props;
    const value = useId2(props2.value);
    const rootContext = injectMenubarRootContext();
    useForwardExpose();
    const triggerElement = ref63();
    const wasKeyboardTriggerOpenRef = ref63(false);
    const open = computed63(() => rootContext.modelValue.value === value);
    watch25(open, () => {
      if (!open.value) wasKeyboardTriggerOpenRef.value = false;
    });
    provideMenubarMenuContext({
      value,
      triggerElement,
      triggerId: value,
      contentId: "",
      wasKeyboardTriggerOpenRef
    });
    return (_ctx, _cache) => {
      return openBlock221(), createBlock216(unref224(MenuRoot_default), {
        open: open.value,
        modal: false,
        dir: unref224(rootContext).dir.value,
        "onUpdate:open": _cache[0] || (_cache[0] = (value$1) => {
          if (!value$1) unref224(rootContext).onMenuClose();
        })
      }, {
        default: withCtx217(() => [renderSlot221(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["open", "dir"]);
    };
  }
});
var MenubarMenu_default = MenubarMenu_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarContent.js
import { createBlock as createBlock217, defineComponent as defineComponent230, mergeProps as mergeProps92, openBlock as openBlock222, ref as ref64, renderSlot as renderSlot222, unref as unref225, withCtx as withCtx218, withKeys as withKeys13 } from "vue";
var MenubarContent_vue_vue_type_script_setup_true_lang_default = defineComponent230({
  __name: "MenubarContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const rootContext = injectMenubarRootContext();
    const menuContext = injectMenubarMenuContext();
    menuContext.contentId ||= useId2(void 0, "reka-menubar-content");
    const { getItems } = useCollection({ key: "Menubar" });
    const hasInteractedOutsideRef = ref64(false);
    function handleArrowNavigation(event) {
      const target = event.target;
      const targetIsSubTrigger = target.hasAttribute("data-reka-menubar-subtrigger");
      const prevMenuKey = rootContext.dir.value === "rtl" ? "ArrowRight" : "ArrowLeft";
      const isPrevKey = prevMenuKey === event.key;
      const isNextKey = !isPrevKey;
      if (isNextKey && targetIsSubTrigger) return;
      let candidateValues = getItems().filter((i) => i.ref.dataset.disabled !== "").map((i) => i.ref.dataset.value);
      if (isPrevKey) candidateValues.reverse();
      const currentIndex = candidateValues.indexOf(menuContext.value);
      candidateValues = rootContext.loop.value ? wrapArray(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
      const [nextValue] = candidateValues;
      if (nextValue) rootContext.onMenuOpen(nextValue);
    }
    return (_ctx, _cache) => {
      return openBlock222(), createBlock217(unref225(MenuContent_default), mergeProps92(unref225(forwarded), {
        id: unref225(menuContext).contentId,
        "data-reka-menubar-content": "",
        "aria-labelledby": unref225(menuContext).triggerId,
        style: {
          "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
          "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
          "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onCloseAutoFocus: _cache[0] || (_cache[0] = (event) => {
          const menubarOpen = Boolean(unref225(rootContext).modelValue.value);
          if (!menubarOpen && !hasInteractedOutsideRef.value) unref225(menuContext).triggerElement.value?.focus();
          hasInteractedOutsideRef.value = false;
          event.preventDefault();
        }),
        onFocusOutside: _cache[1] || (_cache[1] = (event) => {
          const target = event.target;
          const isMenubarTrigger = unref225(getItems)().filter((i) => i.ref.dataset.disabled !== "").some((i) => i.ref.contains(target));
          if (isMenubarTrigger) event.preventDefault();
        }),
        onInteractOutside: _cache[2] || (_cache[2] = (event) => {
          hasInteractedOutsideRef.value = true;
        }),
        onEntryFocus: _cache[3] || (_cache[3] = (event) => {
          if (!unref225(menuContext).wasKeyboardTriggerOpenRef.value) event.preventDefault();
        }),
        onKeydown: withKeys13(handleArrowNavigation, ["arrow-right", "arrow-left"])
      }), {
        default: withCtx218(() => [renderSlot222(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id", "aria-labelledby"]);
    };
  }
});
var MenubarContent_default = MenubarContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarGroup.js
import { createBlock as createBlock218, defineComponent as defineComponent231, guardReactiveProps as guardReactiveProps89, normalizeProps as normalizeProps89, openBlock as openBlock223, renderSlot as renderSlot223, unref as unref226, withCtx as withCtx219 } from "vue";
var MenubarGroup_vue_vue_type_script_setup_true_lang_default = defineComponent231({
  __name: "MenubarGroup",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock223(), createBlock218(unref226(MenuGroup_default), normalizeProps89(guardReactiveProps89(props2)), {
        default: withCtx219(() => [renderSlot223(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarGroup_default = MenubarGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarItem.js
import { createBlock as createBlock219, defineComponent as defineComponent232, guardReactiveProps as guardReactiveProps90, normalizeProps as normalizeProps90, openBlock as openBlock224, renderSlot as renderSlot224, unref as unref227, withCtx as withCtx220 } from "vue";
var MenubarItem_vue_vue_type_script_setup_true_lang_default = defineComponent232({
  __name: "MenubarItem",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock224(), createBlock219(unref227(MenuItem_default), normalizeProps90(guardReactiveProps90({
        ...props2,
        ...unref227(emitsAsProps)
      })), {
        default: withCtx220(() => [renderSlot224(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarItem_default = MenubarItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarItemIndicator.js
import { createBlock as createBlock220, defineComponent as defineComponent233, guardReactiveProps as guardReactiveProps91, normalizeProps as normalizeProps91, openBlock as openBlock225, renderSlot as renderSlot225, unref as unref228, withCtx as withCtx221 } from "vue";
var MenubarItemIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent233({
  __name: "MenubarItemIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock225(), createBlock220(unref228(MenuItemIndicator_default), normalizeProps91(guardReactiveProps91(props2)), {
        default: withCtx221(() => [renderSlot225(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarItemIndicator_default = MenubarItemIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarLabel.js
import { createBlock as createBlock221, defineComponent as defineComponent234, guardReactiveProps as guardReactiveProps92, normalizeProps as normalizeProps92, openBlock as openBlock226, renderSlot as renderSlot226, unref as unref229, withCtx as withCtx222 } from "vue";
var MenubarLabel_vue_vue_type_script_setup_true_lang_default = defineComponent234({
  __name: "MenubarLabel",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock226(), createBlock221(unref229(MenuLabel_default), normalizeProps92(guardReactiveProps92(props2)), {
        default: withCtx222(() => [renderSlot226(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarLabel_default = MenubarLabel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarPortal.js
import { createBlock as createBlock222, defineComponent as defineComponent235, guardReactiveProps as guardReactiveProps93, normalizeProps as normalizeProps93, openBlock as openBlock227, renderSlot as renderSlot227, unref as unref230, withCtx as withCtx223 } from "vue";
var MenubarPortal_vue_vue_type_script_setup_true_lang_default = defineComponent235({
  __name: "MenubarPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock227(), createBlock222(unref230(MenuPortal_default), normalizeProps93(guardReactiveProps93(props2)), {
        default: withCtx223(() => [renderSlot227(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarPortal_default = MenubarPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarRadioGroup.js
import { createBlock as createBlock223, defineComponent as defineComponent236, guardReactiveProps as guardReactiveProps94, normalizeProps as normalizeProps94, openBlock as openBlock228, renderSlot as renderSlot228, unref as unref231, withCtx as withCtx224 } from "vue";
var MenubarRadioGroup_vue_vue_type_script_setup_true_lang_default = defineComponent236({
  __name: "MenubarRadioGroup",
  props: {
    modelValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock228(), createBlock223(unref231(MenuRadioGroup_default), normalizeProps94(guardReactiveProps94({
        ...props2,
        ...unref231(emitsAsProps)
      })), {
        default: withCtx224(() => [renderSlot228(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarRadioGroup_default = MenubarRadioGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarRadioItem.js
import { createBlock as createBlock224, defineComponent as defineComponent237, guardReactiveProps as guardReactiveProps95, normalizeProps as normalizeProps95, openBlock as openBlock229, renderSlot as renderSlot229, unref as unref232, withCtx as withCtx225 } from "vue";
var MenubarRadioItem_vue_vue_type_script_setup_true_lang_default = defineComponent237({
  __name: "MenubarRadioItem",
  props: {
    value: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock229(), createBlock224(unref232(MenuRadioItem_default), normalizeProps95(guardReactiveProps95(unref232(forwarded))), {
        default: withCtx225(() => [renderSlot229(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarRadioItem_default = MenubarRadioItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarSeparator.js
import { createBlock as createBlock225, defineComponent as defineComponent238, guardReactiveProps as guardReactiveProps96, normalizeProps as normalizeProps96, openBlock as openBlock230, renderSlot as renderSlot230, unref as unref233, withCtx as withCtx226 } from "vue";
var MenubarSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent238({
  __name: "MenubarSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock230(), createBlock225(unref233(MenuSeparator_default), normalizeProps96(guardReactiveProps96(props2)), {
        default: withCtx226(() => [renderSlot230(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarSeparator_default = MenubarSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarSub.js
import { createBlock as createBlock226, defineComponent as defineComponent239, isRef as isRef10, openBlock as openBlock231, renderSlot as renderSlot231, unref as unref234, withCtx as withCtx227 } from "vue";
var MenubarSub_vue_vue_type_script_setup_true_lang_default = defineComponent239({
  __name: "MenubarSub",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen ?? false,
      passive: props2.open === void 0
    });
    return (_ctx, _cache) => {
      return openBlock231(), createBlock226(unref234(MenuSub_default), {
        open: unref234(open),
        "onUpdate:open": _cache[0] || (_cache[0] = ($event) => isRef10(open) ? open.value = $event : null)
      }, {
        default: withCtx227(() => [renderSlot231(_ctx.$slots, "default", { open: unref234(open) })]),
        _: 3
      }, 8, ["open"]);
    };
  }
});
var MenubarSub_default = MenubarSub_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarSubContent.js
import { createBlock as createBlock227, defineComponent as defineComponent240, mergeProps as mergeProps93, openBlock as openBlock232, renderSlot as renderSlot232, unref as unref235, withCtx as withCtx228, withKeys as withKeys14 } from "vue";
var MenubarSubContent_vue_vue_type_script_setup_true_lang_default = defineComponent240({
  __name: "MenubarSubContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside",
    "entryFocus",
    "openAutoFocus",
    "closeAutoFocus"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    useForwardExpose();
    const { getItems } = useCollection({ key: "Menubar" });
    const rootContext = injectMenubarRootContext();
    const menuContext = injectMenubarMenuContext();
    function handleArrowNavigation(event) {
      const target = event.target;
      const targetIsSubTrigger = target.hasAttribute("data-reka-menubar-subtrigger");
      if (targetIsSubTrigger) return;
      let candidateValues = getItems().filter((i) => i.ref.dataset.disabled !== "").map((i) => i.ref.dataset.value);
      const currentIndex = candidateValues.indexOf(menuContext.value);
      candidateValues = rootContext.loop.value ? wrapArray(candidateValues, currentIndex + 1) : candidateValues.slice(currentIndex + 1);
      const [nextValue] = candidateValues;
      if (nextValue) rootContext.onMenuOpen(nextValue);
    }
    return (_ctx, _cache) => {
      return openBlock232(), createBlock227(unref235(MenuSubContent_default), mergeProps93(unref235(forwarded), {
        "data-reka-menubar-content": "",
        style: {
          "--reka-menubar-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-menubar-content-available-width": "var(--reka-popper-available-width)",
          "--reka-menubar-content-available-height": "var(--reka-popper-available-height)",
          "--reka-menubar-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-menubar-trigger-height": "var(--reka-popper-anchor-height)"
        },
        onKeydown: withKeys14(handleArrowNavigation, ["arrow-right"])
      }), {
        default: withCtx228(() => [renderSlot232(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarSubContent_default = MenubarSubContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarSubTrigger.js
import { createBlock as createBlock228, defineComponent as defineComponent241, mergeProps as mergeProps94, openBlock as openBlock233, renderSlot as renderSlot233, unref as unref236, withCtx as withCtx229 } from "vue";
var MenubarSubTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent241({
  __name: "MenubarSubTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock233(), createBlock228(unref236(MenuSubTrigger_default), mergeProps94(props2, { "data-reka-menubar-subtrigger": "" }), {
        default: withCtx229(() => [renderSlot233(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var MenubarSubTrigger_default = MenubarSubTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Menubar/MenubarTrigger.js
import { computed as computed64, createBlock as createBlock229, createVNode as createVNode34, defineComponent as defineComponent242, onMounted as onMounted29, openBlock as openBlock234, ref as ref65, renderSlot as renderSlot234, unref as unref237, withCtx as withCtx230, withKeys as withKeys15 } from "vue";
var MenubarTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent242({
  __name: "MenubarTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const rootContext = injectMenubarRootContext();
    const menuContext = injectMenubarMenuContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const { CollectionItem } = useCollection({ key: "Menubar" });
    const isFocused = ref65(false);
    const open = computed64(() => rootContext.modelValue.value === menuContext.value);
    onMounted29(() => {
      menuContext.triggerElement = triggerElement;
    });
    return (_ctx, _cache) => {
      return openBlock234(), createBlock229(unref237(RovingFocusItem_default), {
        "as-child": "",
        focusable: !_ctx.disabled,
        "tab-stop-id": unref237(menuContext).value
      }, {
        default: withCtx230(() => [createVNode34(unref237(CollectionItem), null, {
          default: withCtx230(() => [createVNode34(unref237(MenuAnchor_default), { "as-child": "" }, {
            default: withCtx230(() => [createVNode34(unref237(Primitive), {
              id: unref237(menuContext).triggerId,
              ref: unref237(forwardRef),
              as: _ctx.as,
              "as-child": _ctx.asChild,
              type: _ctx.as === "button" ? "button" : void 0,
              role: "menuitem",
              "aria-haspopup": "menu",
              "aria-expanded": open.value,
              "aria-controls": open.value ? unref237(menuContext).contentId : void 0,
              "data-highlighted": isFocused.value ? "" : void 0,
              "data-state": open.value ? "open" : "closed",
              "data-disabled": _ctx.disabled ? "" : void 0,
              disabled: _ctx.disabled,
              "data-value": unref237(menuContext).value,
              onPointerdown: _cache[0] || (_cache[0] = (event) => {
                if (!_ctx.disabled && event.button === 0 && event.ctrlKey === false) {
                  unref237(rootContext).onMenuOpen(unref237(menuContext).value);
                  if (!open.value) event.preventDefault();
                }
              }),
              onPointerenter: _cache[1] || (_cache[1] = () => {
                const menubarOpen = Boolean(unref237(rootContext).modelValue.value);
                if (menubarOpen && !open.value) {
                  unref237(rootContext).onMenuOpen(unref237(menuContext).value);
                  unref237(triggerElement)?.focus();
                }
              }),
              onKeydown: _cache[2] || (_cache[2] = withKeys15((event) => {
                if (_ctx.disabled) return;
                if (["Enter", " "].includes(event.key)) unref237(rootContext).onMenuToggle(unref237(menuContext).value);
                if (event.key === "ArrowDown") unref237(rootContext).onMenuOpen(unref237(menuContext).value);
                if ([
                  "Enter",
                  " ",
                  "ArrowDown"
                ].includes(event.key)) {
                  unref237(menuContext).wasKeyboardTriggerOpenRef.value = true;
                  event.preventDefault();
                }
              }, [
                "enter",
                "space",
                "arrow-down"
              ])),
              onFocus: _cache[3] || (_cache[3] = ($event) => isFocused.value = true),
              onBlur: _cache[4] || (_cache[4] = ($event) => isFocused.value = false)
            }, {
              default: withCtx230(() => [renderSlot234(_ctx.$slots, "default")]),
              _: 3
            }, 8, [
              "id",
              "as",
              "as-child",
              "type",
              "aria-expanded",
              "aria-controls",
              "data-highlighted",
              "data-state",
              "data-disabled",
              "disabled",
              "data-value"
            ])]),
            _: 3
          })]),
          _: 3
        })]),
        _: 3
      }, 8, ["focusable", "tab-stop-id"]);
    };
  }
});
var MenubarTrigger_default = MenubarTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuRoot.js
import { computed as computed65, createBlock as createBlock230, createVNode as createVNode35, defineComponent as defineComponent243, openBlock as openBlock235, ref as ref66, renderSlot as renderSlot235, toRefs as toRefs30, unref as unref238, watchEffect as watchEffect14, withCtx as withCtx231 } from "vue";
var [injectNavigationMenuContext, provideNavigationMenuContext] = createContext(["NavigationMenuRoot", "NavigationMenuSub"], "NavigationMenuContext");
var NavigationMenuRoot_vue_vue_type_script_setup_true_lang_default = defineComponent243({
  __name: "NavigationMenuRoot",
  props: {
    modelValue: {
      type: String,
      required: false,
      default: void 0
    },
    defaultValue: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    delayDuration: {
      type: Number,
      required: false,
      default: 200
    },
    skipDelayDuration: {
      type: Number,
      required: false,
      default: 300
    },
    disableClickTrigger: {
      type: Boolean,
      required: false,
      default: false
    },
    disableHoverTrigger: {
      type: Boolean,
      required: false,
      default: false
    },
    disablePointerLeaveClose: {
      type: Boolean,
      required: false
    },
    unmountOnHide: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "nav"
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? "",
      passive: props2.modelValue === void 0
    });
    const previousValue = ref66("");
    const { forwardRef, currentElement: rootNavigationMenu } = useForwardExpose();
    const indicatorTrack = ref66();
    const viewport = ref66();
    const activeTrigger = ref66();
    const { getItems, CollectionSlot } = useCollection({
      key: "NavigationMenu",
      isProvider: true
    });
    const { delayDuration, skipDelayDuration, dir: propDir, disableClickTrigger, disableHoverTrigger, unmountOnHide } = toRefs30(props2);
    const dir = useDirection(propDir);
    const isDelaySkipped = refAutoReset(false, skipDelayDuration);
    const computedDelay = computed65(() => {
      const isOpen = modelValue.value !== "";
      if (isOpen || isDelaySkipped.value) return 150;
      else return delayDuration.value;
    });
    const debouncedFn = useDebounceFn((val) => {
      if (typeof val === "string") {
        previousValue.value = modelValue.value;
        modelValue.value = val;
      }
    }, computedDelay);
    watchEffect14(() => {
      if (!modelValue.value) return;
      const items = getItems().map((i) => i.ref);
      activeTrigger.value = items.find((item) => item.id.includes(modelValue.value));
    });
    provideNavigationMenuContext({
      isRootMenu: true,
      modelValue,
      previousValue,
      baseId: useId2(void 0, "reka-navigation-menu"),
      disableClickTrigger,
      disableHoverTrigger,
      dir,
      unmountOnHide,
      orientation: props2.orientation,
      rootNavigationMenu,
      indicatorTrack,
      activeTrigger,
      onIndicatorTrackChange: (val) => {
        indicatorTrack.value = val;
      },
      viewport,
      onViewportChange: (val) => {
        viewport.value = val;
      },
      onTriggerEnter: (val) => {
        debouncedFn(val);
      },
      onTriggerLeave: () => {
        isDelaySkipped.value = true;
        debouncedFn("");
      },
      onContentEnter: () => {
        debouncedFn();
      },
      onContentLeave: () => {
        if (!props2.disablePointerLeaveClose) debouncedFn("");
      },
      onItemSelect: (val) => {
        previousValue.value = modelValue.value;
        modelValue.value = val;
      },
      onItemDismiss: () => {
        previousValue.value = modelValue.value;
        modelValue.value = "";
      }
    });
    return (_ctx, _cache) => {
      return openBlock235(), createBlock230(unref238(CollectionSlot), null, {
        default: withCtx231(() => [createVNode35(unref238(Primitive), {
          ref: unref238(forwardRef),
          "aria-label": "Main",
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-orientation": _ctx.orientation,
          dir: unref238(dir),
          "data-reka-navigation-menu": ""
        }, {
          default: withCtx231(() => [renderSlot235(_ctx.$slots, "default", { modelValue: unref238(modelValue) })]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "data-orientation",
          "dir"
        ])]),
        _: 3
      });
    };
  }
});
var NavigationMenuRoot_default = NavigationMenuRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/utils.js
function getOpenState2(open) {
  return open ? "open" : "closed";
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var LINK_SELECT = "navigationMenu.linkSelect";
var EVENT_ROOT_CONTENT_DISMISS = "navigationMenu.rootContentDismiss";
function getTabbableCandidates2(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
    const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
    if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
    return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst4(candidates) {
  const previouslyFocusedElement = getActiveElement();
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return getActiveElement() !== previouslyFocusedElement;
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuItem.js
import { createBlock as createBlock231, defineComponent as defineComponent244, openBlock as openBlock236, ref as ref67, renderSlot as renderSlot236, unref as unref239, withCtx as withCtx232, withKeys as withKeys16 } from "vue";
var [injectNavigationMenuItemContext, provideNavigationMenuItemContext] = createContext("NavigationMenuItem");
var NavigationMenuItem_vue_vue_type_script_setup_true_lang_default = defineComponent244({
  __name: "NavigationMenuItem",
  props: {
    value: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "li"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const { getItems } = useCollection({ key: "NavigationMenu" });
    const context2 = injectNavigationMenuContext();
    const value = useId2(props2.value);
    const triggerRef2 = ref67();
    const focusProxyRef = ref67();
    const contentId = makeContentId(context2.baseId, value);
    let restoreContentTabOrderRef = () => ({});
    const wasEscapeCloseRef = ref67(false);
    async function handleContentEntry(side = "start") {
      const el = document.getElementById(contentId);
      if (el) {
        restoreContentTabOrderRef();
        const candidates = getTabbableCandidates2(el);
        if (candidates.length) focusFirst4(side === "start" ? candidates : candidates.reverse());
      }
    }
    function handleContentExit() {
      const el = document.getElementById(contentId);
      if (el) {
        const candidates = getTabbableCandidates2(el);
        if (candidates.length) restoreContentTabOrderRef = removeFromTabOrder(candidates);
      }
    }
    provideNavigationMenuItemContext({
      value,
      contentId,
      triggerRef: triggerRef2,
      focusProxyRef,
      wasEscapeCloseRef,
      onEntryKeyDown: handleContentEntry,
      onFocusProxyEnter: handleContentEntry,
      onContentFocusOutside: handleContentExit,
      onRootContentClose: handleContentExit
    });
    function handleClose() {
      context2.onItemDismiss();
      triggerRef2.value?.focus();
    }
    function handleKeydown(ev) {
      const currentFocus = getActiveElement();
      if (ev.keyCode === 32 || ev.key === "Enter") if (context2.modelValue.value === value) {
        handleClose();
        ev.preventDefault();
        return;
      } else {
        ev.target.click();
        ev.preventDefault();
        return;
      }
      const itemsArray = getItems().filter((i) => i.ref.parentElement?.hasAttribute("data-menu-item")).map((i) => i.ref);
      if (!itemsArray.includes(currentFocus)) return;
      const newSelectedElement = useArrowNavigation(ev, currentFocus, void 0, {
        itemsArray,
        loop: false
      });
      if (newSelectedElement) newSelectedElement?.focus();
      ev.preventDefault();
      ev.stopPropagation();
    }
    return (_ctx, _cache) => {
      return openBlock236(), createBlock231(unref239(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-menu-item": "",
        onKeydown: withKeys16(handleKeydown, [
          "up",
          "down",
          "left",
          "right",
          "home",
          "end",
          "space"
        ])
      }, {
        default: withCtx232(() => [renderSlot236(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["as-child", "as"]);
    };
  }
});
var NavigationMenuItem_default = NavigationMenuItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuContentImpl.js
import { computed as computed66, createBlock as createBlock232, defineComponent as defineComponent245, mergeProps as mergeProps95, openBlock as openBlock237, ref as ref68, renderSlot as renderSlot237, unref as unref240, watchEffect as watchEffect15, withCtx as withCtx233 } from "vue";
var NavigationMenuContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent245({
  __name: "NavigationMenuContentImpl",
  props: {
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { getItems } = useCollection({ key: "NavigationMenu" });
    const { forwardRef, currentElement } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const itemContext = injectNavigationMenuItemContext();
    const triggerId = makeTriggerId(menuContext.baseId, itemContext.value);
    const contentId = makeContentId(menuContext.baseId, itemContext.value);
    const prevMotionAttributeRef = ref68(null);
    const motionAttribute = computed66(() => {
      const values = getItems().map((i) => i.ref.id.split("trigger-")[1]);
      if (menuContext.dir.value === "rtl") values.reverse();
      const index = values.indexOf(menuContext.modelValue.value);
      const prevIndex = values.indexOf(menuContext.previousValue.value);
      const isSelected = itemContext.value === menuContext.modelValue.value;
      const wasSelected = prevIndex === values.indexOf(itemContext.value);
      if (!isSelected && !wasSelected) return prevMotionAttributeRef.value;
      const attribute = (() => {
        if (index !== prevIndex) {
          if (isSelected && prevIndex !== -1) return index > prevIndex ? "from-end" : "from-start";
          if (wasSelected && index !== -1) return index > prevIndex ? "to-start" : "to-end";
        }
        return null;
      })();
      prevMotionAttributeRef.value = attribute;
      return attribute;
    });
    function handleFocusOutside(ev) {
      emits("focusOutside", ev);
      emits("interactOutside", ev);
      const target = ev.detail.originalEvent.target;
      if (target.hasAttribute("data-navigation-menu-trigger")) ev.preventDefault();
      if (!ev.defaultPrevented) {
        itemContext.onContentFocusOutside();
        const target$1 = ev.target;
        if (menuContext.rootNavigationMenu?.value?.contains(target$1)) ev.preventDefault();
      }
    }
    function handlePointerDownOutside(ev) {
      emits("pointerDownOutside", ev);
      if (!ev.defaultPrevented) {
        const target = ev.target;
        const isTrigger = getItems().some((i) => i.ref.contains(target));
        const isRootViewport = menuContext.isRootMenu && menuContext.viewport.value?.contains(target);
        if (isTrigger || isRootViewport || !menuContext.isRootMenu) ev.preventDefault();
      }
    }
    watchEffect15((cleanupFn) => {
      const content = currentElement.value;
      if (menuContext.isRootMenu && content) {
        const handleClose = () => {
          menuContext.onItemDismiss();
          itemContext.onRootContentClose();
          if (content.contains(getActiveElement())) itemContext.triggerRef.value?.focus();
        };
        content.addEventListener(EVENT_ROOT_CONTENT_DISMISS, handleClose);
        cleanupFn(() => content.removeEventListener(EVENT_ROOT_CONTENT_DISMISS, handleClose));
      }
    });
    function handleEscapeKeyDown(ev) {
      emits("escapeKeyDown", ev);
      if (!ev.defaultPrevented) {
        menuContext.onItemDismiss();
        itemContext.triggerRef?.value?.focus();
        itemContext.wasEscapeCloseRef.value = true;
      }
    }
    function handleKeydown(ev) {
      if (ev.target.closest("[data-reka-navigation-menu]") !== menuContext.rootNavigationMenu.value) return;
      const isMetaKey = ev.altKey || ev.ctrlKey || ev.metaKey;
      const isTabKey = ev.key === "Tab" && !isMetaKey;
      const candidates = getTabbableCandidates2(ev.currentTarget);
      if (isTabKey) {
        const focusedElement = getActiveElement();
        const index = candidates.findIndex((candidate) => candidate === focusedElement);
        const isMovingBackwards = ev.shiftKey;
        const nextCandidates = isMovingBackwards ? candidates.slice(0, index).reverse() : candidates.slice(index + 1, candidates.length);
        if (focusFirst4(nextCandidates)) ev.preventDefault();
        else {
          itemContext.focusProxyRef.value?.focus();
          return;
        }
      }
      const newSelectedElement = useArrowNavigation(ev, getActiveElement(), void 0, {
        itemsArray: candidates,
        loop: false,
        enableIgnoredElement: true
      });
      newSelectedElement?.focus();
    }
    function handleDismiss() {
      const rootContentDismissEvent = new Event(EVENT_ROOT_CONTENT_DISMISS, {
        bubbles: true,
        cancelable: true
      });
      currentElement.value?.dispatchEvent(rootContentDismissEvent);
    }
    return (_ctx, _cache) => {
      return openBlock237(), createBlock232(unref240(DismissableLayer_default), mergeProps95({
        id: unref240(contentId),
        ref: unref240(forwardRef),
        "aria-labelledby": unref240(triggerId),
        "data-motion": motionAttribute.value,
        "data-state": unref240(getOpenState2)(unref240(menuContext).modelValue.value === unref240(itemContext).value),
        "data-orientation": unref240(menuContext).orientation
      }, props2, {
        onKeydown: handleKeydown,
        onEscapeKeyDown: handleEscapeKeyDown,
        onPointerDownOutside: handlePointerDownOutside,
        onFocusOutside: handleFocusOutside,
        onDismiss: handleDismiss
      }), {
        default: withCtx233(() => [renderSlot237(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "aria-labelledby",
        "data-motion",
        "data-state",
        "data-orientation"
      ]);
    };
  }
});
var NavigationMenuContentImpl_default = NavigationMenuContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuContent.js
import { Teleport as Teleport2, computed as computed67, createBlock as createBlock233, createVNode as createVNode36, defineComponent as defineComponent246, mergeProps as mergeProps96, openBlock as openBlock238, renderSlot as renderSlot238, unref as unref241, withCtx as withCtx234 } from "vue";
var NavigationMenuContent_vue_vue_type_script_setup_true_lang_default = defineComponent246({
  inheritAttrs: false,
  __name: "NavigationMenuContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    disableOutsidePointerEvents: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "escapeKeyDown",
    "pointerDownOutside",
    "focusOutside",
    "interactOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(reactiveOmit(props2, "forceMount"), emits);
    const { forwardRef } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const itemContext = injectNavigationMenuItemContext();
    const open = computed67(() => itemContext.value === menuContext.modelValue.value);
    const isLastActiveValue = computed67(() => {
      if (menuContext.viewport.value) {
        if (!menuContext.modelValue.value && menuContext.previousValue.value) return menuContext.previousValue.value === itemContext.value;
      }
      return false;
    });
    return (_ctx, _cache) => {
      return openBlock238(), createBlock233(Teleport2, {
        to: unref241(isClient) && unref241(menuContext).viewport.value ? unref241(menuContext).viewport.value : "body",
        disabled: unref241(isClient) && unref241(menuContext).viewport.value ? !unref241(menuContext).viewport.value : true
      }, [createVNode36(unref241(Presence_default), {
        present: _ctx.forceMount || open.value || isLastActiveValue.value,
        "force-mount": !unref241(menuContext).unmountOnHide.value
      }, {
        default: withCtx234(({ present }) => [createVNode36(NavigationMenuContentImpl_default, mergeProps96({
          ref: unref241(forwardRef),
          "data-state": unref241(getOpenState2)(open.value),
          style: { pointerEvents: !open.value && unref241(menuContext).isRootMenu ? "none" : void 0 }
        }, {
          ..._ctx.$attrs,
          ...unref241(forwarded)
        }, {
          hidden: !present,
          onPointerenter: _cache[0] || (_cache[0] = ($event) => unref241(menuContext).onContentEnter(unref241(itemContext).value)),
          onPointerleave: _cache[1] || (_cache[1] = ($event) => unref241(whenMouse)(() => unref241(menuContext).onContentLeave())($event)),
          onPointerDownOutside: _cache[2] || (_cache[2] = ($event) => emits("pointerDownOutside", $event)),
          onFocusOutside: _cache[3] || (_cache[3] = ($event) => emits("focusOutside", $event)),
          onInteractOutside: _cache[4] || (_cache[4] = ($event) => emits("interactOutside", $event))
        }), {
          default: withCtx234(() => [renderSlot238(_ctx.$slots, "default")]),
          _: 2
        }, 1040, [
          "data-state",
          "style",
          "hidden"
        ])]),
        _: 3
      }, 8, ["present", "force-mount"])], 8, ["to", "disabled"]);
    };
  }
});
var NavigationMenuContent_default = NavigationMenuContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuIndicator.js
import { Teleport as Teleport3, computed as computed68, createBlock as createBlock234, createCommentVNode as createCommentVNode18, createVNode as createVNode37, defineComponent as defineComponent247, mergeProps as mergeProps97, openBlock as openBlock239, ref as ref69, renderSlot as renderSlot239, unref as unref242, watchEffect as watchEffect16, withCtx as withCtx235 } from "vue";
var NavigationMenuIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent247({
  inheritAttrs: false,
  __name: "NavigationMenuIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const indicatorStyle = ref69();
    const isHorizontal = computed68(() => menuContext.orientation === "horizontal");
    const isVisible = computed68(() => !!menuContext.modelValue.value);
    const { activeTrigger } = menuContext;
    function handlePositionChange() {
      if (!activeTrigger.value) return;
      indicatorStyle.value = {
        size: isHorizontal.value ? activeTrigger.value.offsetWidth : activeTrigger.value.offsetHeight,
        position: isHorizontal.value ? activeTrigger.value.offsetLeft : activeTrigger.value.offsetTop
      };
    }
    watchEffect16(() => {
      if (!menuContext.modelValue.value) return;
      handlePositionChange();
    });
    useResizeObserver(activeTrigger, handlePositionChange);
    useResizeObserver(menuContext.indicatorTrack, handlePositionChange);
    return (_ctx, _cache) => {
      return unref242(menuContext).indicatorTrack.value ? (openBlock239(), createBlock234(Teleport3, {
        key: 0,
        to: unref242(menuContext).indicatorTrack.value
      }, [createVNode37(unref242(Presence_default), { present: _ctx.forceMount || isVisible.value }, {
        default: withCtx235(() => [createVNode37(unref242(Primitive), mergeProps97({
          ref: unref242(forwardRef),
          "aria-hidden": "true",
          "data-state": isVisible.value ? "visible" : "hidden",
          "data-orientation": unref242(menuContext).orientation,
          "as-child": props2.asChild,
          as: _ctx.as,
          style: { ...indicatorStyle.value ? {
            "--reka-navigation-menu-indicator-size": `${indicatorStyle.value.size}px`,
            "--reka-navigation-menu-indicator-position": `${indicatorStyle.value.position}px`
          } : {} }
        }, _ctx.$attrs), {
          default: withCtx235(() => [renderSlot239(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "data-state",
          "data-orientation",
          "as-child",
          "as",
          "style"
        ])]),
        _: 3
      }, 8, ["present"])], 8, ["to"])) : createCommentVNode18("v-if", true);
    };
  }
});
var NavigationMenuIndicator_default = NavigationMenuIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuLink.js
import { createBlock as createBlock235, createVNode as createVNode38, defineComponent as defineComponent248, openBlock as openBlock240, renderSlot as renderSlot240, unref as unref243, withCtx as withCtx236 } from "vue";
var NavigationMenuLink_vue_vue_type_script_setup_true_lang_default = defineComponent248({
  __name: "NavigationMenuLink",
  props: {
    active: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "a"
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { CollectionItem } = useCollection({ key: "NavigationMenu" });
    useForwardExpose();
    async function handleClick(ev) {
      const linkSelectEvent = new CustomEvent(LINK_SELECT, {
        bubbles: true,
        cancelable: true,
        detail: { originalEvent: ev }
      });
      emits("select", linkSelectEvent);
      if (!linkSelectEvent.defaultPrevented && !ev.metaKey) {
        const rootContentDismissEvent = new CustomEvent(EVENT_ROOT_CONTENT_DISMISS, {
          bubbles: true,
          cancelable: true
        });
        ev.target?.dispatchEvent(rootContentDismissEvent);
      }
    }
    return (_ctx, _cache) => {
      return openBlock240(), createBlock235(unref243(CollectionItem), null, {
        default: withCtx236(() => [createVNode38(unref243(Primitive), {
          as: _ctx.as,
          "data-active": _ctx.active ? "" : void 0,
          "aria-current": _ctx.active ? "page" : void 0,
          "as-child": props2.asChild,
          onClick: handleClick
        }, {
          default: withCtx236(() => [renderSlot240(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as",
          "data-active",
          "aria-current",
          "as-child"
        ])]),
        _: 3
      });
    };
  }
});
var NavigationMenuLink_default = NavigationMenuLink_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuList.js
import { createBlock as createBlock236, createVNode as createVNode39, defineComponent as defineComponent249, mergeProps as mergeProps98, onMounted as onMounted30, openBlock as openBlock241, renderSlot as renderSlot241, unref as unref244, withCtx as withCtx237 } from "vue";
var NavigationMenuList_vue_vue_type_script_setup_true_lang_default = defineComponent249({
  inheritAttrs: false,
  __name: "NavigationMenuList",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "ul"
    }
  },
  setup(__props) {
    const props2 = __props;
    const menuContext = injectNavigationMenuContext();
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted30(() => {
      menuContext.onIndicatorTrackChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock241(), createBlock236(unref244(Primitive), {
        ref: unref244(forwardRef),
        style: { "position": "relative" }
      }, {
        default: withCtx237(() => [createVNode39(unref244(Primitive), mergeProps98(_ctx.$attrs, {
          "as-child": props2.asChild,
          as: _ctx.as,
          "data-orientation": unref244(menuContext).orientation
        }), {
          default: withCtx237(() => [renderSlot241(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "as-child",
          "as",
          "data-orientation"
        ])]),
        _: 3
      }, 512);
    };
  }
});
var NavigationMenuList_default = NavigationMenuList_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuSub.js
import { createBlock as createBlock237, createVNode as createVNode40, defineComponent as defineComponent250, openBlock as openBlock242, ref as ref70, renderSlot as renderSlot242, unref as unref245, watchEffect as watchEffect17, withCtx as withCtx238 } from "vue";
var NavigationMenuSub_vue_vue_type_script_setup_true_lang_default = defineComponent250({
  __name: "NavigationMenuSub",
  props: {
    modelValue: {
      type: String,
      required: false
    },
    defaultValue: {
      type: String,
      required: false
    },
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? "",
      passive: props2.modelValue === void 0
    });
    const previousValue = ref70("");
    const menuContext = injectNavigationMenuContext();
    const { forwardRef, currentElement } = useForwardExpose();
    const indicatorTrack = ref70();
    const viewport = ref70();
    const activeTrigger = ref70();
    const { getItems, CollectionSlot } = useCollection({
      key: "NavigationMenu",
      isProvider: true
    });
    watchEffect17(() => {
      if (!modelValue.value) return;
      const items = getItems().map((i) => i.ref);
      activeTrigger.value = items.find((item) => item.id.includes(modelValue.value));
    });
    provideNavigationMenuContext({
      ...menuContext,
      isRootMenu: false,
      modelValue,
      previousValue,
      activeTrigger,
      orientation: props2.orientation,
      rootNavigationMenu: currentElement,
      indicatorTrack,
      onIndicatorTrackChange: (val) => {
        indicatorTrack.value = val;
      },
      viewport,
      onViewportChange: (val) => {
        viewport.value = val;
      },
      onTriggerEnter: (val) => {
        modelValue.value = val;
      },
      onTriggerLeave: () => {
      },
      onContentEnter: () => {
      },
      onContentLeave: () => {
      },
      onItemSelect: (val) => {
        modelValue.value = val;
      },
      onItemDismiss: () => {
        modelValue.value = "";
      }
    });
    return (_ctx, _cache) => {
      return openBlock242(), createBlock237(unref245(CollectionSlot), null, {
        default: withCtx238(() => [createVNode40(unref245(Primitive), {
          ref: unref245(forwardRef),
          "data-orientation": _ctx.orientation,
          "as-child": props2.asChild,
          as: _ctx.as,
          "data-reka-navigation-menu": ""
        }, {
          default: withCtx238(() => [renderSlot242(_ctx.$slots, "default", { modelValue: unref245(modelValue) })]),
          _: 3
        }, 8, [
          "data-orientation",
          "as-child",
          "as"
        ])]),
        _: 3
      });
    };
  }
});
var NavigationMenuSub_default = NavigationMenuSub_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuTrigger.js
import { Fragment as Fragment7, computed as computed69, createCommentVNode as createCommentVNode19, createElementBlock as createElementBlock9, createVNode as createVNode41, defineComponent as defineComponent251, mergeProps as mergeProps99, onMounted as onMounted31, openBlock as openBlock243, ref as ref71, renderSlot as renderSlot243, unref as unref246, withCtx as withCtx239 } from "vue";
var _hoisted_14 = ["aria-owns"];
var NavigationMenuTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent251({
  inheritAttrs: false,
  __name: "NavigationMenuTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const menuContext = injectNavigationMenuContext();
    const itemContext = injectNavigationMenuItemContext();
    const { CollectionItem } = useCollection({ key: "NavigationMenu" });
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const triggerId = ref71("");
    const contentId = ref71("");
    const hasPointerMoveOpenedRef = refAutoReset(false, 300);
    const wasClickCloseRef = ref71(false);
    const open = computed69(() => itemContext.value === menuContext.modelValue.value);
    onMounted31(() => {
      itemContext.triggerRef = triggerElement;
      triggerId.value = makeTriggerId(menuContext.baseId, itemContext.value);
      contentId.value = makeContentId(menuContext.baseId, itemContext.value);
    });
    function handlePointerEnter() {
      if (menuContext.disableHoverTrigger.value) return;
      wasClickCloseRef.value = false;
      itemContext.wasEscapeCloseRef.value = false;
    }
    function handlePointerMove2(ev) {
      if (menuContext.disableHoverTrigger.value) return;
      if (ev.pointerType === "mouse") {
        if (props2.disabled || wasClickCloseRef.value || itemContext.wasEscapeCloseRef.value || hasPointerMoveOpenedRef.value) return;
        menuContext.onTriggerEnter(itemContext.value);
        hasPointerMoveOpenedRef.value = true;
      }
    }
    function handlePointerLeave(ev) {
      if (menuContext.disableHoverTrigger.value) return;
      if (ev.pointerType === "mouse") {
        if (props2.disabled) return;
        menuContext.onTriggerLeave();
        hasPointerMoveOpenedRef.value = false;
      }
    }
    function handleClick(event) {
      if (event.pointerType === "mouse" && menuContext.disableClickTrigger.value) return;
      if (hasPointerMoveOpenedRef.value) return;
      if (open.value) menuContext.onItemSelect("");
      else menuContext.onItemSelect(itemContext.value);
      wasClickCloseRef.value = open.value;
    }
    function handleKeydown(ev) {
      const verticalEntryKey = menuContext.dir.value === "rtl" ? "ArrowLeft" : "ArrowRight";
      const entryKey = {
        horizontal: "ArrowDown",
        vertical: verticalEntryKey
      }[menuContext.orientation];
      if (open.value && ev.key === entryKey) {
        itemContext.onEntryKeyDown();
        ev.preventDefault();
        ev.stopPropagation();
      }
    }
    function setFocusProxyRef(node) {
      itemContext.focusProxyRef.value = unrefElement(node);
      return void 0;
    }
    function handleVisuallyHiddenFocus(ev) {
      const content = document.getElementById(itemContext.contentId);
      const prevFocusedElement = ev.relatedTarget;
      const wasTriggerFocused = prevFocusedElement === triggerElement.value;
      const wasFocusFromContent = content?.contains(prevFocusedElement);
      if (wasTriggerFocused || !wasFocusFromContent) itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
    }
    return (_ctx, _cache) => {
      return openBlock243(), createElementBlock9(Fragment7, null, [createVNode41(unref246(CollectionItem), null, {
        default: withCtx239(() => [createVNode41(unref246(Primitive), mergeProps99({
          id: triggerId.value,
          ref: unref246(forwardRef),
          disabled: _ctx.disabled,
          "data-disabled": _ctx.disabled ? "" : void 0,
          "data-state": unref246(getOpenState2)(open.value),
          "data-navigation-menu-trigger": "",
          "aria-expanded": open.value,
          "aria-controls": contentId.value,
          "as-child": props2.asChild,
          as: _ctx.as
        }, _ctx.$attrs, {
          onPointerenter: handlePointerEnter,
          onPointermove: handlePointerMove2,
          onPointerleave: handlePointerLeave,
          onClick: handleClick,
          onKeydown: handleKeydown
        }), {
          default: withCtx239(() => [renderSlot243(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "id",
          "disabled",
          "data-disabled",
          "data-state",
          "aria-expanded",
          "aria-controls",
          "as-child",
          "as"
        ])]),
        _: 3
      }), open.value ? (openBlock243(), createElementBlock9(Fragment7, { key: 0 }, [createVNode41(unref246(VisuallyHidden_default), {
        ref: setFocusProxyRef,
        "aria-hidden": "true",
        tabindex: 0,
        onFocus: handleVisuallyHiddenFocus
      }), unref246(menuContext).viewport ? (openBlock243(), createElementBlock9("span", {
        key: 0,
        "aria-owns": contentId.value
      }, null, 8, _hoisted_14)) : createCommentVNode19("v-if", true)], 64)) : createCommentVNode19("v-if", true)], 64);
    };
  }
});
var NavigationMenuTrigger_default = NavigationMenuTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NavigationMenu/NavigationMenuViewport.js
import { computed as computed70, createBlock as createBlock238, createVNode as createVNode42, defineComponent as defineComponent252, mergeProps as mergeProps100, nextTick as nextTick25, openBlock as openBlock244, ref as ref72, renderSlot as renderSlot244, unref as unref247, watch as watch26, withCtx as withCtx240 } from "vue";
var NavigationMenuViewport_vue_vue_type_script_setup_true_lang_default = defineComponent252({
  inheritAttrs: false,
  __name: "NavigationMenuViewport",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    align: {
      type: String,
      required: false,
      default: "center"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const menuContext = injectNavigationMenuContext();
    const { activeTrigger, rootNavigationMenu, modelValue } = menuContext;
    const size3 = ref72();
    const position = ref72();
    const open = computed70(() => !!menuContext.modelValue.value);
    watch26(currentElement, () => {
      menuContext.onViewportChange(currentElement.value);
    });
    const content = ref72();
    watch26([modelValue, open], () => {
      nextTick25(() => {
        if (!currentElement.value) return;
        requestAnimationFrame(() => {
          const el = currentElement.value?.querySelector("[data-state=open]");
          content.value = el;
        });
      });
    }, { immediate: true });
    function updatePosition() {
      if (content.value && activeTrigger.value && rootNavigationMenu.value) {
        const bodyWidth = document.documentElement.offsetWidth;
        const bodyHeight = document.documentElement.offsetHeight;
        const rootRect = rootNavigationMenu.value.getBoundingClientRect();
        const rect = activeTrigger.value.getBoundingClientRect();
        const { offsetWidth, offsetHeight } = content.value;
        const startPositionLeft = rect.left - rootRect.left;
        const startPositionTop = rect.top - rootRect.top;
        let posLeft = null;
        let posTop = null;
        switch (props2.align) {
          case "start":
            posLeft = startPositionLeft;
            posTop = startPositionTop;
            break;
          case "end":
            posLeft = startPositionLeft - offsetWidth + rect.width;
            posTop = startPositionTop - offsetHeight + rect.height;
            break;
          default:
            posLeft = startPositionLeft - offsetWidth / 2 + rect.width / 2;
            posTop = startPositionTop - offsetHeight / 2 + rect.height / 2;
        }
        const screenOffset = 10;
        if (posLeft + rootRect.left < screenOffset) posLeft = screenOffset - rootRect.left;
        const rightOffset = posLeft + rootRect.left + offsetWidth;
        if (rightOffset > bodyWidth - screenOffset) {
          posLeft -= rightOffset - bodyWidth + screenOffset;
          if (posLeft < screenOffset - rootRect.left) posLeft = screenOffset - rootRect.left;
        }
        if (posTop + rootRect.top < screenOffset) posTop = screenOffset - rootRect.top;
        const bottomOffset = posTop + rootRect.top + offsetHeight;
        if (bottomOffset > bodyHeight - screenOffset) {
          posTop -= bottomOffset - bodyHeight + screenOffset;
          if (posTop < screenOffset - rootRect.top) posTop = screenOffset - rootRect.top;
        }
        posLeft = Math.round(posLeft);
        posTop = Math.round(posTop);
        position.value = {
          left: posLeft,
          top: posTop
        };
      }
    }
    useResizeObserver(content, () => {
      if (content.value) {
        size3.value = {
          width: content.value.offsetWidth,
          height: content.value.offsetHeight
        };
        updatePosition();
      }
    });
    useResizeObserver([globalThis.document?.body, rootNavigationMenu], () => {
      updatePosition();
    });
    return (_ctx, _cache) => {
      return openBlock244(), createBlock238(unref247(Presence_default), {
        present: _ctx.forceMount || open.value,
        "force-mount": !unref247(menuContext).unmountOnHide.value,
        onAfterLeave: _cache[2] || (_cache[2] = () => {
          size3.value = void 0;
          position.value = void 0;
        })
      }, {
        default: withCtx240(({ present }) => [createVNode42(unref247(Primitive), mergeProps100(_ctx.$attrs, {
          ref: unref247(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-state": unref247(getOpenState2)(open.value),
          "data-orientation": unref247(menuContext).orientation,
          style: {
            pointerEvents: !open.value && unref247(menuContext).isRootMenu ? "none" : void 0,
            ["--reka-navigation-menu-viewport-width"]: size3.value ? `${size3.value?.width}px` : void 0,
            ["--reka-navigation-menu-viewport-height"]: size3.value ? `${size3.value?.height}px` : void 0,
            ["--reka-navigation-menu-viewport-left"]: position.value ? `${position.value?.left}px` : void 0,
            ["--reka-navigation-menu-viewport-top"]: position.value ? `${position.value?.top}px` : void 0
          },
          hidden: !present,
          onPointerenter: _cache[0] || (_cache[0] = ($event) => unref247(menuContext).onContentEnter(unref247(menuContext).modelValue.value)),
          onPointerleave: _cache[1] || (_cache[1] = ($event) => unref247(whenMouse)(() => unref247(menuContext).onContentLeave())($event))
        }), {
          default: withCtx240(() => [renderSlot244(_ctx.$slots, "default")]),
          _: 2
        }, 1040, [
          "as",
          "as-child",
          "data-state",
          "data-orientation",
          "style",
          "hidden"
        ])]),
        _: 3
      }, 8, ["present", "force-mount"]);
    };
  }
});
var NavigationMenuViewport_default = NavigationMenuViewport_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NumberField/utils.js
import { computed as computed71, ref as ref73 } from "vue";

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      fullySanitizedValue = fullySanitizedValue.replace("+", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.symbols.group === "’" && value.includes("'")) value = $6c7bd7858deea686$var$replaceAll(value, "'", this.symbols.group);
    if (this.options.locale === "fr-FR" && this.symbols.group) {
      value = $6c7bd7858deea686$var$replaceAll(value, " ", this.symbols.group);
      value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
    }
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    if (options.roundingIncrement !== 1 && options.roundingIncrement != null) {
      if (options.maximumFractionDigits == null && options.minimumFractionDigits == null) {
        options.maximumFractionDigits = 0;
        options.minimumFractionDigits = 0;
      } else if (options.maximumFractionDigits == null) options.maximumFractionDigits = options.minimumFractionDigits;
      else if (options.minimumFractionDigits == null) options.minimumFractionDigits = options.maximumFractionDigits;
    }
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b) => b.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
  if (str.replaceAll) return str.replaceAll(find, replace);
  return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/reka-ui/dist/NumberField/utils.js
function usePressedHold(options) {
  const { disabled } = options;
  const timeout = ref73();
  const triggerHook = createEventHook();
  const resetTimeout = () => window.clearTimeout(timeout.value);
  const onIncrementPressStart = (delay) => {
    resetTimeout();
    if (disabled.value) return;
    triggerHook.trigger();
    timeout.value = window.setTimeout(() => {
      onIncrementPressStart(60);
    }, delay);
  };
  const handlePressStart = () => {
    onIncrementPressStart(400);
  };
  const handlePressEnd = () => {
    resetTimeout();
  };
  const isPressed = ref73(false);
  const target = computed71(() => unrefElement(options.target));
  const onPressStart = (event) => {
    if (event.button !== 0 || isPressed.value) return;
    event.preventDefault();
    isPressed.value = true;
    handlePressStart();
  };
  const onPressRelease = () => {
    isPressed.value = false;
    handlePressEnd();
  };
  if (isClient) {
    useEventListener(target || window, "pointerdown", onPressStart);
    useEventListener(window, "pointerup", onPressRelease);
    useEventListener(window, "pointercancel", onPressRelease);
  }
  return {
    isPressed,
    onTrigger: triggerHook.on
  };
}
function useNumberFormatter(locale, options = ref73({})) {
  return reactiveComputed(() => new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(locale.value, options.value));
}
function useNumberParser(locale, options = ref73({})) {
  return reactiveComputed(() => new $6c7bd7858deea686$export$cd11ab140839f11d(locale.value, options.value));
}
function handleDecimalOperation(operator, value1, value2) {
  let result = operator === "+" ? value1 + value2 : value1 - value2;
  if (value1 % 1 !== 0 || value2 % 1 !== 0) {
    const value1Decimal = value1.toString().split(".");
    const value2Decimal = value2.toString().split(".");
    const value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;
    const value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;
    const multiplier = 10 ** Math.max(value1DecimalLength, value2DecimalLength);
    value1 = Math.round(value1 * multiplier);
    value2 = Math.round(value2 * multiplier);
    result = operator === "+" ? value1 + value2 : value1 - value2;
    result /= multiplier;
  }
  return result;
}

// node_modules/reka-ui/dist/NumberField/NumberFieldRoot.js
import { computed as computed72, createBlock as createBlock239, createCommentVNode as createCommentVNode20, defineComponent as defineComponent253, mergeProps as mergeProps101, openBlock as openBlock245, ref as ref74, renderSlot as renderSlot245, toRefs as toRefs31, unref as unref248, withCtx as withCtx241 } from "vue";
var [injectNumberFieldRootContext, provideNumberFieldRootContext] = createContext("NumberFieldRoot");
var NumberFieldRoot_vue_vue_type_script_setup_true_lang_default = defineComponent253({
  inheritAttrs: false,
  __name: "NumberFieldRoot",
  props: {
    defaultValue: {
      type: Number,
      required: false,
      default: void 0
    },
    modelValue: {
      type: [Number, null],
      required: false
    },
    min: {
      type: Number,
      required: false
    },
    max: {
      type: Number,
      required: false
    },
    step: {
      type: Number,
      required: false,
      default: 1
    },
    stepSnapping: {
      type: Boolean,
      required: false,
      default: true
    },
    formatOptions: {
      type: null,
      required: false
    },
    locale: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    readonly: {
      type: Boolean,
      required: false
    },
    disableWheelChange: {
      type: Boolean,
      required: false
    },
    invertWheelChange: {
      type: Boolean,
      required: false
    },
    id: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, disableWheelChange, invertWheelChange, min: min2, max: max2, step, stepSnapping, formatOptions, id, locale: propLocale } = toRefs31(props2);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const locale = useLocale(propLocale);
    const isFormControl = useFormControl(currentElement);
    const inputEl = ref74();
    const isDecreaseDisabled = computed72(() => !isNullish(modelValue.value) && (clampInputValue(modelValue.value) === min2.value || min2.value && !isNaN(modelValue.value) ? handleDecimalOperation("-", modelValue.value, step.value) < min2.value : false));
    const isIncreaseDisabled = computed72(() => !isNullish(modelValue.value) && (clampInputValue(modelValue.value) === max2.value || max2.value && !isNaN(modelValue.value) ? handleDecimalOperation("+", modelValue.value, step.value) > max2.value : false));
    function handleChangingValue(type, multiplier = 1) {
      inputEl.value?.focus();
      if (props2.disabled || props2.readonly) return;
      const currentInputValue = numberParser.parse(inputEl.value?.value ?? "");
      if (isNaN(currentInputValue)) modelValue.value = min2.value ?? 0;
      else if (type === "increase") modelValue.value = clampInputValue(currentInputValue + (step.value ?? 1) * multiplier);
      else modelValue.value = clampInputValue(currentInputValue - (step.value ?? 1) * multiplier);
    }
    function handleIncrease(multiplier = 1) {
      handleChangingValue("increase", multiplier);
    }
    function handleDecrease(multiplier = 1) {
      handleChangingValue("decrease", multiplier);
    }
    function handleMinMaxValue(type) {
      if (type === "min" && min2.value !== void 0) modelValue.value = clampInputValue(min2.value);
      else if (type === "max" && max2.value !== void 0) modelValue.value = clampInputValue(max2.value);
    }
    const numberFormatter = useNumberFormatter(locale, formatOptions);
    const numberParser = useNumberParser(locale, formatOptions);
    const inputMode = computed72(() => {
      const hasDecimals = numberFormatter.resolvedOptions().maximumFractionDigits > 0;
      return hasDecimals ? "decimal" : "numeric";
    });
    const textValueFormatter = useNumberFormatter(locale, formatOptions);
    const textValue = computed72(() => isNullish(modelValue.value) || isNaN(modelValue.value) ? "" : textValueFormatter.format(modelValue.value));
    function validate(val) {
      return numberParser.isValidPartialNumber(val, min2.value, max2.value);
    }
    function setInputValue(val) {
      if (inputEl.value) inputEl.value.value = val;
    }
    function clampInputValue(val) {
      let clampedValue;
      if (step.value === void 0 || isNaN(step.value) || !stepSnapping.value) clampedValue = clamp(val, min2.value, max2.value);
      else clampedValue = snapValueToStep(val, min2.value, max2.value, step.value);
      clampedValue = numberParser.parse(numberFormatter.format(clampedValue));
      return clampedValue;
    }
    function applyInputValue(val) {
      const parsedValue = numberParser.parse(val);
      modelValue.value = isNaN(parsedValue) ? void 0 : clampInputValue(parsedValue);
      if (!val.length) return setInputValue(val);
      if (isNaN(parsedValue)) return setInputValue(textValue.value);
      return setInputValue(textValue.value);
    }
    provideNumberFieldRootContext({
      modelValue,
      handleDecrease,
      handleIncrease,
      handleMinMaxValue,
      inputMode,
      inputEl,
      onInputElement: (el) => inputEl.value = el,
      textValue,
      validate,
      applyInputValue,
      disabled,
      readonly: readonly3,
      disableWheelChange,
      invertWheelChange,
      max: max2,
      min: min2,
      isDecreaseDisabled,
      isIncreaseDisabled,
      id
    });
    return (_ctx, _cache) => {
      return openBlock245(), createBlock239(unref248(Primitive), mergeProps101(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-disabled": unref248(disabled) ? "" : void 0,
        "data-readonly": unref248(readonly3) ? "" : void 0
      }), {
        default: withCtx241(() => [renderSlot245(_ctx.$slots, "default", {
          modelValue: unref248(modelValue),
          textValue: textValue.value
        }), unref248(isFormControl) && _ctx.name ? (openBlock245(), createBlock239(unref248(VisuallyHiddenInput_default), {
          key: 0,
          type: "text",
          value: unref248(modelValue),
          name: _ctx.name,
          disabled: unref248(disabled),
          readonly: unref248(readonly3),
          required: _ctx.required
        }, null, 8, [
          "value",
          "name",
          "disabled",
          "readonly",
          "required"
        ])) : createCommentVNode20("v-if", true)]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "data-disabled",
        "data-readonly"
      ]);
    };
  }
});
var NumberFieldRoot_default = NumberFieldRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NumberField/NumberFieldDecrement.js
import { computed as computed73, createBlock as createBlock240, defineComponent as defineComponent254, mergeProps as mergeProps102, openBlock as openBlock246, renderSlot as renderSlot246, unref as unref249, withCtx as withCtx242, withModifiers as withModifiers12 } from "vue";
var NumberFieldDecrement_vue_vue_type_script_setup_true_lang_default = defineComponent254({
  __name: "NumberFieldDecrement",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectNumberFieldRootContext();
    const isDisabled = computed73(() => rootContext.disabled?.value || rootContext.readonly.value || props2.disabled || rootContext.isDecreaseDisabled.value);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const { isPressed, onTrigger } = usePressedHold({
      target: currentElement,
      disabled: isDisabled
    });
    onTrigger(() => {
      rootContext.handleDecrease();
    });
    return (_ctx, _cache) => {
      return openBlock246(), createBlock240(unref249(Primitive), mergeProps102(props2, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        tabindex: "-1",
        "aria-label": "Decrease",
        type: _ctx.as === "button" ? "button" : void 0,
        style: { userSelect: unref249(isPressed) ? "none" : void 0 },
        disabled: isDisabled.value ? "" : void 0,
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-pressed": unref249(isPressed) ? "true" : void 0,
        onContextmenu: _cache[0] || (_cache[0] = withModifiers12(() => {
        }, ["prevent"]))
      }), {
        default: withCtx242(() => [renderSlot246(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "type",
        "style",
        "disabled",
        "data-disabled",
        "data-pressed"
      ]);
    };
  }
});
var NumberFieldDecrement_default = NumberFieldDecrement_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NumberField/NumberFieldIncrement.js
import { computed as computed74, createBlock as createBlock241, defineComponent as defineComponent255, mergeProps as mergeProps103, openBlock as openBlock247, renderSlot as renderSlot247, unref as unref250, withCtx as withCtx243, withModifiers as withModifiers13 } from "vue";
var NumberFieldIncrement_vue_vue_type_script_setup_true_lang_default = defineComponent255({
  __name: "NumberFieldIncrement",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectNumberFieldRootContext();
    const isDisabled = computed74(() => rootContext.disabled?.value || rootContext.readonly.value || props2.disabled || rootContext.isIncreaseDisabled.value);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const { isPressed, onTrigger } = usePressedHold({
      target: currentElement,
      disabled: isDisabled
    });
    onTrigger(() => {
      rootContext.handleIncrease();
    });
    return (_ctx, _cache) => {
      return openBlock247(), createBlock241(unref250(Primitive), mergeProps103(props2, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        tabindex: "-1",
        "aria-label": "Increase",
        type: _ctx.as === "button" ? "button" : void 0,
        style: { userSelect: unref250(isPressed) ? "none" : void 0 },
        disabled: isDisabled.value ? "" : void 0,
        "data-disabled": isDisabled.value ? "" : void 0,
        "data-pressed": unref250(isPressed) ? "true" : void 0,
        onContextmenu: _cache[0] || (_cache[0] = withModifiers13(() => {
        }, ["prevent"]))
      }), {
        default: withCtx243(() => [renderSlot247(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "type",
        "style",
        "disabled",
        "data-disabled",
        "data-pressed"
      ]);
    };
  }
});
var NumberFieldIncrement_default = NumberFieldIncrement_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/NumberField/NumberFieldInput.js
import { createBlock as createBlock242, defineComponent as defineComponent256, mergeProps as mergeProps104, onMounted as onMounted32, openBlock as openBlock248, ref as ref75, renderSlot as renderSlot248, unref as unref251, watch as watch27, withCtx as withCtx244, withKeys as withKeys17, withModifiers as withModifiers14 } from "vue";
var NumberFieldInput_vue_vue_type_script_setup_true_lang_default = defineComponent256({
  __name: "NumberFieldInput",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "input"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { primitiveElement, currentElement } = usePrimitiveElement();
    const rootContext = injectNumberFieldRootContext();
    function handleWheelEvent(event) {
      if (rootContext.disableWheelChange.value) return;
      if (event.target !== getActiveElement()) return;
      if (Math.abs(event.deltaY) <= Math.abs(event.deltaX)) return;
      event.preventDefault();
      if (event.deltaY > 0) rootContext.invertWheelChange.value ? rootContext.handleDecrease() : rootContext.handleIncrease();
      else if (event.deltaY < 0) rootContext.invertWheelChange.value ? rootContext.handleIncrease() : rootContext.handleDecrease();
    }
    onMounted32(() => {
      rootContext.onInputElement(currentElement.value);
    });
    const inputValue = ref75(rootContext.textValue.value);
    watch27(() => rootContext.textValue.value, () => {
      inputValue.value = rootContext.textValue.value;
    }, {
      immediate: true,
      deep: true
    });
    function handleChange() {
      requestAnimationFrame(() => {
        inputValue.value = rootContext.textValue.value;
      });
    }
    return (_ctx, _cache) => {
      return openBlock248(), createBlock242(unref251(Primitive), mergeProps104(props2, {
        id: unref251(rootContext).id.value,
        ref_key: "primitiveElement",
        ref: primitiveElement,
        value: inputValue.value,
        role: "spinbutton",
        type: "text",
        tabindex: "0",
        inputmode: unref251(rootContext).inputMode.value,
        disabled: unref251(rootContext).disabled.value ? "" : void 0,
        "data-disabled": unref251(rootContext).disabled.value ? "" : void 0,
        readonly: unref251(rootContext).readonly.value ? "" : void 0,
        "data-readonly": unref251(rootContext).readonly.value ? "" : void 0,
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: "false",
        "aria-roledescription": "Number field",
        "aria-valuenow": unref251(rootContext).modelValue.value,
        "aria-valuemin": unref251(rootContext).min.value,
        "aria-valuemax": unref251(rootContext).max.value,
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys17(withModifiers14(($event) => unref251(rootContext).handleIncrease(), ["prevent"]), ["up"])),
          _cache[1] || (_cache[1] = withKeys17(withModifiers14(($event) => unref251(rootContext).handleDecrease(), ["prevent"]), ["down"])),
          _cache[2] || (_cache[2] = withKeys17(withModifiers14(($event) => unref251(rootContext).handleIncrease(10), ["prevent"]), ["page-up"])),
          _cache[3] || (_cache[3] = withKeys17(withModifiers14(($event) => unref251(rootContext).handleDecrease(10), ["prevent"]), ["page-down"])),
          _cache[4] || (_cache[4] = withKeys17(withModifiers14(($event) => unref251(rootContext).handleMinMaxValue("min"), ["prevent"]), ["home"])),
          _cache[5] || (_cache[5] = withKeys17(withModifiers14(($event) => unref251(rootContext).handleMinMaxValue("max"), ["prevent"]), ["end"])),
          _cache[8] || (_cache[8] = withKeys17(($event) => unref251(rootContext).applyInputValue($event.target?.value), ["enter"]))
        ],
        onWheel: handleWheelEvent,
        onBeforeinput: _cache[6] || (_cache[6] = (event) => {
          const target = event.target;
          let nextValue = target.value.slice(0, target.selectionStart ?? void 0) + (event.data ?? "") + target.value.slice(target.selectionEnd ?? void 0);
          if (!unref251(rootContext).validate(nextValue)) event.preventDefault();
        }),
        onInput: _cache[7] || (_cache[7] = (event) => {
          const target = event.target;
          inputValue.value = target.value;
        }),
        onChange: handleChange,
        onBlur: _cache[9] || (_cache[9] = ($event) => unref251(rootContext).applyInputValue($event.target?.value))
      }), {
        default: withCtx244(() => [renderSlot248(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "id",
        "value",
        "inputmode",
        "disabled",
        "data-disabled",
        "readonly",
        "data-readonly",
        "aria-valuenow",
        "aria-valuemin",
        "aria-valuemax"
      ]);
    };
  }
});
var NumberFieldInput_default = NumberFieldInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/PaginationEllipsis.js
import { createBlock as createBlock243, createTextVNode as createTextVNode18, defineComponent as defineComponent257, mergeProps as mergeProps105, openBlock as openBlock249, renderSlot as renderSlot249, unref as unref252, withCtx as withCtx245 } from "vue";
var PaginationEllipsis_vue_vue_type_script_setup_true_lang_default = defineComponent257({
  __name: "PaginationEllipsis",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock249(), createBlock243(unref252(Primitive), mergeProps105(props2, { "data-type": "ellipsis" }), {
        default: withCtx245(() => [renderSlot249(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createTextVNode18("…"))])]),
        _: 3
      }, 16);
    };
  }
});
var PaginationEllipsis_default = PaginationEllipsis_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/PaginationRoot.js
import { computed as computed75, createBlock as createBlock244, defineComponent as defineComponent258, openBlock as openBlock250, renderSlot as renderSlot250, toRefs as toRefs32, unref as unref253, withCtx as withCtx246 } from "vue";
var [injectPaginationRootContext, providePaginationRootContext] = createContext("PaginationRoot");
var PaginationRoot_vue_vue_type_script_setup_true_lang_default = defineComponent258({
  __name: "PaginationRoot",
  props: {
    page: {
      type: Number,
      required: false
    },
    defaultPage: {
      type: Number,
      required: false,
      default: 1
    },
    itemsPerPage: {
      type: Number,
      required: true
    },
    total: {
      type: Number,
      required: false,
      default: 0
    },
    siblingCount: {
      type: Number,
      required: false,
      default: 2
    },
    disabled: {
      type: Boolean,
      required: false
    },
    showEdges: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "nav"
    }
  },
  emits: ["update:page"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { siblingCount, disabled, showEdges } = toRefs32(props2);
    useForwardExpose();
    const page = useVModel(props2, "page", emits, {
      defaultValue: props2.defaultPage,
      passive: props2.page === void 0
    });
    const pageCount = computed75(() => Math.max(1, Math.ceil(props2.total / (props2.itemsPerPage || 1))));
    providePaginationRootContext({
      page,
      onPageChange(value) {
        page.value = value;
      },
      pageCount,
      siblingCount,
      disabled,
      showEdges
    });
    return (_ctx, _cache) => {
      return openBlock250(), createBlock244(unref253(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx246(() => [renderSlot250(_ctx.$slots, "default", {
          page: unref253(page),
          pageCount: pageCount.value
        })]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});
var PaginationRoot_default = PaginationRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/PaginationFirst.js
import { computed as computed76, createBlock as createBlock245, createTextVNode as createTextVNode19, defineComponent as defineComponent259, mergeProps as mergeProps106, openBlock as openBlock251, renderSlot as renderSlot251, unref as unref254, withCtx as withCtx247 } from "vue";
var PaginationFirst_vue_vue_type_script_setup_true_lang_default = defineComponent259({
  __name: "PaginationFirst",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectPaginationRootContext();
    useForwardExpose();
    const disabled = computed76(() => rootContext.page.value === 1 || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock251(), createBlock245(unref254(Primitive), mergeProps106(props2, {
        "aria-label": "First Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref254(rootContext).onPageChange(1))
      }), {
        default: withCtx247(() => [renderSlot251(_ctx.$slots, "default", {}, () => [_cache[1] || (_cache[1] = createTextVNode19("First page"))])]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});
var PaginationFirst_default = PaginationFirst_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/PaginationLast.js
import { computed as computed77, createBlock as createBlock246, createTextVNode as createTextVNode20, defineComponent as defineComponent260, mergeProps as mergeProps107, openBlock as openBlock252, renderSlot as renderSlot252, unref as unref255, withCtx as withCtx248 } from "vue";
var PaginationLast_vue_vue_type_script_setup_true_lang_default = defineComponent260({
  __name: "PaginationLast",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectPaginationRootContext();
    useForwardExpose();
    const disabled = computed77(() => rootContext.page.value === rootContext.pageCount.value || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock252(), createBlock246(unref255(Primitive), mergeProps107(props2, {
        "aria-label": "Last Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref255(rootContext).onPageChange(unref255(rootContext).pageCount.value))
      }), {
        default: withCtx248(() => [renderSlot252(_ctx.$slots, "default", {}, () => [_cache[1] || (_cache[1] = createTextVNode20("Last page"))])]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});
var PaginationLast_default = PaginationLast_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/utils.js
function range(start, end) {
  const length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
}
function transform(items) {
  return items.map((value) => {
    if (typeof value === "number") return {
      type: "page",
      value
    };
    return { type: "ellipsis" };
  });
}
var ELLIPSIS = "ellipsis";
function getRange(currentPage, pageCount, siblingCount, showEdges) {
  const firstPageIndex = 1;
  const lastPageIndex = pageCount;
  const leftSiblingIndex = Math.max(currentPage - siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(currentPage + siblingCount, lastPageIndex);
  if (showEdges) {
    const totalPageNumbers = Math.min(2 * siblingCount + 5, pageCount);
    const itemCount = totalPageNumbers - 2;
    const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 2 && Math.abs(lastPageIndex - itemCount - firstPageIndex + 1) > 2 && Math.abs(leftSiblingIndex - firstPageIndex) > 2;
    const showRightEllipsis = rightSiblingIndex < lastPageIndex - 2 && Math.abs(lastPageIndex - itemCount) > 2 && Math.abs(lastPageIndex - rightSiblingIndex) > 2;
    if (!showLeftEllipsis && showRightEllipsis) {
      const leftRange = range(1, itemCount);
      return [
        ...leftRange,
        ELLIPSIS,
        lastPageIndex
      ];
    }
    if (showLeftEllipsis && !showRightEllipsis) {
      const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
      return [
        firstPageIndex,
        ELLIPSIS,
        ...rightRange
      ];
    }
    if (showLeftEllipsis && showRightEllipsis) {
      const middleRange = range(leftSiblingIndex, rightSiblingIndex);
      return [
        firstPageIndex,
        ELLIPSIS,
        ...middleRange,
        ELLIPSIS,
        lastPageIndex
      ];
    }
    const fullRange = range(firstPageIndex, lastPageIndex);
    return fullRange;
  } else {
    const itemCount = siblingCount * 2 + 1;
    if (pageCount < itemCount) return range(1, lastPageIndex);
    else if (currentPage <= siblingCount + 1) return range(firstPageIndex, itemCount);
    else if (pageCount - currentPage <= siblingCount) return range(pageCount - itemCount + 1, lastPageIndex);
    else return range(leftSiblingIndex, rightSiblingIndex);
  }
}

// node_modules/reka-ui/dist/Pagination/PaginationList.js
import { computed as computed78, createBlock as createBlock247, defineComponent as defineComponent261, guardReactiveProps as guardReactiveProps97, normalizeProps as normalizeProps97, openBlock as openBlock253, renderSlot as renderSlot253, unref as unref256, withCtx as withCtx249 } from "vue";
var PaginationList_vue_vue_type_script_setup_true_lang_default = defineComponent261({
  __name: "PaginationList",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const transformedRange = computed78(() => {
      return transform(getRange(rootContext.page.value, rootContext.pageCount.value, rootContext.siblingCount.value, rootContext.showEdges.value));
    });
    return (_ctx, _cache) => {
      return openBlock253(), createBlock247(unref256(Primitive), normalizeProps97(guardReactiveProps97(props2)), {
        default: withCtx249(() => [renderSlot253(_ctx.$slots, "default", { items: transformedRange.value })]),
        _: 3
      }, 16);
    };
  }
});
var PaginationList_default = PaginationList_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/PaginationListItem.js
import { computed as computed79, createBlock as createBlock248, createTextVNode as createTextVNode21, defineComponent as defineComponent262, mergeProps as mergeProps108, openBlock as openBlock254, renderSlot as renderSlot254, toDisplayString as toDisplayString11, unref as unref257, withCtx as withCtx250 } from "vue";
var PaginationListItem_vue_vue_type_script_setup_true_lang_default = defineComponent262({
  __name: "PaginationListItem",
  props: {
    value: {
      type: Number,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const isSelected = computed79(() => rootContext.page.value === props2.value);
    const disabled = computed79(() => rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock254(), createBlock248(unref257(Primitive), mergeProps108(props2, {
        "data-type": "page",
        "aria-label": `Page ${_ctx.value}`,
        "aria-current": isSelected.value ? "page" : void 0,
        "data-selected": isSelected.value ? "true" : void 0,
        disabled: disabled.value,
        type: _ctx.as === "button" ? "button" : void 0,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref257(rootContext).onPageChange(_ctx.value))
      }), {
        default: withCtx250(() => [renderSlot254(_ctx.$slots, "default", {}, () => [createTextVNode21(toDisplayString11(_ctx.value), 1)])]),
        _: 3
      }, 16, [
        "aria-label",
        "aria-current",
        "data-selected",
        "disabled",
        "type"
      ]);
    };
  }
});
var PaginationListItem_default = PaginationListItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/PaginationNext.js
import { computed as computed80, createBlock as createBlock249, createTextVNode as createTextVNode22, defineComponent as defineComponent263, mergeProps as mergeProps109, openBlock as openBlock255, renderSlot as renderSlot255, unref as unref258, withCtx as withCtx251 } from "vue";
var PaginationNext_vue_vue_type_script_setup_true_lang_default = defineComponent263({
  __name: "PaginationNext",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const disabled = computed80(() => rootContext.page.value === rootContext.pageCount.value || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock255(), createBlock249(unref258(Primitive), mergeProps109(props2, {
        "aria-label": "Next Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref258(rootContext).onPageChange(unref258(rootContext).page.value + 1))
      }), {
        default: withCtx251(() => [renderSlot255(_ctx.$slots, "default", {}, () => [_cache[1] || (_cache[1] = createTextVNode22("Next page"))])]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});
var PaginationNext_default = PaginationNext_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Pagination/PaginationPrev.js
import { computed as computed81, createBlock as createBlock250, createTextVNode as createTextVNode23, defineComponent as defineComponent264, mergeProps as mergeProps110, openBlock as openBlock256, renderSlot as renderSlot256, unref as unref259, withCtx as withCtx252 } from "vue";
var PaginationPrev_vue_vue_type_script_setup_true_lang_default = defineComponent264({
  __name: "PaginationPrev",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const rootContext = injectPaginationRootContext();
    const disabled = computed81(() => rootContext.page.value === 1 || rootContext.disabled.value);
    return (_ctx, _cache) => {
      return openBlock256(), createBlock250(unref259(Primitive), mergeProps110(props2, {
        "aria-label": "Previous Page",
        type: _ctx.as === "button" ? "button" : void 0,
        disabled: disabled.value,
        onClick: _cache[0] || (_cache[0] = ($event) => !disabled.value && unref259(rootContext).onPageChange(unref259(rootContext).page.value - 1))
      }), {
        default: withCtx252(() => [renderSlot256(_ctx.$slots, "default", {}, () => [_cache[1] || (_cache[1] = createTextVNode23("Prev page"))])]),
        _: 3
      }, 16, ["type", "disabled"]);
    };
  }
});
var PaginationPrev_default = PaginationPrev_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/PinInput/PinInputRoot.js
import { computed as computed82, createBlock as createBlock251, createVNode as createVNode43, defineComponent as defineComponent265, mergeProps as mergeProps111, openBlock as openBlock257, ref as ref76, renderSlot as renderSlot257, toRefs as toRefs33, unref as unref260, watch as watch28, withCtx as withCtx253 } from "vue";
var [injectPinInputRootContext, providePinInputRootContext] = createContext("PinInputRoot");
var PinInputRoot_vue_vue_type_script_setup_true_lang_default = defineComponent265({
  inheritAttrs: false,
  __name: "PinInputRoot",
  props: {
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: Array,
      required: false
    },
    placeholder: {
      type: String,
      required: false,
      default: ""
    },
    mask: {
      type: Boolean,
      required: false
    },
    otp: {
      type: Boolean,
      required: false
    },
    type: {
      type: null,
      required: false,
      default: "text"
    },
    dir: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    id: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue", "complete"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { mask, otp, placeholder, type, disabled, dir: propDir } = toRefs33(props2);
    const { forwardRef } = useForwardExpose();
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? [],
      passive: props2.modelValue === void 0
    });
    const currentModelValue = computed82(() => Array.isArray(modelValue.value) ? [...modelValue.value] : []);
    const inputElements = ref76(/* @__PURE__ */ new Set());
    function onInputElementChange(el) {
      inputElements.value.add(el);
    }
    const isNumericMode = computed82(() => props2.type === "number");
    const isCompleted = computed82(() => {
      const modelValues = currentModelValue.value.filter((i) => !!i || isNumericMode.value && i === 0);
      return modelValues.length === inputElements.value.size;
    });
    watch28(modelValue, () => {
      if (isCompleted.value) emits("complete", modelValue.value);
    }, { deep: true });
    providePinInputRootContext({
      modelValue,
      currentModelValue,
      mask,
      otp,
      placeholder,
      type,
      dir,
      disabled,
      isCompleted,
      inputElements,
      onInputElementChange,
      isNumericMode
    });
    return (_ctx, _cache) => {
      return openBlock257(), createBlock251(unref260(Primitive), mergeProps111(_ctx.$attrs, {
        ref: unref260(forwardRef),
        dir: unref260(dir),
        "data-complete": isCompleted.value ? "" : void 0,
        "data-disabled": unref260(disabled) ? "" : void 0
      }), {
        default: withCtx253(() => [renderSlot257(_ctx.$slots, "default", { modelValue: unref260(modelValue) }), createVNode43(VisuallyHiddenInput_default, {
          id: _ctx.id,
          as: "input",
          feature: "focusable",
          tabindex: "-1",
          value: currentModelValue.value.join(""),
          name: _ctx.name ?? "",
          disabled: unref260(disabled),
          required: _ctx.required,
          onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(inputElements.value)?.[0]?.focus())
        }, null, 8, [
          "id",
          "value",
          "name",
          "disabled",
          "required"
        ])]),
        _: 3
      }, 16, [
        "dir",
        "data-complete",
        "data-disabled"
      ]);
    };
  }
});
var PinInputRoot_default = PinInputRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/PinInput/PinInputInput.js
import { computed as computed83, createBlock as createBlock252, defineComponent as defineComponent266, nextTick as nextTick26, onMounted as onMounted33, onUnmounted as onUnmounted15, openBlock as openBlock258, renderSlot as renderSlot258, unref as unref261, watch as watch29, withCtx as withCtx254, withKeys as withKeys18 } from "vue";
var PinInputInput_vue_vue_type_script_setup_true_lang_default = defineComponent266({
  __name: "PinInputInput",
  props: {
    index: {
      type: Number,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "input"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectPinInputRootContext();
    const inputElements = computed83(() => Array.from(context2.inputElements.value));
    const currentValue = computed83(() => context2.currentModelValue.value[props2.index]);
    const disabled = computed83(() => props2.disabled || context2.disabled.value);
    const isOtpMode = computed83(() => context2.otp.value);
    const isPasswordMode = computed83(() => context2.mask.value);
    const { primitiveElement, currentElement } = usePrimitiveElement();
    function handleInput(event) {
      const target = event.target;
      if ((event.data?.length ?? 0) > 1) {
        handleMultipleCharacter(target.value);
        return;
      }
      if (context2.isNumericMode.value && !/^\d*$/.test(target.value)) {
        target.value = target.value.replace(/\D/g, "");
        return;
      }
      target.value = event.data ?? "";
      updateModelValueAt(props2.index, target.value);
      const nextEl = inputElements.value[props2.index + 1];
      if (nextEl) nextEl.focus();
    }
    function resetPlaceholder() {
      const target = currentElement.value;
      nextTick26(() => {
        if (target && !target.value) target.placeholder = context2.placeholder.value;
      });
    }
    function handleKeydown(event) {
      useArrowNavigation(event, getActiveElement(), void 0, {
        itemsArray: inputElements.value,
        focus: true,
        loop: false,
        arrowKeyOptions: "horizontal",
        dir: context2.dir.value
      });
    }
    function handleBackspace(event) {
      event.preventDefault();
      const target = event.target;
      const value = target.value;
      if (value) updateModelValueAt(props2.index, "");
      else {
        const prevEl = inputElements.value[props2.index - 1];
        if (prevEl) {
          prevEl.focus();
          updateModelValueAt(props2.index - 1, "");
        }
      }
    }
    function handleDelete(event) {
      if (event.key === "Delete") {
        event.preventDefault();
        updateModelValueAt(props2.index, "");
      }
    }
    function handleFocus(event) {
      const target = event.target;
      target.setSelectionRange(1, 1);
      if (!target.value) target.placeholder = "";
    }
    function handleBlur(event) {
      resetPlaceholder();
    }
    function handlePaste(event) {
      event.preventDefault();
      const clipboardData = event.clipboardData;
      if (!clipboardData) return;
      const values = clipboardData.getData("text");
      handleMultipleCharacter(values);
    }
    function handleMultipleCharacter(values) {
      const tempModelValue = [...context2.currentModelValue.value];
      const initialIndex = values.length >= inputElements.value.length ? 0 : props2.index;
      const lastIndex = Math.min(initialIndex + values.length, inputElements.value.length);
      for (let i = initialIndex; i < lastIndex; i++) {
        const input = inputElements.value[i];
        const value = values[i - initialIndex];
        if (context2.isNumericMode.value && !/^\d*$/.test(value)) continue;
        tempModelValue[i] = value;
        input.focus();
      }
      context2.modelValue.value = tempModelValue;
      inputElements.value[lastIndex]?.focus();
    }
    function removeTrailingEmptyStrings(input) {
      let i = input.length - 1;
      while (i >= 0 && input[i] === "") {
        input.pop();
        i--;
      }
      return input;
    }
    function updateModelValueAt(index, value) {
      const tempModelValue = [...context2.currentModelValue.value];
      if (context2.isNumericMode.value) {
        const num = +value;
        if (value === "" || isNaN(num)) delete tempModelValue[index];
        else tempModelValue[index] = num;
      } else tempModelValue[index] = value;
      context2.modelValue.value = removeTrailingEmptyStrings(tempModelValue);
    }
    watch29(currentValue, () => {
      if (!currentValue.value) resetPlaceholder();
    });
    onMounted33(() => {
      context2.onInputElementChange(currentElement.value);
    });
    onUnmounted15(() => {
      context2.inputElements?.value.delete(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock258(), createBlock252(unref261(Primitive), {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        autocapitalize: "none",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        autocomplete: isOtpMode.value ? "one-time-code" : "false",
        type: isPasswordMode.value ? "password" : "text",
        inputmode: unref261(context2).isNumericMode.value ? "numeric" : "text",
        pattern: unref261(context2).isNumericMode.value ? "[0-9]*" : void 0,
        placeholder: unref261(context2).placeholder.value,
        value: currentValue.value,
        disabled: disabled.value,
        "data-disabled": disabled.value ? "" : void 0,
        "data-complete": unref261(context2).isCompleted.value ? "" : void 0,
        "aria-label": `pin input ${_ctx.index + 1} of ${inputElements.value.length}`,
        onInput: _cache[0] || (_cache[0] = ($event) => handleInput($event)),
        onKeydown: [
          withKeys18(handleKeydown, [
            "left",
            "right",
            "up",
            "down",
            "home",
            "end"
          ]),
          withKeys18(handleBackspace, ["backspace"]),
          withKeys18(handleDelete, ["delete"])
        ],
        onFocus: handleFocus,
        onBlur: handleBlur,
        onPaste: handlePaste
      }, {
        default: withCtx254(() => [renderSlot258(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "autocomplete",
        "type",
        "inputmode",
        "pattern",
        "placeholder",
        "value",
        "disabled",
        "data-disabled",
        "data-complete",
        "aria-label"
      ]);
    };
  }
});
var PinInputInput_default = PinInputInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Progress/ProgressRoot.js
import { computed as computed84, createBlock as createBlock253, defineComponent as defineComponent267, nextTick as nextTick27, openBlock as openBlock259, renderSlot as renderSlot259, unref as unref262, watch as watch30, withCtx as withCtx255 } from "vue";
var DEFAULT_MAX = 100;
var [injectProgressRootContext, provideProgressRootContext] = createContext("ProgressRoot");
var isNumber = (v) => typeof v === "number";
function validateValue(value, max2) {
  const isValidValueError = isNullish(value) || isNumber(value) && !Number.isNaN(value) && value <= max2 && value >= 0;
  if (isValidValueError) return value;
  console.error(`Invalid prop \`value\` of value \`${value}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`);
  return null;
}
function validateMax(max2) {
  const isValidMaxError = isNumber(max2) && !Number.isNaN(max2) && max2 > 0;
  if (isValidMaxError) return max2;
  console.error(`Invalid prop \`max\` of value \`${max2}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`);
  return DEFAULT_MAX;
}
var ProgressRoot_vue_vue_type_script_setup_true_lang_default = defineComponent267({
  __name: "ProgressRoot",
  props: {
    modelValue: {
      type: [Number, null],
      required: false
    },
    max: {
      type: Number,
      required: false,
      default: DEFAULT_MAX
    },
    getValueLabel: {
      type: Function,
      required: false,
      default: (value, max2) => isNumber(value) ? `${Math.round(value / max2 * DEFAULT_MAX)}%` : void 0
    },
    getValueText: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue", "update:max"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const modelValue = useVModel(props2, "modelValue", emit, { passive: props2.modelValue === void 0 });
    const max2 = useVModel(props2, "max", emit, { passive: props2.max === void 0 });
    watch30(() => modelValue.value, async (value) => {
      const correctedValue = validateValue(value, props2.max);
      if (correctedValue !== value) {
        await nextTick27();
        modelValue.value = correctedValue;
      }
    }, { immediate: true });
    watch30(() => props2.max, (newMax) => {
      const correctedMax = validateMax(props2.max);
      if (correctedMax !== newMax) max2.value = correctedMax;
    }, { immediate: true });
    const progressState = computed84(() => {
      if (isNullish(modelValue.value)) return "indeterminate";
      if (modelValue.value === max2.value) return "complete";
      return "loading";
    });
    provideProgressRootContext({
      modelValue,
      max: max2,
      progressState
    });
    return (_ctx, _cache) => {
      return openBlock259(), createBlock253(unref262(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "aria-valuemax": unref262(max2),
        "aria-valuemin": 0,
        "aria-valuenow": isNumber(unref262(modelValue)) ? unref262(modelValue) : void 0,
        "aria-valuetext": _ctx.getValueText?.(unref262(modelValue), unref262(max2)),
        "aria-label": _ctx.getValueLabel(unref262(modelValue), unref262(max2)),
        role: "progressbar",
        "data-state": progressState.value,
        "data-value": unref262(modelValue) ?? void 0,
        "data-max": unref262(max2)
      }, {
        default: withCtx255(() => [renderSlot259(_ctx.$slots, "default", { modelValue: unref262(modelValue) })]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "aria-valuemax",
        "aria-valuenow",
        "aria-valuetext",
        "aria-label",
        "data-state",
        "data-value",
        "data-max"
      ]);
    };
  }
});
var ProgressRoot_default = ProgressRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Progress/ProgressIndicator.js
import { createBlock as createBlock254, defineComponent as defineComponent268, mergeProps as mergeProps112, openBlock as openBlock260, renderSlot as renderSlot260, unref as unref263, withCtx as withCtx256 } from "vue";
var ProgressIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent268({
  __name: "ProgressIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectProgressRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock260(), createBlock254(unref263(Primitive), mergeProps112(props2, {
        "data-state": unref263(rootContext).progressState.value,
        "data-value": unref263(rootContext).modelValue?.value ?? void 0,
        "data-max": unref263(rootContext).max.value
      }), {
        default: withCtx256(() => [renderSlot260(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-value",
        "data-max"
      ]);
    };
  }
});
var ProgressIndicator_default = ProgressIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RadioGroup/utils.js
var RADIO_SELECT = "radio.select";
function handleSelect(event, value, callback) {
  const eventDetail = {
    originalEvent: event,
    value
  };
  handleAndDispatchCustomEvent(RADIO_SELECT, callback, eventDetail);
}

// node_modules/reka-ui/dist/RadioGroup/Radio.js
import { computed as computed85, createBlock as createBlock255, createCommentVNode as createCommentVNode21, defineComponent as defineComponent269, mergeProps as mergeProps113, openBlock as openBlock261, renderSlot as renderSlot261, toRefs as toRefs34, unref as unref264, withCtx as withCtx257, withModifiers as withModifiers15 } from "vue";
var Radio_vue_vue_type_script_setup_true_lang_default = defineComponent269({
  __name: "Radio",
  props: {
    id: {
      type: String,
      required: false
    },
    value: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    checked: {
      type: Boolean,
      required: false,
      default: void 0
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:checked", "select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const checked = useVModel(props2, "checked", emits, { passive: props2.checked === void 0 });
    const { value } = toRefs34(props2);
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const isFormControl = useFormControl(triggerElement);
    const ariaLabel = computed85(() => props2.id && triggerElement.value ? document.querySelector(`[for="${props2.id}"]`)?.innerText ?? props2.value : void 0);
    function handleClick(event) {
      if (props2.disabled) return;
      handleSelect(event, props2.value, (ev) => {
        emits("select", ev);
        if (ev?.defaultPrevented) return;
        checked.value = true;
        if (isFormControl.value) ev.stopPropagation();
      });
    }
    return (_ctx, _cache) => {
      return openBlock261(), createBlock255(unref264(Primitive), mergeProps113(_ctx.$attrs, {
        id: _ctx.id,
        ref: unref264(forwardRef),
        role: "radio",
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "aria-checked": unref264(checked),
        "aria-label": ariaLabel.value,
        "as-child": _ctx.asChild,
        disabled: _ctx.disabled ? "" : void 0,
        "data-state": unref264(checked) ? "checked" : "unchecked",
        "data-disabled": _ctx.disabled ? "" : void 0,
        value: unref264(value),
        required: _ctx.required,
        name: _ctx.name,
        onClick: withModifiers15(handleClick, ["stop"])
      }), {
        default: withCtx257(() => [renderSlot261(_ctx.$slots, "default", { checked: unref264(checked) }), unref264(isFormControl) && _ctx.name ? (openBlock261(), createBlock255(unref264(VisuallyHiddenInput_default), {
          key: 0,
          type: "radio",
          tabindex: "-1",
          value: unref264(value),
          checked: !!unref264(checked),
          name: _ctx.name,
          disabled: _ctx.disabled,
          required: _ctx.required
        }, null, 8, [
          "value",
          "checked",
          "name",
          "disabled",
          "required"
        ])) : createCommentVNode21("v-if", true)]),
        _: 3
      }, 16, [
        "id",
        "type",
        "as",
        "aria-checked",
        "aria-label",
        "as-child",
        "disabled",
        "data-state",
        "data-disabled",
        "value",
        "required",
        "name"
      ]);
    };
  }
});
var Radio_default = Radio_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RadioGroup/RadioGroupRoot.js
import { createBlock as createBlock256, createCommentVNode as createCommentVNode22, createVNode as createVNode44, defineComponent as defineComponent270, openBlock as openBlock262, renderSlot as renderSlot262, toRefs as toRefs35, unref as unref265, withCtx as withCtx258 } from "vue";
var [injectRadioGroupRootContext, provideRadioGroupRootContext] = createContext("RadioGroupRoot");
var RadioGroupRoot_vue_vue_type_script_setup_true_lang_default = defineComponent270({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    orientation: {
      type: String,
      required: false,
      default: void 0
    },
    dir: {
      type: String,
      required: false
    },
    loop: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const { disabled, loop, orientation, name, required, dir: propDir } = toRefs35(props2);
    const dir = useDirection(propDir);
    const isFormControl = useFormControl(currentElement);
    provideRadioGroupRootContext({
      modelValue,
      changeModelValue: (value) => {
        modelValue.value = value;
      },
      disabled,
      loop,
      orientation,
      name: name?.value,
      required
    });
    return (_ctx, _cache) => {
      return openBlock262(), createBlock256(unref265(RovingFocusGroup_default), {
        "as-child": "",
        orientation: unref265(orientation),
        dir: unref265(dir),
        loop: unref265(loop)
      }, {
        default: withCtx258(() => [createVNode44(unref265(Primitive), {
          ref: unref265(forwardRef),
          role: "radiogroup",
          "data-disabled": unref265(disabled) ? "" : void 0,
          "as-child": _ctx.asChild,
          as: _ctx.as,
          "aria-orientation": unref265(orientation),
          "aria-required": unref265(required),
          dir: unref265(dir)
        }, {
          default: withCtx258(() => [renderSlot262(_ctx.$slots, "default", { modelValue: unref265(modelValue) }), unref265(isFormControl) && unref265(name) ? (openBlock262(), createBlock256(unref265(VisuallyHiddenInput_default), {
            key: 0,
            required: unref265(required),
            disabled: unref265(disabled),
            value: unref265(modelValue),
            name: unref265(name)
          }, null, 8, [
            "required",
            "disabled",
            "value",
            "name"
          ])) : createCommentVNode22("v-if", true)]),
          _: 3
        }, 8, [
          "data-disabled",
          "as-child",
          "as",
          "aria-orientation",
          "aria-required",
          "dir"
        ])]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]);
    };
  }
});
var RadioGroupRoot_default = RadioGroupRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RadioGroup/RadioGroupItem.js
import { computed as computed86, createBlock as createBlock257, createVNode as createVNode45, defineComponent as defineComponent271, mergeProps as mergeProps114, openBlock as openBlock263, ref as ref77, renderSlot as renderSlot263, unref as unref266, withCtx as withCtx259, withKeys as withKeys19, withModifiers as withModifiers16 } from "vue";
var [injectRadioGroupItemContext, provideRadiogroupItemContext] = createContext("RadioGroupItem");
var RadioGroupItem_vue_vue_type_script_setup_true_lang_default = defineComponent271({
  inheritAttrs: false,
  __name: "RadioGroupItem",
  props: {
    id: {
      type: String,
      required: false
    },
    value: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectRadioGroupRootContext();
    const disabled = computed86(() => rootContext.disabled.value || props2.disabled);
    const required = computed86(() => rootContext.required.value || props2.required);
    const checked = computed86(() => isEqual(rootContext.modelValue?.value, props2.value));
    provideRadiogroupItemContext({
      disabled,
      checked
    });
    const isArrowKeyPressed = ref77(false);
    const ARROW_KEYS2 = [
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ];
    useEventListener("keydown", (event) => {
      if (ARROW_KEYS2.includes(event.key)) isArrowKeyPressed.value = true;
    });
    useEventListener("keyup", () => {
      isArrowKeyPressed.value = false;
    });
    function handleFocus() {
      setTimeout(() => {
        if (isArrowKeyPressed.value) currentElement.value?.click();
      }, 0);
    }
    return (_ctx, _cache) => {
      return openBlock263(), createBlock257(unref266(RovingFocusItem_default), {
        checked: checked.value,
        disabled: disabled.value,
        "as-child": "",
        focusable: !disabled.value,
        active: checked.value
      }, {
        default: withCtx259(() => [createVNode45(Radio_default, mergeProps114({
          ..._ctx.$attrs,
          ...props2
        }, {
          ref: unref266(forwardRef),
          checked: checked.value,
          required: required.value,
          disabled: disabled.value,
          "onUpdate:checked": _cache[0] || (_cache[0] = ($event) => unref266(rootContext).changeModelValue(_ctx.value)),
          onSelect: _cache[1] || (_cache[1] = ($event) => emits("select", $event)),
          onKeydown: _cache[2] || (_cache[2] = withKeys19(withModifiers16(() => {
          }, ["prevent"]), ["enter"])),
          onFocus: handleFocus
        }), {
          default: withCtx259(() => [renderSlot263(_ctx.$slots, "default", {
            checked: checked.value,
            required: required.value,
            disabled: disabled.value
          })]),
          _: 3
        }, 16, [
          "checked",
          "required",
          "disabled"
        ])]),
        _: 3
      }, 8, [
        "checked",
        "disabled",
        "focusable",
        "active"
      ]);
    };
  }
});
var RadioGroupItem_default = RadioGroupItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/RadioGroup/RadioGroupIndicator.js
import { createBlock as createBlock258, createVNode as createVNode46, defineComponent as defineComponent272, mergeProps as mergeProps115, openBlock as openBlock264, renderSlot as renderSlot264, unref as unref267, withCtx as withCtx260 } from "vue";
var RadioGroupIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent272({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const { forwardRef } = useForwardExpose();
    const itemContext = injectRadioGroupItemContext();
    return (_ctx, _cache) => {
      return openBlock264(), createBlock258(unref267(Presence_default), { present: _ctx.forceMount || unref267(itemContext).checked.value }, {
        default: withCtx260(() => [createVNode46(unref267(Primitive), mergeProps115({
          ref: unref267(forwardRef),
          "data-state": unref267(itemContext).checked.value ? "checked" : "unchecked",
          "data-disabled": unref267(itemContext).disabled.value ? "" : void 0,
          "as-child": _ctx.asChild,
          as: _ctx.as
        }, _ctx.$attrs), {
          default: withCtx260(() => [renderSlot264(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "data-state",
          "data-disabled",
          "as-child",
          "as"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var RadioGroupIndicator_default = RadioGroupIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaRoot.js
import { createBlock as createBlock259, defineComponent as defineComponent273, normalizeStyle as normalizeStyle6, openBlock as openBlock265, ref as ref78, renderSlot as renderSlot265, toRefs as toRefs36, unref as unref268, withCtx as withCtx261 } from "vue";
var [injectScrollAreaRootContext, provideScrollAreaRootContext] = createContext("ScrollAreaRoot");
var ScrollAreaRoot_vue_vue_type_script_setup_true_lang_default = defineComponent273({
  __name: "ScrollAreaRoot",
  props: {
    type: {
      type: String,
      required: false,
      default: "hover"
    },
    dir: {
      type: String,
      required: false
    },
    scrollHideDelay: {
      type: Number,
      required: false,
      default: 600
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props, { expose: __expose }) {
    const props2 = __props;
    const cornerWidth = ref78(0);
    const cornerHeight = ref78(0);
    const viewport = ref78();
    const content = ref78();
    const scrollbarX = ref78();
    const scrollbarY = ref78();
    const scrollbarXEnabled = ref78(false);
    const scrollbarYEnabled = ref78(false);
    const { type, dir: propDir, scrollHideDelay } = toRefs36(props2);
    const dir = useDirection(propDir);
    function scrollTop() {
      viewport.value?.scrollTo({ top: 0 });
    }
    function scrollTopLeft() {
      viewport.value?.scrollTo({
        top: 0,
        left: 0
      });
    }
    __expose({
      viewport,
      scrollTop,
      scrollTopLeft
    });
    const { forwardRef, currentElement: scrollArea } = useForwardExpose();
    provideScrollAreaRootContext({
      type,
      dir,
      scrollHideDelay,
      scrollArea,
      viewport,
      onViewportChange: (el) => {
        viewport.value = el || void 0;
      },
      content,
      onContentChange: (el) => {
        content.value = el;
      },
      scrollbarX,
      scrollbarXEnabled,
      scrollbarY,
      scrollbarYEnabled,
      onScrollbarXChange: (scrollbar) => {
        scrollbarX.value = scrollbar || void 0;
      },
      onScrollbarYChange: (scrollbar) => {
        scrollbarY.value = scrollbar || void 0;
      },
      onScrollbarXEnabledChange: (rendered) => {
        scrollbarXEnabled.value = rendered;
      },
      onScrollbarYEnabledChange: (rendered) => {
        scrollbarYEnabled.value = rendered;
      },
      onCornerWidthChange: (width) => {
        cornerWidth.value = width;
      },
      onCornerHeightChange: (height) => {
        cornerHeight.value = height;
      }
    });
    return (_ctx, _cache) => {
      return openBlock265(), createBlock259(unref268(Primitive), {
        ref: unref268(forwardRef),
        "as-child": props2.asChild,
        as: _ctx.as,
        dir: unref268(dir),
        style: normalizeStyle6({
          position: "relative",
          ["--reka-scroll-area-corner-width"]: `${cornerWidth.value}px`,
          ["--reka-scroll-area-corner-height"]: `${cornerHeight.value}px`
        })
      }, {
        default: withCtx261(() => [renderSlot265(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "dir",
        "style"
      ]);
    };
  }
});
var ScrollAreaRoot_default = ScrollAreaRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaCornerImpl.js
import { computed as computed87, createBlock as createBlock260, createCommentVNode as createCommentVNode23, defineComponent as defineComponent274, mergeProps as mergeProps116, openBlock as openBlock266, ref as ref79, renderSlot as renderSlot266, unref as unref269, watch as watch31, withCtx as withCtx262 } from "vue";
var ScrollAreaCornerImpl_vue_vue_type_script_setup_true_lang_default = defineComponent274({
  __name: "ScrollAreaCornerImpl",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const width = ref79(0);
    const height = ref79(0);
    const hasSize = computed87(() => !!width.value && !!height.value);
    function setCornerHeight() {
      const offsetHeight = rootContext.scrollbarX.value?.offsetHeight || 0;
      rootContext.onCornerHeightChange(offsetHeight);
      height.value = offsetHeight;
    }
    function setCornerWidth() {
      const offsetWidth = rootContext.scrollbarY.value?.offsetWidth || 0;
      rootContext.onCornerWidthChange(offsetWidth);
      width.value = offsetWidth;
    }
    useResizeObserver(rootContext.scrollbarX.value, setCornerHeight);
    useResizeObserver(rootContext.scrollbarY.value, setCornerWidth);
    watch31(() => rootContext.scrollbarX.value, setCornerHeight);
    watch31(() => rootContext.scrollbarY.value, setCornerWidth);
    return (_ctx, _cache) => {
      return hasSize.value ? (openBlock266(), createBlock260(unref269(Primitive), mergeProps116({
        key: 0,
        style: {
          width: `${width.value}px`,
          height: `${height.value}px`,
          position: "absolute",
          right: unref269(rootContext).dir.value === "ltr" ? 0 : void 0,
          left: unref269(rootContext).dir.value === "rtl" ? 0 : void 0,
          bottom: 0
        }
      }, _ctx.$parent?.$props), {
        default: withCtx262(() => [renderSlot266(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["style"])) : createCommentVNode23("v-if", true);
    };
  }
});
var ScrollAreaCornerImpl_default = ScrollAreaCornerImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaCorner.js
import { computed as computed88, createBlock as createBlock261, createCommentVNode as createCommentVNode24, defineComponent as defineComponent275, mergeProps as mergeProps117, openBlock as openBlock267, renderSlot as renderSlot267, unref as unref270, withCtx as withCtx263 } from "vue";
var ScrollAreaCorner_vue_vue_type_script_setup_true_lang_default = defineComponent275({
  __name: "ScrollAreaCorner",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectScrollAreaRootContext();
    const hasBothScrollbarsVisible = computed88(() => !!rootContext.scrollbarX.value && !!rootContext.scrollbarY.value);
    const hasCorner = computed88(() => rootContext.type.value !== "scroll" && hasBothScrollbarsVisible.value);
    return (_ctx, _cache) => {
      return hasCorner.value ? (openBlock267(), createBlock261(ScrollAreaCornerImpl_default, mergeProps117({ key: 0 }, props2, { ref: unref270(forwardRef) }), {
        default: withCtx263(() => [renderSlot267(_ctx.$slots, "default")]),
        _: 3
      }, 16)) : createCommentVNode24("v-if", true);
    };
  }
});
var ScrollAreaCorner_default = ScrollAreaCorner_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/utils.js
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function addUnlinkedScrollListener(node, handler = () => {
}) {
  let prevPosition = {
    left: node.scrollLeft,
    top: node.scrollTop
  };
  let rAF = 0;
  (function loop() {
    const position = {
      left: node.scrollLeft,
      top: node.scrollTop
    };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange[0], scrollClampRange[1]);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function toInt(value) {
  return value ? Number.parseInt(value, 10) : 0;
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset3 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset3;
  const minPointerPos = sizes.scrollbar.paddingStart + offset3;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarX.js
import { computed as computed89, createBlock as createBlock262, defineComponent as defineComponent276, normalizeStyle as normalizeStyle7, onMounted as onMounted34, openBlock as openBlock268, renderSlot as renderSlot268, unref as unref271, withCtx as withCtx264 } from "vue";
var ScrollAreaScrollbarX_vue_vue_type_script_setup_true_lang_default = defineComponent276({
  __name: "ScrollAreaScrollbarX",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
    const { forwardRef, currentElement: scrollbarElement } = useForwardExpose();
    onMounted34(() => {
      if (scrollbarElement.value) rootContext.onScrollbarXChange(scrollbarElement.value);
    });
    const sizes = computed89(() => scrollbarVisibleContext.sizes.value);
    return (_ctx, _cache) => {
      return openBlock268(), createBlock262(ScrollAreaScrollbarImpl_default, {
        ref: unref271(forwardRef),
        "is-horizontal": true,
        "data-orientation": "horizontal",
        style: normalizeStyle7({
          bottom: 0,
          left: unref271(rootContext).dir.value === "rtl" ? "var(--reka-scroll-area-corner-width)" : 0,
          right: unref271(rootContext).dir.value === "ltr" ? "var(--reka-scroll-area-corner-width)" : 0,
          ["--reka-scroll-area-thumb-width"]: sizes.value ? `${unref271(getThumbSize)(sizes.value)}px` : void 0
        }),
        onOnDragScroll: _cache[0] || (_cache[0] = ($event) => unref271(scrollbarVisibleContext).onDragScroll($event.x))
      }, {
        default: withCtx264(() => [renderSlot268(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["style"]);
    };
  }
});
var ScrollAreaScrollbarX_default = ScrollAreaScrollbarX_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarY.js
import { computed as computed90, createBlock as createBlock263, defineComponent as defineComponent277, normalizeStyle as normalizeStyle8, onMounted as onMounted35, openBlock as openBlock269, renderSlot as renderSlot269, unref as unref272, withCtx as withCtx265 } from "vue";
var ScrollAreaScrollbarY_vue_vue_type_script_setup_true_lang_default = defineComponent277({
  __name: "ScrollAreaScrollbarY",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
    const { forwardRef, currentElement: scrollbarElement } = useForwardExpose();
    onMounted35(() => {
      if (scrollbarElement.value) rootContext.onScrollbarYChange(scrollbarElement.value);
    });
    const sizes = computed90(() => scrollbarVisibleContext.sizes.value);
    return (_ctx, _cache) => {
      return openBlock269(), createBlock263(ScrollAreaScrollbarImpl_default, {
        ref: unref272(forwardRef),
        "is-horizontal": false,
        "data-orientation": "vertical",
        style: normalizeStyle8({
          top: 0,
          right: unref272(rootContext).dir.value === "ltr" ? 0 : void 0,
          left: unref272(rootContext).dir.value === "rtl" ? 0 : void 0,
          bottom: "var(--reka-scroll-area-corner-height)",
          ["--reka-scroll-area-thumb-height"]: sizes.value ? `${unref272(getThumbSize)(sizes.value)}px` : void 0
        }),
        onOnDragScroll: _cache[0] || (_cache[0] = ($event) => unref272(scrollbarVisibleContext).onDragScroll($event.y))
      }, {
        default: withCtx265(() => [renderSlot269(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["style"]);
    };
  }
});
var ScrollAreaScrollbarY_default = ScrollAreaScrollbarY_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarAuto.js
import { createBlock as createBlock264, createVNode as createVNode47, defineComponent as defineComponent278, mergeProps as mergeProps118, onMounted as onMounted36, openBlock as openBlock270, ref as ref80, renderSlot as renderSlot270, unref as unref273, withCtx as withCtx266 } from "vue";
var ScrollAreaScrollbarAuto_vue_vue_type_script_setup_true_lang_default = defineComponent278({
  __name: "ScrollAreaScrollbarAuto",
  props: { forceMount: {
    type: Boolean,
    required: false
  } },
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef } = useForwardExpose();
    const visible = ref80(false);
    const handleResize = useDebounceFn(() => {
      if (rootContext.viewport.value) {
        const isOverflowX = rootContext.viewport.value.offsetWidth < rootContext.viewport.value.scrollWidth;
        const isOverflowY = rootContext.viewport.value.offsetHeight < rootContext.viewport.value.scrollHeight;
        visible.value = scrollbarContext.isHorizontal.value ? isOverflowX : isOverflowY;
      }
    }, 10);
    onMounted36(() => handleResize());
    useResizeObserver(rootContext.viewport, handleResize);
    useResizeObserver(rootContext.content, handleResize);
    return (_ctx, _cache) => {
      return openBlock270(), createBlock264(unref273(Presence_default), { present: _ctx.forceMount || visible.value }, {
        default: withCtx266(() => [createVNode47(ScrollAreaScrollbarVisible_default, mergeProps118(_ctx.$attrs, {
          ref: unref273(forwardRef),
          "data-state": visible.value ? "visible" : "hidden"
        }), {
          default: withCtx266(() => [renderSlot270(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["data-state"])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var ScrollAreaScrollbarAuto_default = ScrollAreaScrollbarAuto_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarHover.js
import { createBlock as createBlock265, createVNode as createVNode48, defineComponent as defineComponent279, mergeProps as mergeProps119, onMounted as onMounted37, onUnmounted as onUnmounted16, openBlock as openBlock271, ref as ref81, renderSlot as renderSlot271, unref as unref274, withCtx as withCtx267 } from "vue";
var ScrollAreaScrollbarHover_vue_vue_type_script_setup_true_lang_default = defineComponent279({
  inheritAttrs: false,
  __name: "ScrollAreaScrollbarHover",
  props: { forceMount: {
    type: Boolean,
    required: false
  } },
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const { forwardRef } = useForwardExpose();
    let timeout;
    const visible = ref81(false);
    function handlePointerEnter() {
      window.clearTimeout(timeout);
      visible.value = true;
    }
    function handlePointerLeave() {
      timeout = window.setTimeout(() => {
        visible.value = false;
      }, rootContext.scrollHideDelay.value);
    }
    onMounted37(() => {
      const scrollArea = rootContext.scrollArea.value;
      if (scrollArea) {
        scrollArea.addEventListener("pointerenter", handlePointerEnter);
        scrollArea.addEventListener("pointerleave", handlePointerLeave);
      }
    });
    onUnmounted16(() => {
      const scrollArea = rootContext.scrollArea.value;
      if (scrollArea) {
        window.clearTimeout(timeout);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      }
    });
    return (_ctx, _cache) => {
      return openBlock271(), createBlock265(unref274(Presence_default), { present: _ctx.forceMount || visible.value }, {
        default: withCtx267(() => [createVNode48(ScrollAreaScrollbarAuto_default, mergeProps119(_ctx.$attrs, {
          ref: unref274(forwardRef),
          "data-state": visible.value ? "visible" : "hidden"
        }), {
          default: withCtx267(() => [renderSlot271(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["data-state"])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var ScrollAreaScrollbarHover_default = ScrollAreaScrollbarHover_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarScroll.js
import { computed as computed91, createBlock as createBlock266, createVNode as createVNode49, defineComponent as defineComponent280, mergeProps as mergeProps120, openBlock as openBlock272, renderSlot as renderSlot272, unref as unref275, watchEffect as watchEffect18, withCtx as withCtx268 } from "vue";
var ScrollAreaScrollbarScroll_vue_vue_type_script_setup_true_lang_default = defineComponent280({
  __name: "ScrollAreaScrollbarScroll",
  props: { forceMount: {
    type: Boolean,
    required: false
  } },
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef } = useForwardExpose();
    const { state, dispatch } = useStateMachine("hidden", {
      hidden: { SCROLL: "scrolling" },
      scrolling: {
        SCROLL_END: "idle",
        POINTER_ENTER: "interacting"
      },
      interacting: {
        SCROLL: "interacting",
        POINTER_LEAVE: "idle"
      },
      idle: {
        HIDE: "hidden",
        SCROLL: "scrolling",
        POINTER_ENTER: "interacting"
      }
    });
    const visible = computed91(() => state.value !== "hidden");
    watchEffect18((onCleanup) => {
      if (state.value === "idle") {
        const timeId = window.setTimeout(() => dispatch("HIDE"), rootContext.scrollHideDelay.value);
        onCleanup(() => {
          window.clearTimeout(timeId);
        });
      }
    });
    const debounceScrollEnd = useDebounceFn(() => dispatch("SCROLL_END"), 100);
    watchEffect18((onCleanup) => {
      const viewport = rootContext.viewport.value;
      const scrollDirection = scrollbarContext.isHorizontal.value ? "scrollLeft" : "scrollTop";
      if (viewport) {
        let prevScrollPos = viewport[scrollDirection];
        const handleScroll = () => {
          const scrollPos = viewport[scrollDirection];
          const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
          if (hasScrollInDirectionChanged) {
            dispatch("SCROLL");
            debounceScrollEnd();
          }
          prevScrollPos = scrollPos;
        };
        viewport.addEventListener("scroll", handleScroll);
        onCleanup(() => {
          viewport.removeEventListener("scroll", handleScroll);
        });
      }
    });
    return (_ctx, _cache) => {
      return openBlock272(), createBlock266(unref275(Presence_default), { present: _ctx.forceMount || visible.value }, {
        default: withCtx268(() => [createVNode49(ScrollAreaScrollbarVisible_default, mergeProps120(_ctx.$attrs, {
          ref: unref275(forwardRef),
          "data-state": visible.value ? "visible" : "hidden"
        }), {
          default: withCtx268(() => [renderSlot272(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["data-state"])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var ScrollAreaScrollbarScroll_default = ScrollAreaScrollbarScroll_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbar.js
import { computed as computed92, createBlock as createBlock267, createCommentVNode as createCommentVNode25, defineComponent as defineComponent281, mergeProps as mergeProps121, onUnmounted as onUnmounted17, openBlock as openBlock273, renderSlot as renderSlot273, toRefs as toRefs37, unref as unref276, watch as watch32, withCtx as withCtx269 } from "vue";
var [injectScrollAreaScrollbarContext, provideScrollAreaScrollbarContext] = createContext("ScrollAreaScrollbar");
var ScrollAreaScrollbar_vue_vue_type_script_setup_true_lang_default = defineComponent281({
  inheritAttrs: false,
  __name: "ScrollAreaScrollbar",
  props: {
    orientation: {
      type: String,
      required: false,
      default: "vertical"
    },
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectScrollAreaRootContext();
    const isHorizontal = computed92(() => props2.orientation === "horizontal");
    watch32(isHorizontal, () => {
      if (isHorizontal.value) rootContext.onScrollbarXEnabledChange(true);
      else rootContext.onScrollbarYEnabledChange(true);
    }, { immediate: true });
    onUnmounted17(() => {
      rootContext.onScrollbarXEnabledChange(false);
      rootContext.onScrollbarYEnabledChange(false);
    });
    const { orientation, forceMount, asChild, as } = toRefs37(props2);
    provideScrollAreaScrollbarContext({
      orientation,
      forceMount,
      isHorizontal,
      as,
      asChild
    });
    return (_ctx, _cache) => {
      return unref276(rootContext).type.value === "hover" ? (openBlock273(), createBlock267(ScrollAreaScrollbarHover_default, mergeProps121({ key: 0 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "force-mount": unref276(forceMount)
      }), {
        default: withCtx269(() => [renderSlot273(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["force-mount"])) : unref276(rootContext).type.value === "scroll" ? (openBlock273(), createBlock267(ScrollAreaScrollbarScroll_default, mergeProps121({ key: 1 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "force-mount": unref276(forceMount)
      }), {
        default: withCtx269(() => [renderSlot273(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["force-mount"])) : unref276(rootContext).type.value === "auto" ? (openBlock273(), createBlock267(ScrollAreaScrollbarAuto_default, mergeProps121({ key: 2 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "force-mount": unref276(forceMount)
      }), {
        default: withCtx269(() => [renderSlot273(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["force-mount"])) : unref276(rootContext).type.value === "always" ? (openBlock273(), createBlock267(ScrollAreaScrollbarVisible_default, mergeProps121({ key: 3 }, _ctx.$attrs, {
        ref: unref276(forwardRef),
        "data-state": "visible"
      }), {
        default: withCtx269(() => [renderSlot273(_ctx.$slots, "default")]),
        _: 3
      }, 16)) : createCommentVNode25("v-if", true);
    };
  }
});
var ScrollAreaScrollbar_default = ScrollAreaScrollbar_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarVisible.js
import { computed as computed93, createBlock as createBlock268, createCommentVNode as createCommentVNode26, defineComponent as defineComponent282, mergeProps as mergeProps122, openBlock as openBlock274, ref as ref82, renderSlot as renderSlot274, unref as unref277, withCtx as withCtx270 } from "vue";
var [injectScrollAreaScrollbarVisibleContext, provideScrollAreaScrollbarVisibleContext] = createContext("ScrollAreaScrollbarVisible");
var ScrollAreaScrollbarVisible_vue_vue_type_script_setup_true_lang_default = defineComponent282({
  __name: "ScrollAreaScrollbarVisible",
  setup(__props) {
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef } = useForwardExpose();
    const sizes = ref82({
      content: 0,
      viewport: 0,
      scrollbar: {
        size: 0,
        paddingStart: 0,
        paddingEnd: 0
      }
    });
    const hasThumb = computed93(() => {
      const thumbRatio = getThumbRatio(sizes.value.viewport, sizes.value.content);
      return Boolean(thumbRatio > 0 && thumbRatio < 1);
    });
    const thumbRef = ref82();
    const pointerOffset = ref82(0);
    function handleWheelScroll(event, payload) {
      if (isShowingScrollbarX.value) {
        const scrollPos = rootContext.viewport.value.scrollLeft + event.deltaY;
        rootContext.viewport.value.scrollLeft = scrollPos;
        if (isScrollingWithinScrollbarBounds(scrollPos, payload)) event.preventDefault();
      } else {
        const scrollPos = rootContext.viewport.value.scrollTop + event.deltaY;
        rootContext.viewport.value.scrollTop = scrollPos;
        if (isScrollingWithinScrollbarBounds(scrollPos, payload)) event.preventDefault();
      }
    }
    function handleThumbDown(event, payload) {
      if (isShowingScrollbarX.value) pointerOffset.value = payload.x;
      else pointerOffset.value = payload.y;
    }
    function handleThumbUp(event) {
      pointerOffset.value = 0;
    }
    function handleSizeChange(payload) {
      sizes.value = payload;
    }
    function getScrollPosition(pointerPos, dir) {
      return getScrollPositionFromPointer(pointerPos, pointerOffset.value, sizes.value, dir);
    }
    const isShowingScrollbarX = computed93(() => scrollbarContext.isHorizontal.value);
    function onDragScroll(payload) {
      if (isShowingScrollbarX.value) rootContext.viewport.value.scrollLeft = getScrollPosition(payload, rootContext.dir.value);
      else rootContext.viewport.value.scrollTop = getScrollPosition(payload);
    }
    function onThumbPositionChange() {
      if (isShowingScrollbarX.value) {
        if (rootContext.viewport.value && thumbRef.value) {
          const scrollPos = rootContext.viewport.value.scrollLeft;
          const offset3 = getThumbOffsetFromScroll(scrollPos, sizes.value, rootContext.dir.value);
          thumbRef.value.style.transform = `translate3d(${offset3}px, 0, 0)`;
        }
      } else if (rootContext.viewport.value && thumbRef.value) {
        const scrollPos = rootContext.viewport.value.scrollTop;
        const offset3 = getThumbOffsetFromScroll(scrollPos, sizes.value);
        thumbRef.value.style.transform = `translate3d(0, ${offset3}px, 0)`;
      }
    }
    function onThumbChange(element) {
      thumbRef.value = element;
    }
    provideScrollAreaScrollbarVisibleContext({
      sizes,
      hasThumb,
      handleWheelScroll,
      handleThumbDown,
      handleThumbUp,
      handleSizeChange,
      onThumbPositionChange,
      onThumbChange,
      onDragScroll
    });
    return (_ctx, _cache) => {
      return isShowingScrollbarX.value ? (openBlock274(), createBlock268(ScrollAreaScrollbarX_default, mergeProps122({ key: 0 }, _ctx.$attrs, { ref: unref277(forwardRef) }), {
        default: withCtx270(() => [renderSlot274(_ctx.$slots, "default")]),
        _: 3
      }, 16)) : (openBlock274(), createBlock268(ScrollAreaScrollbarY_default, mergeProps122({ key: 1 }, _ctx.$attrs, { ref: unref277(forwardRef) }), {
        default: withCtx270(() => [renderSlot274(_ctx.$slots, "default")]),
        _: 3
      }, 16));
    };
  }
});
var ScrollAreaScrollbarVisible_default = ScrollAreaScrollbarVisible_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaScrollbarImpl.js
import { createBlock as createBlock269, defineComponent as defineComponent283, onMounted as onMounted38, onUnmounted as onUnmounted18, openBlock as openBlock275, ref as ref83, renderSlot as renderSlot275, unref as unref278, withCtx as withCtx271 } from "vue";
var ScrollAreaScrollbarImpl_vue_vue_type_script_setup_true_lang_default = defineComponent283({
  __name: "ScrollAreaScrollbarImpl",
  props: { isHorizontal: {
    type: Boolean,
    required: true
  } },
  emits: [
    "onDragScroll",
    "onWheelScroll",
    "onThumbPointerDown"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const rootContext = injectScrollAreaRootContext();
    const scrollbarVisibleContext = injectScrollAreaScrollbarVisibleContext();
    const scrollbarContext = injectScrollAreaScrollbarContext();
    const { forwardRef, currentElement: scrollbar } = useForwardExpose();
    const prevWebkitUserSelectRef = ref83("");
    const rectRef = ref83();
    function handleDragScroll(event) {
      if (rectRef.value) {
        const x = event.clientX - rectRef.value?.left;
        const y = event.clientY - rectRef.value?.top;
        emit("onDragScroll", {
          x,
          y
        });
      }
    }
    function handlePointerDown2(event) {
      const mainPointer = 0;
      if (event.button === mainPointer) {
        const element = event.target;
        element.setPointerCapture(event.pointerId);
        rectRef.value = scrollbar.value.getBoundingClientRect();
        prevWebkitUserSelectRef.value = document.body.style.webkitUserSelect;
        document.body.style.webkitUserSelect = "none";
        if (rootContext.viewport) rootContext.viewport.value.style.scrollBehavior = "auto";
        handleDragScroll(event);
      }
    }
    function handlePointerMove2(event) {
      handleDragScroll(event);
    }
    function handlePointerUp2(event) {
      const element = event.target;
      if (element.hasPointerCapture(event.pointerId)) element.releasePointerCapture(event.pointerId);
      document.body.style.webkitUserSelect = prevWebkitUserSelectRef.value;
      if (rootContext.viewport) rootContext.viewport.value.style.scrollBehavior = "";
      rectRef.value = void 0;
    }
    function handleWheel(event) {
      const element = event.target;
      const isScrollbarWheel = scrollbar.value?.contains(element);
      const maxScrollPos = scrollbarVisibleContext.sizes.value.content - scrollbarVisibleContext.sizes.value.viewport;
      if (isScrollbarWheel) scrollbarVisibleContext.handleWheelScroll(event, maxScrollPos);
    }
    onMounted38(() => {
      document.addEventListener("wheel", handleWheel, { passive: false });
    });
    onUnmounted18(() => {
      document.removeEventListener("wheel", handleWheel);
    });
    function handleSizeChange() {
      if (!scrollbar.value) return;
      if (props2.isHorizontal) scrollbarVisibleContext.handleSizeChange({
        content: rootContext.viewport.value?.scrollWidth ?? 0,
        viewport: rootContext.viewport.value?.offsetWidth ?? 0,
        scrollbar: {
          size: scrollbar.value.clientWidth ?? 0,
          paddingStart: toInt(getComputedStyle(scrollbar.value).paddingLeft),
          paddingEnd: toInt(getComputedStyle(scrollbar.value).paddingRight)
        }
      });
      else scrollbarVisibleContext.handleSizeChange({
        content: rootContext.viewport.value?.scrollHeight ?? 0,
        viewport: rootContext.viewport.value?.offsetHeight ?? 0,
        scrollbar: {
          size: scrollbar.value?.clientHeight ?? 0,
          paddingStart: toInt(getComputedStyle(scrollbar.value).paddingLeft),
          paddingEnd: toInt(getComputedStyle(scrollbar.value).paddingRight)
        }
      });
    }
    useResizeObserver(scrollbar, handleSizeChange);
    useResizeObserver(rootContext.content, handleSizeChange);
    return (_ctx, _cache) => {
      return openBlock275(), createBlock269(unref278(Primitive), {
        ref: unref278(forwardRef),
        style: { "position": "absolute" },
        "data-scrollbarimpl": "",
        as: unref278(scrollbarContext).as.value,
        "as-child": unref278(scrollbarContext).asChild.value,
        onPointerdown: handlePointerDown2,
        onPointermove: handlePointerMove2,
        onPointerup: handlePointerUp2
      }, {
        default: withCtx271(() => [renderSlot275(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});
var ScrollAreaScrollbarImpl_default = ScrollAreaScrollbarImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaThumb.js
import { computed as computed94, createBlock as createBlock270, defineComponent as defineComponent284, onUnmounted as onUnmounted19, openBlock as openBlock276, ref as ref84, renderSlot as renderSlot276, unref as unref279, withCtx as withCtx272 } from "vue";
var ScrollAreaThumb_vue_vue_type_script_setup_true_lang_default = defineComponent284({
  __name: "ScrollAreaThumb",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectScrollAreaRootContext();
    const scrollbarContextVisible = injectScrollAreaScrollbarVisibleContext();
    function handlePointerDown2(event) {
      const thumb = event.target;
      const thumbRect = thumb.getBoundingClientRect();
      const x = event.clientX - thumbRect.left;
      const y = event.clientY - thumbRect.top;
      scrollbarContextVisible.handleThumbDown(event, {
        x,
        y
      });
    }
    function handlePointerUp2(event) {
      scrollbarContextVisible.handleThumbUp(event);
    }
    const { forwardRef, currentElement: thumbElement } = useForwardExpose();
    const removeUnlinkedScrollListenerRef = ref84();
    const viewport = computed94(() => rootContext.viewport.value);
    function handleScroll() {
      if (!removeUnlinkedScrollListenerRef.value) {
        const listener = addUnlinkedScrollListener(viewport.value, scrollbarContextVisible.onThumbPositionChange);
        removeUnlinkedScrollListenerRef.value = listener;
        scrollbarContextVisible.onThumbPositionChange();
      }
    }
    const sizes = computed94(() => scrollbarContextVisible.sizes.value);
    watchOnce(sizes, () => {
      scrollbarContextVisible.onThumbChange(thumbElement.value);
      if (viewport.value) {
        scrollbarContextVisible.onThumbPositionChange();
        viewport.value.addEventListener("scroll", handleScroll);
      }
    });
    onUnmounted19(() => {
      viewport.value.removeEventListener("scroll", handleScroll);
      rootContext.viewport.value?.removeEventListener("scroll", handleScroll);
    });
    return (_ctx, _cache) => {
      return openBlock276(), createBlock270(unref279(Primitive), {
        ref: unref279(forwardRef),
        "data-state": unref279(scrollbarContextVisible).hasThumb ? "visible" : "hidden",
        style: {
          width: "var(--reka-scroll-area-thumb-width)",
          height: "var(--reka-scroll-area-thumb-height)"
        },
        "as-child": props2.asChild,
        as: _ctx.as,
        onPointerdown: handlePointerDown2,
        onPointerup: handlePointerUp2
      }, {
        default: withCtx272(() => [renderSlot276(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "data-state",
        "as-child",
        "as"
      ]);
    };
  }
});
var ScrollAreaThumb_default = ScrollAreaThumb_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ScrollArea/ScrollAreaViewport.js
import { Fragment as Fragment8, createElementBlock as createElementBlock10, createElementVNode as createElementVNode3, createTextVNode as createTextVNode24, createVNode as createVNode50, defineComponent as defineComponent285, mergeProps as mergeProps123, normalizeStyle as normalizeStyle9, onMounted as onMounted39, openBlock as openBlock277, ref as ref85, renderSlot as renderSlot277, toRefs as toRefs38, unref as unref280, withCtx as withCtx273 } from "vue";
var ScrollAreaViewport_vue_vue_type_script_setup_true_lang_default = defineComponent285({
  inheritAttrs: false,
  __name: "ScrollAreaViewport",
  props: {
    nonce: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props, { expose: __expose }) {
    const props2 = __props;
    const { nonce: propNonce } = toRefs38(props2);
    const nonce = useNonce(propNonce);
    const rootContext = injectScrollAreaRootContext();
    const viewportElement = ref85();
    onMounted39(() => {
      rootContext.onViewportChange(viewportElement.value);
      rootContext.onContentChange(contentElement.value);
    });
    __expose({ viewportElement });
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock277(), createElementBlock10(Fragment8, null, [createElementVNode3("div", mergeProps123({
        ref_key: "viewportElement",
        ref: viewportElement,
        "data-reka-scroll-area-viewport": "",
        style: {
          overflowX: unref280(rootContext).scrollbarXEnabled.value ? "scroll" : "hidden",
          overflowY: unref280(rootContext).scrollbarYEnabled.value ? "scroll" : "hidden"
        }
      }, _ctx.$attrs, { tabindex: 0 }), [createVNode50(unref280(Primitive), {
        ref: unref280(forwardRef),
        style: normalizeStyle9({ minWidth: unref280(rootContext).scrollbarXEnabled.value ? "fit-content" : void 0 }),
        "as-child": props2.asChild,
        as: _ctx.as
      }, {
        default: withCtx273(() => [renderSlot277(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "style",
        "as-child",
        "as"
      ])], 16), createVNode50(unref280(Primitive), {
        as: "style",
        nonce: unref280(nonce)
      }, {
        default: withCtx273(() => _cache[0] || (_cache[0] = [createTextVNode24(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-reka-scroll-area-viewport]::-webkit-scrollbar { display:none; } ")])),
        _: 1,
        __: [0]
      }, 8, ["nonce"])], 64);
    };
  }
});
var ScrollAreaViewport_default = ScrollAreaViewport_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/BubbleSelect.js
import { createBlock as createBlock271, createElementVNode as createElementVNode4, defineComponent as defineComponent286, mergeProps as mergeProps124, openBlock as openBlock278, ref as ref86, renderSlot as renderSlot278, unref as unref281, watch as watch33, withCtx as withCtx274 } from "vue";
var BubbleSelect_vue_vue_type_script_setup_true_lang_default = defineComponent286({
  __name: "BubbleSelect",
  props: {
    autocomplete: {
      type: String,
      required: false
    },
    autofocus: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    form: {
      type: String,
      required: false
    },
    multiple: {
      type: Boolean,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    },
    size: {
      type: Number,
      required: false
    },
    value: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const selectElement = ref86();
    watch33(() => props2.value, (cur, prev) => {
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(selectProto, "value");
      const setValue = descriptor.set;
      if (cur !== prev && setValue && selectElement.value) {
        const event = new Event("change", { bubbles: true });
        setValue.call(selectElement.value, cur);
        selectElement.value.dispatchEvent(event);
      }
    });
    return (_ctx, _cache) => {
      return openBlock278(), createBlock271(unref281(VisuallyHidden_default), { "as-child": "" }, {
        default: withCtx274(() => [createElementVNode4("select", mergeProps124({
          ref_key: "selectElement",
          ref: selectElement
        }, props2), [renderSlot278(_ctx.$slots, "default")], 16)]),
        _: 3
      });
    };
  }
});
var BubbleSelect_default = BubbleSelect_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/utils.js
var OPEN_KEYS = [
  " ",
  "Enter",
  "ArrowUp",
  "ArrowDown"
];
var SELECTION_KEYS2 = [" ", "Enter"];
var CONTENT_MARGIN = 10;
function valueComparator2(value, currentValue, comparator) {
  if (value === void 0) return false;
  else if (Array.isArray(value)) return value.some((val) => compare2(val, currentValue, comparator));
  else return compare2(value, currentValue, comparator);
}
function compare2(value, currentValue, comparator) {
  if (value === void 0 || currentValue === void 0) return false;
  if (typeof value === "string") return value === currentValue;
  if (typeof comparator === "function") return comparator(value, currentValue);
  if (typeof comparator === "string") return value?.[comparator] === currentValue?.[comparator];
  return isEqual(value, currentValue);
}
function shouldShowPlaceholder(value) {
  return value === void 0 || value === null || value === "" || Array.isArray(value) && value.length === 0;
}

// node_modules/reka-ui/dist/Select/SelectRoot.js
import { Fragment as Fragment9, computed as computed95, createBlock as createBlock272, createCommentVNode as createCommentVNode27, createElementBlock as createElementBlock11, defineComponent as defineComponent287, mergeProps as mergeProps125, openBlock as openBlock279, ref as ref87, renderList as renderList3, renderSlot as renderSlot279, toRefs as toRefs39, unref as unref282, withCtx as withCtx275 } from "vue";
var _hoisted_15 = {
  key: 0,
  value: ""
};
var [injectSelectRootContext, provideSelectRootContext] = createContext("SelectRoot");
var SelectRoot_vue_vue_type_script_setup_true_lang_default = defineComponent287({
  inheritAttrs: false,
  __name: "SelectRoot",
  props: {
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    },
    modelValue: {
      type: null,
      required: false,
      default: void 0
    },
    by: {
      type: [String, Function],
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    multiple: {
      type: Boolean,
      required: false
    },
    autocomplete: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue", "update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { required, disabled, multiple, dir: propDir } = toRefs39(props2);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: props2.modelValue === void 0,
      deep: true
    });
    const open = useVModel(props2, "open", emits, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    const triggerElement = ref87();
    const valueElement = ref87();
    const triggerPointerDownPosRef = ref87({
      x: 0,
      y: 0
    });
    const isEmptyModelValue = computed95(() => {
      if (multiple.value && Array.isArray(modelValue.value)) return modelValue.value?.length === 0;
      else return isNullish(modelValue.value);
    });
    useCollection({ isProvider: true });
    const dir = useDirection(propDir);
    const isFormControl = useFormControl(triggerElement);
    const optionsSet = ref87(/* @__PURE__ */ new Set());
    const nativeSelectKey = computed95(() => {
      return Array.from(optionsSet.value).map((option) => option.value).join(";");
    });
    function handleValueChange(value) {
      if (multiple.value) {
        const array = Array.isArray(modelValue.value) ? [...modelValue.value] : [];
        const index = array.findIndex((i) => compare2(i, value, props2.by));
        index === -1 ? array.push(value) : array.splice(index, 1);
        modelValue.value = [...array];
      } else modelValue.value = value;
    }
    function getOption(value) {
      return Array.from(optionsSet.value).find((option) => valueComparator2(value, option.value, props2.by));
    }
    provideSelectRootContext({
      triggerElement,
      onTriggerChange: (node) => {
        triggerElement.value = node;
      },
      valueElement,
      onValueElementChange: (node) => {
        valueElement.value = node;
      },
      contentId: "",
      modelValue,
      onValueChange: handleValueChange,
      by: props2.by,
      open,
      multiple,
      required,
      onOpenChange: (value) => {
        open.value = value;
      },
      dir,
      triggerPointerDownPosRef,
      disabled,
      isEmptyModelValue,
      optionsSet,
      onOptionAdd: (option) => {
        const existingOption = getOption(option.value);
        if (existingOption) optionsSet.value.delete(existingOption);
        optionsSet.value.add(option);
      },
      onOptionRemove: (option) => {
        const existingOption = getOption(option.value);
        if (existingOption) optionsSet.value.delete(existingOption);
      }
    });
    return (_ctx, _cache) => {
      return openBlock279(), createBlock272(unref282(PopperRoot_default), null, {
        default: withCtx275(() => [renderSlot279(_ctx.$slots, "default", {
          modelValue: unref282(modelValue),
          open: unref282(open)
        }), unref282(isFormControl) ? (openBlock279(), createBlock272(BubbleSelect_default, {
          key: nativeSelectKey.value,
          "aria-hidden": "true",
          tabindex: "-1",
          multiple: unref282(multiple),
          required: unref282(required),
          name: _ctx.name,
          autocomplete: _ctx.autocomplete,
          disabled: unref282(disabled),
          value: unref282(modelValue)
        }, {
          default: withCtx275(() => [unref282(isNullish)(unref282(modelValue)) ? (openBlock279(), createElementBlock11("option", _hoisted_15)) : createCommentVNode27("v-if", true), (openBlock279(true), createElementBlock11(Fragment9, null, renderList3(Array.from(optionsSet.value), (option) => {
            return openBlock279(), createElementBlock11("option", mergeProps125({ key: option.value ?? "" }, { ref_for: true }, option), null, 16);
          }), 128))]),
          _: 1
        }, 8, [
          "multiple",
          "required",
          "name",
          "autocomplete",
          "disabled",
          "value"
        ])) : createCommentVNode27("v-if", true)]),
        _: 3
      });
    };
  }
});
var SelectRoot_default = SelectRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectPopperPosition.js
import { createBlock as createBlock273, defineComponent as defineComponent288, mergeProps as mergeProps126, openBlock as openBlock280, renderSlot as renderSlot280, unref as unref283, withCtx as withCtx276 } from "vue";
var SelectPopperPosition_vue_vue_type_script_setup_true_lang_default = defineComponent288({
  __name: "SelectPopperPosition",
  props: {
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false,
      default: CONTENT_MARGIN
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const forwarded = useForwardProps(props2);
    return (_ctx, _cache) => {
      return openBlock280(), createBlock273(unref283(PopperContent_default), mergeProps126(unref283(forwarded), { style: {
        "boxSizing": "border-box",
        "--reka-select-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-select-content-available-width": "var(--reka-popper-available-width)",
        "--reka-select-content-available-height": "var(--reka-popper-available-height)",
        "--reka-select-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-select-trigger-height": "var(--reka-popper-anchor-height)"
      } }), {
        default: withCtx276(() => [renderSlot280(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var SelectPopperPosition_default = SelectPopperPosition_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectContentImpl.js
import { computed as computed96, createBlock as createBlock274, createVNode as createVNode51, defineComponent as defineComponent289, mergeProps as mergeProps127, openBlock as openBlock281, ref as ref88, renderSlot as renderSlot281, resolveDynamicComponent as resolveDynamicComponent6, unref as unref284, watch as watch34, watchEffect as watchEffect19, withCtx as withCtx277, withModifiers as withModifiers17 } from "vue";
var SelectContentDefaultContextValue = {
  onViewportChange: () => {
  },
  itemTextRefCallback: () => {
  },
  itemRefCallback: () => {
  }
};
var [injectSelectContentContext, provideSelectContentContext] = createContext("SelectContent");
var SelectContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent289({
  __name: "SelectContentImpl",
  props: {
    position: {
      type: String,
      required: false,
      default: "item-aligned"
    },
    bodyLock: {
      type: Boolean,
      required: false,
      default: true
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false,
      default: "start"
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectSelectRootContext();
    useFocusGuards();
    useBodyScrollLock(props2.bodyLock);
    const { CollectionSlot, getItems } = useCollection();
    const content = ref88();
    useHideOthers(content);
    const { search, handleTypeaheadSearch } = useTypeahead();
    const viewport = ref88();
    const selectedItem = ref88();
    const selectedItemText = ref88();
    const isPositioned = ref88(false);
    const firstValidItemFoundRef = ref88(false);
    const firstSelectedItemInArrayFoundRef = ref88(false);
    function focusSelectedItem() {
      if (selectedItem.value && content.value) focusFirst2([selectedItem.value, content.value]);
    }
    watch34(isPositioned, () => {
      focusSelectedItem();
    });
    const { onOpenChange, triggerPointerDownPosRef } = rootContext;
    watchEffect19((cleanupFn) => {
      if (!content.value) return;
      let pointerMoveDelta = {
        x: 0,
        y: 0
      };
      const handlePointerMove2 = (event) => {
        pointerMoveDelta = {
          x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.value?.x ?? 0)),
          y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.value?.y ?? 0))
        };
      };
      const handlePointerUp2 = (event) => {
        if (event.pointerType === "touch") return;
        if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) event.preventDefault();
        else if (!content.value?.contains(event.target)) onOpenChange(false);
        document.removeEventListener("pointermove", handlePointerMove2);
        triggerPointerDownPosRef.value = null;
      };
      if (triggerPointerDownPosRef.value !== null) {
        document.addEventListener("pointermove", handlePointerMove2);
        document.addEventListener("pointerup", handlePointerUp2, {
          capture: true,
          once: true
        });
      }
      cleanupFn(() => {
        document.removeEventListener("pointermove", handlePointerMove2);
        document.removeEventListener("pointerup", handlePointerUp2, { capture: true });
      });
    });
    function handleKeyDown(event) {
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      if (event.key === "Tab") event.preventDefault();
      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key, getItems());
      if ([
        "ArrowUp",
        "ArrowDown",
        "Home",
        "End"
      ].includes(event.key)) {
        const collectionItems = getItems().map((i) => i.ref);
        let candidateNodes = [...collectionItems];
        if (["ArrowUp", "End"].includes(event.key)) candidateNodes = candidateNodes.slice().reverse();
        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
          const currentElement = event.target;
          const currentIndex = candidateNodes.indexOf(currentElement);
          candidateNodes = candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(() => focusFirst2(candidateNodes));
        event.preventDefault();
      }
    }
    const pickedProps = computed96(() => {
      if (props2.position === "popper") return props2;
      else return {};
    });
    const forwardedProps = useForwardProps(pickedProps.value);
    provideSelectContentContext({
      content,
      viewport,
      onViewportChange: (node) => {
        viewport.value = node;
      },
      itemRefCallback: (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.value && !disabled;
        const isSelectedItem = valueComparator2(rootContext.modelValue.value, value, rootContext.by);
        if (rootContext.multiple.value) {
          if (firstSelectedItemInArrayFoundRef.value) return;
          if (isSelectedItem || isFirstValidItem) {
            selectedItem.value = node;
            if (isSelectedItem) firstSelectedItemInArrayFoundRef.value = true;
          }
        } else if (isSelectedItem || isFirstValidItem) selectedItem.value = node;
        if (isFirstValidItem) firstValidItemFoundRef.value = true;
      },
      selectedItem,
      selectedItemText,
      onItemLeave: () => {
        content.value?.focus();
      },
      itemTextRefCallback: (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.value && !disabled;
        const isSelectedItem = valueComparator2(rootContext.modelValue.value, value, rootContext.by);
        if (isSelectedItem || isFirstValidItem) selectedItemText.value = node;
      },
      focusSelectedItem,
      position: props2.position,
      isPositioned,
      searchRef: search
    });
    return (_ctx, _cache) => {
      return openBlock281(), createBlock274(unref284(CollectionSlot), null, {
        default: withCtx277(() => [createVNode51(unref284(FocusScope_default), {
          "as-child": "",
          onMountAutoFocus: _cache[6] || (_cache[6] = withModifiers17(() => {
          }, ["prevent"])),
          onUnmountAutoFocus: _cache[7] || (_cache[7] = (event) => {
            emits("closeAutoFocus", event);
            if (event.defaultPrevented) return;
            unref284(rootContext).triggerElement.value?.focus({ preventScroll: true });
            event.preventDefault();
          })
        }, {
          default: withCtx277(() => [createVNode51(unref284(DismissableLayer_default), {
            "as-child": "",
            "disable-outside-pointer-events": "",
            onFocusOutside: _cache[2] || (_cache[2] = withModifiers17(() => {
            }, ["prevent"])),
            onDismiss: _cache[3] || (_cache[3] = ($event) => unref284(rootContext).onOpenChange(false)),
            onEscapeKeyDown: _cache[4] || (_cache[4] = ($event) => emits("escapeKeyDown", $event)),
            onPointerDownOutside: _cache[5] || (_cache[5] = ($event) => emits("pointerDownOutside", $event))
          }, {
            default: withCtx277(() => [(openBlock281(), createBlock274(resolveDynamicComponent6(_ctx.position === "popper" ? SelectPopperPosition_default : SelectItemAlignedPosition_default), mergeProps127({
              ..._ctx.$attrs,
              ...unref284(forwardedProps)
            }, {
              id: unref284(rootContext).contentId,
              ref: (vnode) => {
                const el = unref284(unrefElement)(vnode);
                if (el?.hasAttribute("data-reka-popper-content-wrapper")) content.value = el.firstElementChild;
                else content.value = el;
                return void 0;
              },
              role: "listbox",
              "data-state": unref284(rootContext).open.value ? "open" : "closed",
              dir: unref284(rootContext).dir.value,
              style: {
                display: "flex",
                flexDirection: "column",
                outline: "none"
              },
              onContextmenu: _cache[0] || (_cache[0] = withModifiers17(() => {
              }, ["prevent"])),
              onPlaced: _cache[1] || (_cache[1] = ($event) => isPositioned.value = true),
              onKeydown: handleKeyDown
            }), {
              default: withCtx277(() => [renderSlot281(_ctx.$slots, "default")]),
              _: 3
            }, 16, [
              "id",
              "data-state",
              "dir",
              "onKeydown"
            ]))]),
            _: 3
          })]),
          _: 3
        })]),
        _: 3
      });
    };
  }
});
var SelectContentImpl_default = SelectContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectItemAlignedPosition.js
import { createElementBlock as createElementBlock12, createVNode as createVNode52, defineComponent as defineComponent290, mergeProps as mergeProps128, nextTick as nextTick28, normalizeStyle as normalizeStyle10, onMounted as onMounted40, openBlock as openBlock282, ref as ref89, renderSlot as renderSlot282, unref as unref285, withCtx as withCtx278 } from "vue";
var [injectSelectItemAlignedPositionContext, provideSelectItemAlignedPositionContext] = createContext("SelectItemAlignedPosition");
var SelectItemAlignedPosition_vue_vue_type_script_setup_true_lang_default = defineComponent290({
  inheritAttrs: false,
  __name: "SelectItemAlignedPosition",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["placed"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { getItems } = useCollection();
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext();
    const shouldExpandOnScrollRef = ref89(false);
    const shouldRepositionRef = ref89(true);
    const contentWrapperElement = ref89();
    const { forwardRef, currentElement: contentElement } = useForwardExpose();
    const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
    function position() {
      if (rootContext.triggerElement.value && rootContext.valueElement.value && contentWrapperElement.value && contentElement.value && viewport?.value && selectedItem?.value && selectedItemText?.value) {
        const triggerRect = rootContext.triggerElement.value.getBoundingClientRect();
        const contentRect = contentElement.value.getBoundingClientRect();
        const valueNodeRect = rootContext.valueElement.value.getBoundingClientRect();
        const itemTextRect = selectedItemText.value.getBoundingClientRect();
        if (rootContext.dir.value !== "rtl") {
          const itemTextOffset = itemTextRect.left - contentRect.left;
          const left = valueNodeRect.left - itemTextOffset;
          const leftDelta = triggerRect.left - left;
          const minContentWidth = triggerRect.width + leftDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const rightEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedLeft = clamp(left, CONTENT_MARGIN, Math.max(CONTENT_MARGIN, rightEdge - contentWidth));
          contentWrapperElement.value.style.minWidth = `${minContentWidth}px`;
          contentWrapperElement.value.style.left = `${clampedLeft}px`;
        } else {
          const itemTextOffset = contentRect.right - itemTextRect.right;
          const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
          const rightDelta = window.innerWidth - triggerRect.right - right;
          const minContentWidth = triggerRect.width + rightDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const leftEdge = window.innerWidth - CONTENT_MARGIN;
          const clampedRight = clamp(right, CONTENT_MARGIN, Math.max(CONTENT_MARGIN, leftEdge - contentWidth));
          contentWrapperElement.value.style.minWidth = `${minContentWidth}px`;
          contentWrapperElement.value.style.right = `${clampedRight}px`;
        }
        const items = getItems().map((i) => i.ref);
        const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
        const itemsHeight = viewport.value.scrollHeight;
        const contentStyles = window.getComputedStyle(contentElement.value);
        const contentBorderTopWidth = Number.parseInt(contentStyles.borderTopWidth, 10);
        const contentPaddingTop = Number.parseInt(contentStyles.paddingTop, 10);
        const contentBorderBottomWidth = Number.parseInt(contentStyles.borderBottomWidth, 10);
        const contentPaddingBottom = Number.parseInt(contentStyles.paddingBottom, 10);
        const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
        const minContentHeight = Math.min(selectedItem.value.offsetHeight * 5, fullContentHeight);
        const viewportStyles = window.getComputedStyle(viewport.value);
        const viewportPaddingTop = Number.parseInt(viewportStyles.paddingTop, 10);
        const viewportPaddingBottom = Number.parseInt(viewportStyles.paddingBottom, 10);
        const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
        const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
        const selectedItemHalfHeight = selectedItem.value.offsetHeight / 2;
        const itemOffsetMiddle = selectedItem.value.offsetTop + selectedItemHalfHeight;
        const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
        const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
        const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
        if (willAlignWithoutTopOverflow) {
          const isLastItem = selectedItem.value === items[items.length - 1];
          contentWrapperElement.value.style.bottom = `0px`;
          const viewportOffsetBottom = contentElement.value.clientHeight - viewport.value.offsetTop - viewport.value.offsetHeight;
          const clampedTriggerMiddleToBottomEdge = Math.max(triggerMiddleToBottomEdge, selectedItemHalfHeight + (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth);
          const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
          contentWrapperElement.value.style.height = `${height}px`;
        } else {
          const isFirstItem = selectedItem.value === items[0];
          contentWrapperElement.value.style.top = `0px`;
          const clampedTopEdgeToTriggerMiddle = Math.max(topEdgeToTriggerMiddle, contentBorderTopWidth + viewport.value.offsetTop + (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight);
          const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
          contentWrapperElement.value.style.height = `${height}px`;
          viewport.value.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.value.offsetTop;
        }
        contentWrapperElement.value.style.margin = `${CONTENT_MARGIN}px 0`;
        contentWrapperElement.value.style.minHeight = `${minContentHeight}px`;
        contentWrapperElement.value.style.maxHeight = `${availableHeight}px`;
        emits("placed");
        requestAnimationFrame(() => shouldExpandOnScrollRef.value = true);
      }
    }
    const contentZIndex = ref89("");
    onMounted40(async () => {
      await nextTick28();
      position();
      if (contentElement.value) contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
    });
    function handleScrollButtonChange(node) {
      if (node && shouldRepositionRef.value === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.value = false;
      }
    }
    useResizeObserver(rootContext.triggerElement, () => {
      position();
    });
    provideSelectItemAlignedPositionContext({
      contentWrapper: contentWrapperElement,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange
    });
    return (_ctx, _cache) => {
      return openBlock282(), createElementBlock12("div", {
        ref_key: "contentWrapperElement",
        ref: contentWrapperElement,
        style: normalizeStyle10({
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          zIndex: contentZIndex.value
        })
      }, [createVNode52(unref285(Primitive), mergeProps128({
        ref: unref285(forwardRef),
        style: {
          boxSizing: "border-box",
          maxHeight: "100%"
        }
      }, {
        ..._ctx.$attrs,
        ...props2
      }), {
        default: withCtx278(() => [renderSlot282(_ctx.$slots, "default")]),
        _: 3
      }, 16)], 4);
    };
  }
});
var SelectItemAlignedPosition_default = SelectItemAlignedPosition_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectArrow.js
import { createBlock as createBlock275, createCommentVNode as createCommentVNode28, defineComponent as defineComponent291, guardReactiveProps as guardReactiveProps98, mergeProps as mergeProps129, normalizeProps as normalizeProps98, openBlock as openBlock283, renderSlot as renderSlot283, unref as unref286, withCtx as withCtx279 } from "vue";
var SelectArrow_vue_vue_type_script_setup_true_lang_default = defineComponent291({
  __name: "SelectArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    rounded: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext(SelectContentDefaultContextValue);
    return (_ctx, _cache) => {
      return unref286(rootContext).open.value && unref286(contentContext).position === "popper" ? (openBlock283(), createBlock275(unref286(PopperArrow_default), normalizeProps98(mergeProps129({ key: 0 }, props2)), {
        default: withCtx279(() => [renderSlot283(_ctx.$slots, "default")]),
        _: 3
      }, 16)) : createCommentVNode28("v-if", true);
    };
  }
});
var SelectArrow_default = SelectArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectProvider.js
import { defineComponent as defineComponent292, renderSlot as renderSlot284 } from "vue";
var SelectProvider_vue_vue_type_script_setup_true_lang_default = defineComponent292({
  inheritAttrs: false,
  __name: "SelectProvider",
  props: { context: {
    type: Object,
    required: true
  } },
  setup(__props) {
    const props2 = __props;
    provideSelectRootContext(props2.context);
    provideSelectContentContext(SelectContentDefaultContextValue);
    return (_ctx, _cache) => {
      return renderSlot284(_ctx.$slots, "default");
    };
  }
});
var SelectProvider_default = SelectProvider_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectContent.js
import { Teleport as Teleport4, computed as computed97, createBlock as createBlock276, createCommentVNode as createCommentVNode29, createElementBlock as createElementBlock13, createVNode as createVNode53, defineComponent as defineComponent293, guardReactiveProps as guardReactiveProps99, normalizeProps as normalizeProps99, onMounted as onMounted41, openBlock as openBlock284, ref as ref90, renderSlot as renderSlot285, unref as unref287, watch as watch35, withCtx as withCtx280 } from "vue";
var _hoisted_16 = { key: 1 };
var SelectContent_vue_vue_type_script_setup_true_lang_default = defineComponent293({
  inheritAttrs: false,
  __name: "SelectContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    position: {
      type: String,
      required: false
    },
    bodyLock: {
      type: Boolean,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    sideFlip: {
      type: Boolean,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    alignFlip: {
      type: Boolean,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    },
    disableUpdateOnLayoutShift: {
      type: Boolean,
      required: false
    },
    prioritizePosition: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "closeAutoFocus",
    "escapeKeyDown",
    "pointerDownOutside"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const forwarded = useForwardPropsEmits(props2, emits);
    const rootContext = injectSelectRootContext();
    const fragment = ref90();
    onMounted41(() => {
      fragment.value = new DocumentFragment();
    });
    const presenceRef = ref90();
    const present = computed97(() => props2.forceMount || rootContext.open.value);
    const renderPresence = ref90(present.value);
    watch35(present, () => {
      setTimeout(() => renderPresence.value = present.value);
    });
    return (_ctx, _cache) => {
      return present.value || renderPresence.value || presenceRef.value?.present ? (openBlock284(), createBlock276(unref287(Presence_default), {
        key: 0,
        ref_key: "presenceRef",
        ref: presenceRef,
        present: present.value
      }, {
        default: withCtx280(() => [createVNode53(SelectContentImpl_default, normalizeProps99(guardReactiveProps99({
          ...unref287(forwarded),
          ..._ctx.$attrs
        })), {
          default: withCtx280(() => [renderSlot285(_ctx.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      }, 8, ["present"])) : fragment.value ? (openBlock284(), createElementBlock13("div", _hoisted_16, [(openBlock284(), createBlock276(Teleport4, { to: fragment.value }, [createVNode53(SelectProvider_default, { context: unref287(rootContext) }, {
        default: withCtx280(() => [renderSlot285(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["context"])], 8, ["to"]))])) : createCommentVNode29("v-if", true);
    };
  }
});
var SelectContent_default = SelectContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectGroup.js
import { createBlock as createBlock277, defineComponent as defineComponent294, mergeProps as mergeProps130, openBlock as openBlock285, renderSlot as renderSlot286, unref as unref288, withCtx as withCtx281 } from "vue";
var [injectSelectGroupContext, provideSelectGroupContext] = createContext("SelectGroup");
var SelectGroup_vue_vue_type_script_setup_true_lang_default = defineComponent294({
  __name: "SelectGroup",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const id = useId2(void 0, "reka-select-group");
    provideSelectGroupContext({ id });
    return (_ctx, _cache) => {
      return openBlock285(), createBlock277(unref288(Primitive), mergeProps130({ role: "group" }, props2, { "aria-labelledby": unref288(id) }), {
        default: withCtx281(() => [renderSlot286(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["aria-labelledby"]);
    };
  }
});
var SelectGroup_default = SelectGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectIcon.js
import { createBlock as createBlock278, createTextVNode as createTextVNode25, defineComponent as defineComponent295, openBlock as openBlock286, renderSlot as renderSlot287, unref as unref289, withCtx as withCtx282 } from "vue";
var SelectIcon_vue_vue_type_script_setup_true_lang_default = defineComponent295({
  __name: "SelectIcon",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock286(), createBlock278(unref289(Primitive), {
        "aria-hidden": "true",
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, {
        default: withCtx282(() => [renderSlot287(_ctx.$slots, "default", {}, () => [_cache[0] || (_cache[0] = createTextVNode25("▼"))])]),
        _: 3
      }, 8, ["as", "as-child"]);
    };
  }
});
var SelectIcon_default = SelectIcon_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectItem.js
import { computed as computed98, createBlock as createBlock279, createVNode as createVNode54, defineComponent as defineComponent296, nextTick as nextTick29, onMounted as onMounted42, openBlock as openBlock287, ref as ref91, renderSlot as renderSlot288, toRefs as toRefs40, unref as unref290, withCtx as withCtx283, withModifiers as withModifiers18 } from "vue";
var [injectSelectItemContext, provideSelectItemContext] = createContext("SelectItem");
var SelectItem_vue_vue_type_script_setup_true_lang_default = defineComponent296({
  __name: "SelectItem",
  props: {
    value: {
      type: null,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    textValue: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled } = toRefs40(props2);
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext();
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const isSelected = computed98(() => valueComparator2(rootContext.modelValue?.value, props2.value, rootContext.by));
    const isFocused = ref91(false);
    const textValue = ref91(props2.textValue ?? "");
    const textId = useId2(void 0, "reka-select-item-text");
    const SELECT_SELECT = "select.select";
    async function handleSelectCustomEvent(ev) {
      if (ev.defaultPrevented) return;
      const eventDetail = {
        originalEvent: ev,
        value: props2.value
      };
      handleAndDispatchCustomEvent(SELECT_SELECT, handleSelect2, eventDetail);
    }
    async function handleSelect2(ev) {
      await nextTick29();
      emits("select", ev);
      if (ev.defaultPrevented) return;
      if (!disabled.value) {
        rootContext.onValueChange(props2.value);
        if (!rootContext.multiple.value) rootContext.onOpenChange(false);
      }
    }
    async function handlePointerMove2(event) {
      await nextTick29();
      if (event.defaultPrevented) return;
      if (disabled.value) contentContext.onItemLeave?.();
      else event.currentTarget?.focus({ preventScroll: true });
    }
    async function handlePointerLeave(event) {
      await nextTick29();
      if (event.defaultPrevented) return;
      if (event.currentTarget === getActiveElement()) contentContext.onItemLeave?.();
    }
    async function handleKeyDown(event) {
      await nextTick29();
      if (event.defaultPrevented) return;
      const isTypingAhead = contentContext.searchRef?.value !== "";
      if (isTypingAhead && event.key === " ") return;
      if (SELECTION_KEYS2.includes(event.key)) handleSelectCustomEvent(event);
      if (event.key === " ") event.preventDefault();
    }
    if (props2.value === "") throw new Error("A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    onMounted42(() => {
      if (!currentElement.value) return;
      contentContext.itemRefCallback(currentElement.value, props2.value, props2.disabled);
    });
    provideSelectItemContext({
      value: props2.value,
      disabled,
      textId,
      isSelected,
      onItemTextChange: (node) => {
        textValue.value = ((textValue.value || node?.textContent) ?? "").trim();
      }
    });
    return (_ctx, _cache) => {
      return openBlock287(), createBlock279(unref290(CollectionItem), { value: { textValue: textValue.value } }, {
        default: withCtx283(() => [createVNode54(unref290(Primitive), {
          ref: unref290(forwardRef),
          role: "option",
          "aria-labelledby": unref290(textId),
          "data-highlighted": isFocused.value ? "" : void 0,
          "aria-selected": isSelected.value,
          "data-state": isSelected.value ? "checked" : "unchecked",
          "aria-disabled": unref290(disabled) || void 0,
          "data-disabled": unref290(disabled) ? "" : void 0,
          tabindex: unref290(disabled) ? void 0 : -1,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          onFocus: _cache[0] || (_cache[0] = ($event) => isFocused.value = true),
          onBlur: _cache[1] || (_cache[1] = ($event) => isFocused.value = false),
          onPointerup: handleSelectCustomEvent,
          onPointerdown: _cache[2] || (_cache[2] = (event) => {
            event.currentTarget.focus({ preventScroll: true });
          }),
          onTouchend: _cache[3] || (_cache[3] = withModifiers18(() => {
          }, ["prevent", "stop"])),
          onPointermove: handlePointerMove2,
          onPointerleave: handlePointerLeave,
          onKeydown: handleKeyDown
        }, {
          default: withCtx283(() => [renderSlot288(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "aria-labelledby",
          "data-highlighted",
          "aria-selected",
          "data-state",
          "aria-disabled",
          "data-disabled",
          "tabindex",
          "as",
          "as-child"
        ])]),
        _: 3
      }, 8, ["value"]);
    };
  }
});
var SelectItem_default = SelectItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectItemIndicator.js
import { createBlock as createBlock280, createCommentVNode as createCommentVNode30, defineComponent as defineComponent297, mergeProps as mergeProps131, openBlock as openBlock288, renderSlot as renderSlot289, unref as unref291, withCtx as withCtx284 } from "vue";
var SelectItemIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent297({
  __name: "SelectItemIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectSelectItemContext();
    return (_ctx, _cache) => {
      return unref291(itemContext).isSelected.value ? (openBlock288(), createBlock280(unref291(Primitive), mergeProps131({
        key: 0,
        "aria-hidden": "true"
      }, props2), {
        default: withCtx284(() => [renderSlot289(_ctx.$slots, "default")]),
        _: 3
      }, 16)) : createCommentVNode30("v-if", true);
    };
  }
});
var SelectItemIndicator_default = SelectItemIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectItemText.js
import { computed as computed99, createBlock as createBlock281, defineComponent as defineComponent298, mergeProps as mergeProps132, onMounted as onMounted43, onUnmounted as onUnmounted20, openBlock as openBlock289, renderSlot as renderSlot290, unref as unref292, withCtx as withCtx285 } from "vue";
var SelectItemText_vue_vue_type_script_setup_true_lang_default = defineComponent298({
  inheritAttrs: false,
  __name: "SelectItemText",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSelectRootContext();
    const contentContext = injectSelectContentContext();
    const itemContext = injectSelectItemContext();
    const { forwardRef, currentElement: itemTextElement } = useForwardExpose();
    const optionProps = computed99(() => {
      return {
        value: itemContext.value,
        disabled: itemContext.disabled.value,
        textContent: itemTextElement.value?.textContent ?? itemContext.value?.toString() ?? ""
      };
    });
    onMounted43(() => {
      if (!itemTextElement.value) return;
      itemContext.onItemTextChange(itemTextElement.value);
      contentContext.itemTextRefCallback(itemTextElement.value, itemContext.value, itemContext.disabled.value);
      rootContext.onOptionAdd(optionProps.value);
    });
    onUnmounted20(() => {
      rootContext.onOptionRemove(optionProps.value);
    });
    return (_ctx, _cache) => {
      return openBlock289(), createBlock281(unref292(Primitive), mergeProps132({
        id: unref292(itemContext).textId,
        ref: unref292(forwardRef)
      }, {
        ...props2,
        ..._ctx.$attrs
      }), {
        default: withCtx285(() => [renderSlot290(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var SelectItemText_default = SelectItemText_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectLabel.js
import { createBlock as createBlock282, defineComponent as defineComponent299, mergeProps as mergeProps133, openBlock as openBlock290, renderSlot as renderSlot291, unref as unref293, withCtx as withCtx286 } from "vue";
var SelectLabel_vue_vue_type_script_setup_true_lang_default = defineComponent299({
  __name: "SelectLabel",
  props: {
    for: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "div"
    }
  },
  setup(__props) {
    const props2 = __props;
    const groupContext = injectSelectGroupContext({ id: "" });
    return (_ctx, _cache) => {
      return openBlock290(), createBlock282(unref293(Primitive), mergeProps133(props2, { id: unref293(groupContext).id }), {
        default: withCtx286(() => [renderSlot291(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var SelectLabel_default = SelectLabel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectPortal.js
import { createBlock as createBlock283, defineComponent as defineComponent300, guardReactiveProps as guardReactiveProps100, normalizeProps as normalizeProps100, openBlock as openBlock291, renderSlot as renderSlot292, unref as unref294, withCtx as withCtx287 } from "vue";
var SelectPortal_vue_vue_type_script_setup_true_lang_default = defineComponent300({
  __name: "SelectPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock291(), createBlock283(unref294(Teleport_default), normalizeProps100(guardReactiveProps100(props2)), {
        default: withCtx287(() => [renderSlot292(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var SelectPortal_default = SelectPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectScrollButtonImpl.js
import { createBlock as createBlock284, defineComponent as defineComponent301, mergeProps as mergeProps134, onBeforeUnmount as onBeforeUnmount2, openBlock as openBlock292, ref as ref92, renderSlot as renderSlot293, unref as unref295, watchEffect as watchEffect20, withCtx as withCtx288 } from "vue";
var SelectScrollButtonImpl_vue_vue_type_script_setup_true_lang_default = defineComponent301({
  __name: "SelectScrollButtonImpl",
  emits: ["autoScroll"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const { getItems } = useCollection();
    const contentContext = injectSelectContentContext();
    const autoScrollTimerRef = ref92(null);
    function clearAutoScrollTimer() {
      if (autoScrollTimerRef.value !== null) {
        window.clearInterval(autoScrollTimerRef.value);
        autoScrollTimerRef.value = null;
      }
    }
    watchEffect20(() => {
      const activeItem = getItems().map((i) => i.ref).find((item) => item === getActiveElement());
      activeItem?.scrollIntoView({ block: "nearest" });
    });
    function handlePointerDown2() {
      if (autoScrollTimerRef.value === null) autoScrollTimerRef.value = window.setInterval(() => {
        emits("autoScroll");
      }, 50);
    }
    function handlePointerMove2() {
      contentContext.onItemLeave?.();
      if (autoScrollTimerRef.value === null) autoScrollTimerRef.value = window.setInterval(() => {
        emits("autoScroll");
      }, 50);
    }
    onBeforeUnmount2(() => clearAutoScrollTimer());
    return (_ctx, _cache) => {
      return openBlock292(), createBlock284(unref295(Primitive), mergeProps134({
        "aria-hidden": "true",
        style: { flexShrink: 0 }
      }, _ctx.$parent?.$props, {
        onPointerdown: handlePointerDown2,
        onPointermove: handlePointerMove2,
        onPointerleave: _cache[0] || (_cache[0] = () => {
          clearAutoScrollTimer();
        })
      }), {
        default: withCtx288(() => [renderSlot293(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var SelectScrollButtonImpl_default = SelectScrollButtonImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectScrollDownButton.js
import { createBlock as createBlock285, createCommentVNode as createCommentVNode31, defineComponent as defineComponent302, openBlock as openBlock293, ref as ref93, renderSlot as renderSlot294, unref as unref296, watch as watch36, watchEffect as watchEffect21, withCtx as withCtx289 } from "vue";
var SelectScrollDownButton_vue_vue_type_script_setup_true_lang_default = defineComponent302({
  __name: "SelectScrollDownButton",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const contentContext = injectSelectContentContext();
    const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
    const { forwardRef, currentElement } = useForwardExpose();
    const canScrollDown = ref93(false);
    watchEffect21((cleanupFn) => {
      if (contentContext.viewport?.value && contentContext.isPositioned?.value) {
        let handleScroll = function() {
          const maxScroll = viewport.scrollHeight - viewport.clientHeight;
          canScrollDown.value = Math.ceil(viewport.scrollTop) < maxScroll;
        };
        const viewport = contentContext.viewport.value;
        handleScroll();
        viewport.addEventListener("scroll", handleScroll);
        cleanupFn(() => viewport.removeEventListener("scroll", handleScroll));
      }
    });
    watch36(currentElement, () => {
      if (currentElement.value) alignedPositionContext?.onScrollButtonChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return canScrollDown.value ? (openBlock293(), createBlock285(SelectScrollButtonImpl_default, {
        key: 0,
        ref: unref296(forwardRef),
        onAutoScroll: _cache[0] || (_cache[0] = () => {
          const { viewport, selectedItem } = unref296(contentContext);
          if (viewport?.value && selectedItem?.value) viewport.value.scrollTop = viewport.value.scrollTop + selectedItem.value.offsetHeight;
        })
      }, {
        default: withCtx289(() => [renderSlot294(_ctx.$slots, "default")]),
        _: 3
      }, 512)) : createCommentVNode31("v-if", true);
    };
  }
});
var SelectScrollDownButton_default = SelectScrollDownButton_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectScrollUpButton.js
import { createBlock as createBlock286, createCommentVNode as createCommentVNode32, defineComponent as defineComponent303, openBlock as openBlock294, ref as ref94, renderSlot as renderSlot295, unref as unref297, watch as watch37, watchEffect as watchEffect22, withCtx as withCtx290 } from "vue";
var SelectScrollUpButton_vue_vue_type_script_setup_true_lang_default = defineComponent303({
  __name: "SelectScrollUpButton",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const contentContext = injectSelectContentContext();
    const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
    const { forwardRef, currentElement } = useForwardExpose();
    const canScrollUp = ref94(false);
    watchEffect22((cleanupFn) => {
      if (contentContext.viewport?.value && contentContext.isPositioned?.value) {
        let handleScroll = function() {
          canScrollUp.value = viewport.scrollTop > 0;
        };
        const viewport = contentContext.viewport.value;
        handleScroll();
        viewport.addEventListener("scroll", handleScroll);
        cleanupFn(() => viewport.removeEventListener("scroll", handleScroll));
      }
    });
    watch37(currentElement, () => {
      if (currentElement.value) alignedPositionContext?.onScrollButtonChange(currentElement.value);
    });
    return (_ctx, _cache) => {
      return canScrollUp.value ? (openBlock294(), createBlock286(SelectScrollButtonImpl_default, {
        key: 0,
        ref: unref297(forwardRef),
        onAutoScroll: _cache[0] || (_cache[0] = () => {
          const { viewport, selectedItem } = unref297(contentContext);
          if (viewport?.value && selectedItem?.value) viewport.value.scrollTop = viewport.value.scrollTop - selectedItem.value.offsetHeight;
        })
      }, {
        default: withCtx290(() => [renderSlot295(_ctx.$slots, "default")]),
        _: 3
      }, 512)) : createCommentVNode32("v-if", true);
    };
  }
});
var SelectScrollUpButton_default = SelectScrollUpButton_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectSeparator.js
import { createBlock as createBlock287, defineComponent as defineComponent304, mergeProps as mergeProps135, openBlock as openBlock295, renderSlot as renderSlot296, unref as unref298, withCtx as withCtx291 } from "vue";
var SelectSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent304({
  __name: "SelectSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock295(), createBlock287(unref298(Primitive), mergeProps135({ "aria-hidden": "true" }, props2), {
        default: withCtx291(() => [renderSlot296(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var SelectSeparator_default = SelectSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectTrigger.js
import { computed as computed100, createBlock as createBlock288, createVNode as createVNode55, defineComponent as defineComponent305, onMounted as onMounted44, openBlock as openBlock296, renderSlot as renderSlot297, unref as unref299, withCtx as withCtx292, withModifiers as withModifiers19 } from "vue";
var SelectTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent305({
  __name: "SelectTrigger",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSelectRootContext();
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const isDisabled = computed100(() => rootContext.disabled?.value || props2.disabled);
    rootContext.contentId ||= useId2(void 0, "reka-select-content");
    onMounted44(() => {
      rootContext.onTriggerChange(triggerElement.value);
    });
    const { getItems } = useCollection();
    const { search, handleTypeaheadSearch, resetTypeahead } = useTypeahead();
    function handleOpen() {
      if (!isDisabled.value) {
        rootContext.onOpenChange(true);
        resetTypeahead();
      }
    }
    function handlePointerOpen(event) {
      handleOpen();
      rootContext.triggerPointerDownPosRef.value = {
        x: Math.round(event.pageX),
        y: Math.round(event.pageY)
      };
    }
    return (_ctx, _cache) => {
      return openBlock296(), createBlock288(unref299(PopperAnchor_default), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx292(() => [createVNode55(unref299(Primitive), {
          ref: unref299(forwardRef),
          role: "combobox",
          type: _ctx.as === "button" ? "button" : void 0,
          "aria-controls": unref299(rootContext).contentId,
          "aria-expanded": unref299(rootContext).open.value || false,
          "aria-required": unref299(rootContext).required?.value,
          "aria-autocomplete": "none",
          disabled: isDisabled.value,
          dir: unref299(rootContext)?.dir.value,
          "data-state": unref299(rootContext)?.open.value ? "open" : "closed",
          "data-disabled": isDisabled.value ? "" : void 0,
          "data-placeholder": unref299(shouldShowPlaceholder)(unref299(rootContext).modelValue?.value) ? "" : void 0,
          "as-child": _ctx.asChild,
          as: _ctx.as,
          onClick: _cache[0] || (_cache[0] = (event) => {
            event?.currentTarget?.focus();
          }),
          onPointerdown: _cache[1] || (_cache[1] = (event) => {
            if (event.pointerType === "touch") return event.preventDefault();
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) target.releasePointerCapture(event.pointerId);
            if (event.button === 0 && event.ctrlKey === false) {
              handlePointerOpen(event);
              event.preventDefault();
            }
          }),
          onPointerup: _cache[2] || (_cache[2] = withModifiers19((event) => {
            if (event.pointerType === "touch") handlePointerOpen(event);
          }, ["prevent"])),
          onKeydown: _cache[3] || (_cache[3] = (event) => {
            const isTypingAhead = unref299(search) !== "";
            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
            if (!isModifierKey && event.key.length === 1) {
              if (isTypingAhead && event.key === " ") return;
            }
            unref299(handleTypeaheadSearch)(event.key, unref299(getItems)());
            if (unref299(OPEN_KEYS).includes(event.key)) {
              handleOpen();
              event.preventDefault();
            }
          })
        }, {
          default: withCtx292(() => [renderSlot297(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "type",
          "aria-controls",
          "aria-expanded",
          "aria-required",
          "disabled",
          "dir",
          "data-state",
          "data-disabled",
          "data-placeholder",
          "as-child",
          "as"
        ])]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});
var SelectTrigger_default = SelectTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectValue.js
import { computed as computed101, createBlock as createBlock289, createTextVNode as createTextVNode26, defineComponent as defineComponent306, onMounted as onMounted45, openBlock as openBlock297, renderSlot as renderSlot298, toDisplayString as toDisplayString12, unref as unref300, withCtx as withCtx293 } from "vue";
var SelectValue_vue_vue_type_script_setup_true_lang_default = defineComponent306({
  __name: "SelectValue",
  props: {
    placeholder: {
      type: String,
      required: false,
      default: ""
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef, currentElement } = useForwardExpose();
    const rootContext = injectSelectRootContext();
    onMounted45(() => {
      rootContext.valueElement = currentElement;
    });
    const selectedLabel = computed101(() => {
      let list = [];
      const options = Array.from(rootContext.optionsSet.value);
      const getOption = (value) => options.find((option) => valueComparator2(value, option.value, rootContext.by));
      if (Array.isArray(rootContext.modelValue.value)) list = rootContext.modelValue.value.map((value) => getOption(value)?.textContent ?? "");
      else list = [getOption(rootContext.modelValue.value)?.textContent ?? ""];
      return list.filter(Boolean);
    });
    const slotText = computed101(() => {
      return selectedLabel.value.length ? selectedLabel.value.join(", ") : props2.placeholder;
    });
    return (_ctx, _cache) => {
      return openBlock297(), createBlock289(unref300(Primitive), {
        ref: unref300(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        style: { pointerEvents: "none" },
        "data-placeholder": selectedLabel.value.length ? void 0 : props2.placeholder
      }, {
        default: withCtx293(() => [renderSlot298(_ctx.$slots, "default", {
          selectedLabel: selectedLabel.value,
          modelValue: unref300(rootContext).modelValue.value
        }, () => [createTextVNode26(toDisplayString12(slotText.value), 1)])]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-placeholder"
      ]);
    };
  }
});
var SelectValue_default = SelectValue_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Select/SelectViewport.js
import { Fragment as Fragment10, createElementBlock as createElementBlock14, createTextVNode as createTextVNode27, createVNode as createVNode56, defineComponent as defineComponent307, mergeProps as mergeProps136, onMounted as onMounted46, openBlock as openBlock298, ref as ref95, renderSlot as renderSlot299, toRefs as toRefs41, unref as unref301, withCtx as withCtx294 } from "vue";
var SelectViewport_vue_vue_type_script_setup_true_lang_default = defineComponent307({
  __name: "SelectViewport",
  props: {
    nonce: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { nonce: propNonce } = toRefs41(props2);
    const nonce = useNonce(propNonce);
    const contentContext = injectSelectContentContext();
    const alignedPositionContext = contentContext.position === "item-aligned" ? injectSelectItemAlignedPositionContext() : void 0;
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted46(() => {
      contentContext?.onViewportChange(currentElement.value);
    });
    const prevScrollTopRef = ref95(0);
    function handleScroll(event) {
      const viewport = event.currentTarget;
      const { shouldExpandOnScrollRef, contentWrapper } = alignedPositionContext ?? {};
      if (shouldExpandOnScrollRef?.value && contentWrapper?.value) {
        const scrolledBy = Math.abs(prevScrollTopRef.value - viewport.scrollTop);
        if (scrolledBy > 0) {
          const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
          const cssMinHeight = Number.parseFloat(contentWrapper.value.style.minHeight);
          const cssHeight = Number.parseFloat(contentWrapper.value.style.height);
          const prevHeight = Math.max(cssMinHeight, cssHeight);
          if (prevHeight < availableHeight) {
            const nextHeight = prevHeight + scrolledBy;
            const clampedNextHeight = Math.min(availableHeight, nextHeight);
            const heightDiff = nextHeight - clampedNextHeight;
            contentWrapper.value.style.height = `${clampedNextHeight}px`;
            if (contentWrapper.value.style.bottom === "0px") {
              viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
              contentWrapper.value.style.justifyContent = "flex-end";
            }
          }
        }
      }
      prevScrollTopRef.value = viewport.scrollTop;
    }
    return (_ctx, _cache) => {
      return openBlock298(), createElementBlock14(Fragment10, null, [createVNode56(unref301(Primitive), mergeProps136({
        ref: unref301(forwardRef),
        "data-reka-select-viewport": "",
        role: "presentation"
      }, {
        ..._ctx.$attrs,
        ...props2
      }, {
        style: {
          position: "relative",
          flex: 1,
          overflow: "hidden auto"
        },
        onScroll: handleScroll
      }), {
        default: withCtx294(() => [renderSlot299(_ctx.$slots, "default")]),
        _: 3
      }, 16), createVNode56(unref301(Primitive), {
        as: "style",
        nonce: unref301(nonce)
      }, {
        default: withCtx294(() => _cache[0] || (_cache[0] = [createTextVNode27(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-select-viewport]::-webkit-scrollbar { display: none; } ")])),
        _: 1,
        __: [0]
      }, 8, ["nonce"])], 64);
    };
  }
});
var SelectViewport_default = SelectViewport_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/component/BaseSeparator.js
import { computed as computed102, createBlock as createBlock290, defineComponent as defineComponent308, mergeProps as mergeProps137, openBlock as openBlock299, renderSlot as renderSlot300, unref as unref302, withCtx as withCtx295 } from "vue";
var BaseSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent308({
  __name: "BaseSeparator",
  props: {
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const ORIENTATIONS = ["horizontal", "vertical"];
    function isValidOrientation(orientation) {
      return ORIENTATIONS.includes(orientation);
    }
    const computedOrientation = computed102(() => isValidOrientation(props2.orientation) ? props2.orientation : "horizontal");
    const ariaOrientation = computed102(() => computedOrientation.value === "vertical" ? props2.orientation : void 0);
    const semanticProps = computed102(() => props2.decorative ? { role: "none" } : {
      "aria-orientation": ariaOrientation.value,
      "role": "separator"
    });
    return (_ctx, _cache) => {
      return openBlock299(), createBlock290(unref302(Primitive), mergeProps137({
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-orientation": computedOrientation.value
      }, semanticProps.value), {
        default: withCtx295(() => [renderSlot300(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "data-orientation"
      ]);
    };
  }
});
var BaseSeparator_default = BaseSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Separator/Separator.js
import { createBlock as createBlock291, defineComponent as defineComponent309, guardReactiveProps as guardReactiveProps101, normalizeProps as normalizeProps101, openBlock as openBlock300, renderSlot as renderSlot301, withCtx as withCtx296 } from "vue";
var Separator_vue_vue_type_script_setup_true_lang_default = defineComponent309({
  __name: "Separator",
  props: {
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    decorative: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock300(), createBlock291(BaseSeparator_default, normalizeProps101(guardReactiveProps101(props2)), {
        default: withCtx296(() => [renderSlot301(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var Separator_default = Separator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/utils.js
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a, b) => a - b);
}
function convertValueToPercentage(value, min2, max2) {
  const maxSteps = max2 - min2;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min2);
  return clamp(percentage, 0, 100);
}
function getLabel(index, totalValues) {
  if (totalValues > 2) return `Value ${index + 1} of ${totalValues}`;
  else if (totalValues === 2) return ["Minimum", "Maximum"][index];
  else return void 0;
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset3 = linearScale2([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset3(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index) => values[index + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale2(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = 10 ** decimalCount;
  return Math.round(value * rounder) / rounder;
}
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
];
var BACK_KEYS = {
  "from-left": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-right": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowRight"
  ],
  "from-bottom": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-top": [
    "Home",
    "PageUp",
    "ArrowUp",
    "ArrowLeft"
  ]
};
var [injectSliderOrientationContext, provideSliderOrientationContext] = createContext(["SliderVertical", "SliderHorizontal"]);

// node_modules/reka-ui/dist/Slider/SliderHorizontal.js
import { computed as computed103, createBlock as createBlock292, defineComponent as defineComponent310, normalizeStyle as normalizeStyle11, openBlock as openBlock301, ref as ref96, renderSlot as renderSlot302, toRefs as toRefs42, unref as unref303, withCtx as withCtx297 } from "vue";
var SliderHorizontal_vue_vue_type_script_setup_true_lang_default = defineComponent310({
  __name: "SliderHorizontal",
  props: {
    dir: {
      type: String,
      required: false
    },
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    inverted: {
      type: Boolean,
      required: true
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { max: max2, min: min2, dir, inverted } = toRefs42(props2);
    const { forwardRef, currentElement: sliderElement } = useForwardExpose();
    const rootContext = injectSliderRootContext();
    const offsetPosition = ref96();
    const rectRef = ref96();
    const isSlidingFromLeft = computed103(() => dir?.value !== "rtl" && !inverted.value || dir?.value !== "ltr" && inverted.value);
    function getValueFromPointerEvent(event, slideStart) {
      const rect = rectRef.value || sliderElement.value.getBoundingClientRect();
      const thumb = [...rootContext.thumbElements.value][rootContext.valueIndexToChangeRef.value];
      const thumbWidth = rootContext.thumbAlignment.value === "contain" ? thumb.clientWidth : 0;
      if (!offsetPosition.value && !slideStart && rootContext.thumbAlignment.value === "contain") offsetPosition.value = event.clientX - thumb.getBoundingClientRect().left;
      const input = [0, rect.width - thumbWidth];
      const output = isSlidingFromLeft.value ? [min2.value, max2.value] : [max2.value, min2.value];
      const value = linearScale2(input, output);
      rectRef.value = rect;
      const position = slideStart ? event.clientX - rect.left - thumbWidth / 2 : event.clientX - rect.left - (offsetPosition.value ?? 0);
      return value(position);
    }
    const startEdge = computed103(() => isSlidingFromLeft.value ? "left" : "right");
    const endEdge = computed103(() => isSlidingFromLeft.value ? "right" : "left");
    const direction = computed103(() => isSlidingFromLeft.value ? 1 : -1);
    provideSliderOrientationContext({
      startEdge,
      endEdge,
      direction,
      size: "width"
    });
    return (_ctx, _cache) => {
      return openBlock301(), createBlock292(SliderImpl_default, {
        ref: unref303(forwardRef),
        dir: unref303(dir),
        "data-orientation": "horizontal",
        style: normalizeStyle11({ ["--reka-slider-thumb-transform"]: !isSlidingFromLeft.value && unref303(rootContext).thumbAlignment.value === "overflow" ? "translateX(50%)" : "translateX(-50%)" }),
        onSlideStart: _cache[0] || (_cache[0] = (event) => {
          const value = getValueFromPointerEvent(event, true);
          emits("slideStart", value);
        }),
        onSlideMove: _cache[1] || (_cache[1] = (event) => {
          const value = getValueFromPointerEvent(event);
          emits("slideMove", value);
        }),
        onSlideEnd: _cache[2] || (_cache[2] = () => {
          rectRef.value = void 0;
          offsetPosition.value = void 0;
          emits("slideEnd");
        }),
        onStepKeyDown: _cache[3] || (_cache[3] = (event) => {
          const slideDirection = isSlidingFromLeft.value ? "from-left" : "from-right";
          const isBackKey = unref303(BACK_KEYS)[slideDirection].includes(event.key);
          emits("stepKeyDown", event, isBackKey ? -1 : 1);
        }),
        onEndKeyDown: _cache[4] || (_cache[4] = ($event) => emits("endKeyDown", $event)),
        onHomeKeyDown: _cache[5] || (_cache[5] = ($event) => emits("homeKeyDown", $event))
      }, {
        default: withCtx297(() => [renderSlot302(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["dir", "style"]);
    };
  }
});
var SliderHorizontal_default = SliderHorizontal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/SliderVertical.js
import { computed as computed104, createBlock as createBlock293, defineComponent as defineComponent311, normalizeStyle as normalizeStyle12, openBlock as openBlock302, ref as ref97, renderSlot as renderSlot303, toRefs as toRefs43, unref as unref304, withCtx as withCtx298 } from "vue";
var SliderVertical_vue_vue_type_script_setup_true_lang_default = defineComponent311({
  __name: "SliderVertical",
  props: {
    min: {
      type: Number,
      required: true
    },
    max: {
      type: Number,
      required: true
    },
    inverted: {
      type: Boolean,
      required: true
    }
  },
  emits: [
    "slideEnd",
    "slideStart",
    "slideMove",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { max: max2, min: min2, inverted } = toRefs43(props2);
    const rootContext = injectSliderRootContext();
    const { forwardRef, currentElement: sliderElement } = useForwardExpose();
    const offsetPosition = ref97();
    const rectRef = ref97();
    const isSlidingFromBottom = computed104(() => !inverted.value);
    function getValueFromPointerEvent(event, slideStart) {
      const rect = rectRef.value || sliderElement.value.getBoundingClientRect();
      const thumb = [...rootContext.thumbElements.value][rootContext.valueIndexToChangeRef.value];
      const thumbHeight = rootContext.thumbAlignment.value === "contain" ? thumb.clientHeight : 0;
      if (!offsetPosition.value && !slideStart && rootContext.thumbAlignment.value === "contain") offsetPosition.value = event.clientY - thumb.getBoundingClientRect().top;
      const input = [0, rect.height - thumbHeight];
      const output = isSlidingFromBottom.value ? [max2.value, min2.value] : [min2.value, max2.value];
      const value = linearScale2(input, output);
      const position = slideStart ? event.clientY - rect.top - thumbHeight / 2 : event.clientY - rect.top - (offsetPosition.value ?? 0);
      rectRef.value = rect;
      return value(position);
    }
    const startEdge = computed104(() => isSlidingFromBottom.value ? "bottom" : "top");
    const endEdge = computed104(() => isSlidingFromBottom.value ? "top" : "bottom");
    const direction = computed104(() => isSlidingFromBottom.value ? 1 : -1);
    provideSliderOrientationContext({
      startEdge,
      endEdge,
      direction,
      size: "height"
    });
    return (_ctx, _cache) => {
      return openBlock302(), createBlock293(SliderImpl_default, {
        ref: unref304(forwardRef),
        "data-orientation": "vertical",
        style: normalizeStyle12({ ["--reka-slider-thumb-transform"]: !isSlidingFromBottom.value && unref304(rootContext).thumbAlignment.value === "overflow" ? "translateY(-50%)" : "translateY(50%)" }),
        onSlideStart: _cache[0] || (_cache[0] = (event) => {
          const value = getValueFromPointerEvent(event, true);
          emits("slideStart", value);
        }),
        onSlideMove: _cache[1] || (_cache[1] = (event) => {
          const value = getValueFromPointerEvent(event);
          emits("slideMove", value);
        }),
        onSlideEnd: _cache[2] || (_cache[2] = () => {
          rectRef.value = void 0;
          offsetPosition.value = void 0;
          emits("slideEnd");
        }),
        onStepKeyDown: _cache[3] || (_cache[3] = (event) => {
          const slideDirection = isSlidingFromBottom.value ? "from-bottom" : "from-top";
          const isBackKey = unref304(BACK_KEYS)[slideDirection].includes(event.key);
          emits("stepKeyDown", event, isBackKey ? -1 : 1);
        }),
        onEndKeyDown: _cache[4] || (_cache[4] = ($event) => emits("endKeyDown", $event)),
        onHomeKeyDown: _cache[5] || (_cache[5] = ($event) => emits("homeKeyDown", $event))
      }, {
        default: withCtx298(() => [renderSlot303(_ctx.$slots, "default")]),
        _: 3
      }, 8, ["style"]);
    };
  }
});
var SliderVertical_default = SliderVertical_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/SliderRoot.js
import { computed as computed105, createBlock as createBlock294, createCommentVNode as createCommentVNode33, defineComponent as defineComponent312, mergeProps as mergeProps138, openBlock as openBlock303, ref as ref98, renderSlot as renderSlot304, resolveDynamicComponent as resolveDynamicComponent7, toRaw as toRaw2, toRefs as toRefs44, unref as unref305, withCtx as withCtx299 } from "vue";
var [injectSliderRootContext, provideSliderRootContext] = createContext("SliderRoot");
var SliderRoot_vue_vue_type_script_setup_true_lang_default = defineComponent312({
  inheritAttrs: false,
  __name: "SliderRoot",
  props: {
    defaultValue: {
      type: Array,
      required: false,
      default: () => [0]
    },
    modelValue: {
      type: [Array, null],
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: false
    },
    inverted: {
      type: Boolean,
      required: false,
      default: false
    },
    min: {
      type: Number,
      required: false,
      default: 0
    },
    max: {
      type: Number,
      required: false,
      default: 100
    },
    step: {
      type: Number,
      required: false,
      default: 1
    },
    minStepsBetweenThumbs: {
      type: Number,
      required: false,
      default: 0
    },
    thumbAlignment: {
      type: String,
      required: false,
      default: "contain"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { min: min2, max: max2, step, minStepsBetweenThumbs, orientation, disabled, thumbAlignment, dir: propDir } = toRefs44(props2);
    const dir = useDirection(propDir);
    const { forwardRef, currentElement } = useForwardExpose();
    const isFormControl = useFormControl(currentElement);
    const { CollectionSlot } = useCollection({ isProvider: true });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const currentModelValue = computed105(() => Array.isArray(modelValue.value) ? [...modelValue.value] : []);
    const valueIndexToChangeRef = ref98(0);
    const valuesBeforeSlideStartRef = ref98(currentModelValue.value);
    function handleSlideStart(value) {
      const closestIndex = getClosestValueIndex(currentModelValue.value, value);
      updateValues(value, closestIndex);
    }
    function handleSlideMove(value) {
      updateValues(value, valueIndexToChangeRef.value);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.value[valueIndexToChangeRef.value];
      const nextValue = currentModelValue.value[valueIndexToChangeRef.value];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) emits("valueCommit", toRaw2(currentModelValue.value));
    }
    function updateValues(value, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step.value);
      const snapToStep = roundValue(Math.round((value - min2.value) / step.value) * step.value + min2.value, decimalCount);
      const nextValue = clamp(snapToStep, min2.value, max2.value);
      const nextValues = getNextSortedValues(currentModelValue.value, nextValue, atIndex);
      if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs.value * step.value)) {
        valueIndexToChangeRef.value = nextValues.indexOf(nextValue);
        const hasChanged = String(nextValues) !== String(modelValue.value);
        if (hasChanged && commit) emits("valueCommit", nextValues);
        if (hasChanged) {
          thumbElements.value[valueIndexToChangeRef.value]?.focus();
          modelValue.value = nextValues;
        }
      }
    }
    const thumbElements = ref98([]);
    provideSliderRootContext({
      modelValue,
      currentModelValue,
      valueIndexToChangeRef,
      thumbElements,
      orientation,
      min: min2,
      max: max2,
      disabled,
      thumbAlignment
    });
    return (_ctx, _cache) => {
      return openBlock303(), createBlock294(unref305(CollectionSlot), null, {
        default: withCtx299(() => [(openBlock303(), createBlock294(resolveDynamicComponent7(unref305(orientation) === "horizontal" ? SliderHorizontal_default : SliderVertical_default), mergeProps138(_ctx.$attrs, {
          ref: unref305(forwardRef),
          "as-child": _ctx.asChild,
          as: _ctx.as,
          min: unref305(min2),
          max: unref305(max2),
          dir: unref305(dir),
          inverted: _ctx.inverted,
          "aria-disabled": unref305(disabled),
          "data-disabled": unref305(disabled) ? "" : void 0,
          onPointerdown: _cache[0] || (_cache[0] = () => {
            if (!unref305(disabled)) valuesBeforeSlideStartRef.value = currentModelValue.value;
          }),
          onSlideStart: _cache[1] || (_cache[1] = ($event) => !unref305(disabled) && handleSlideStart($event)),
          onSlideMove: _cache[2] || (_cache[2] = ($event) => !unref305(disabled) && handleSlideMove($event)),
          onSlideEnd: _cache[3] || (_cache[3] = ($event) => !unref305(disabled) && handleSlideEnd()),
          onHomeKeyDown: _cache[4] || (_cache[4] = ($event) => !unref305(disabled) && updateValues(unref305(min2), 0, { commit: true })),
          onEndKeyDown: _cache[5] || (_cache[5] = ($event) => !unref305(disabled) && updateValues(unref305(max2), currentModelValue.value.length - 1, { commit: true })),
          onStepKeyDown: _cache[6] || (_cache[6] = (event, direction) => {
            if (!unref305(disabled)) {
              const isPageKey = unref305(PAGE_KEYS).includes(event.key);
              const isSkipKey = isPageKey || event.shiftKey && unref305(ARROW_KEYS).includes(event.key);
              const multiplier = isSkipKey ? 10 : 1;
              const atIndex = valueIndexToChangeRef.value;
              const value = currentModelValue.value[atIndex];
              const stepInDirection = unref305(step) * multiplier * direction;
              updateValues(value + stepInDirection, atIndex, { commit: true });
            }
          })
        }), {
          default: withCtx299(() => [renderSlot304(_ctx.$slots, "default", { modelValue: unref305(modelValue) }), unref305(isFormControl) && _ctx.name ? (openBlock303(), createBlock294(unref305(VisuallyHiddenInput_default), {
            key: 0,
            type: "number",
            value: unref305(modelValue),
            name: _ctx.name,
            required: _ctx.required,
            disabled: unref305(disabled),
            step: unref305(step)
          }, null, 8, [
            "value",
            "name",
            "required",
            "disabled",
            "step"
          ])) : createCommentVNode33("v-if", true)]),
          _: 3
        }, 16, [
          "as-child",
          "as",
          "min",
          "max",
          "dir",
          "inverted",
          "aria-disabled",
          "data-disabled"
        ]))]),
        _: 3
      });
    };
  }
});
var SliderRoot_default = SliderRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/SliderImpl.js
import { createBlock as createBlock295, defineComponent as defineComponent313, mergeProps as mergeProps139, openBlock as openBlock304, renderSlot as renderSlot305, unref as unref306, withCtx as withCtx300 } from "vue";
var SliderImpl_vue_vue_type_script_setup_true_lang_default = defineComponent313({
  __name: "SliderImpl",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  emits: [
    "slideStart",
    "slideMove",
    "slideEnd",
    "homeKeyDown",
    "endKeyDown",
    "stepKeyDown"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectSliderRootContext();
    return (_ctx, _cache) => {
      return openBlock304(), createBlock295(unref306(Primitive), mergeProps139({ "data-slider-impl": "" }, props2, {
        onKeydown: _cache[0] || (_cache[0] = (event) => {
          if (event.key === "Home") {
            emits("homeKeyDown", event);
            event.preventDefault();
          } else if (event.key === "End") {
            emits("endKeyDown", event);
            event.preventDefault();
          } else if (unref306(PAGE_KEYS).concat(unref306(ARROW_KEYS)).includes(event.key)) {
            emits("stepKeyDown", event);
            event.preventDefault();
          }
        }),
        onPointerdown: _cache[1] || (_cache[1] = (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (unref306(rootContext).thumbElements.value.includes(target)) target.focus();
          else emits("slideStart", event);
        }),
        onPointermove: _cache[2] || (_cache[2] = (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) emits("slideMove", event);
        }),
        onPointerup: _cache[3] || (_cache[3] = (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            emits("slideEnd", event);
          }
        })
      }), {
        default: withCtx300(() => [renderSlot305(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var SliderImpl_default = SliderImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/SliderRange.js
import { computed as computed106, createBlock as createBlock296, defineComponent as defineComponent314, normalizeStyle as normalizeStyle13, openBlock as openBlock305, renderSlot as renderSlot306, unref as unref307, withCtx as withCtx301 } from "vue";
var SliderRange_vue_vue_type_script_setup_true_lang_default = defineComponent314({
  __name: "SliderRange",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const rootContext = injectSliderRootContext();
    const orientation = injectSliderOrientationContext();
    useForwardExpose();
    const percentages = computed106(() => rootContext.currentModelValue.value.map((value) => convertValueToPercentage(value, rootContext.min.value, rootContext.max.value)));
    const offsetStart = computed106(() => rootContext.currentModelValue.value.length > 1 ? Math.min(...percentages.value) : 0);
    const offsetEnd = computed106(() => 100 - Math.max(...percentages.value, 0));
    return (_ctx, _cache) => {
      return openBlock305(), createBlock296(unref307(Primitive), {
        "data-disabled": unref307(rootContext).disabled.value ? "" : void 0,
        "data-orientation": unref307(rootContext).orientation.value,
        "as-child": _ctx.asChild,
        as: _ctx.as,
        style: normalizeStyle13({
          [unref307(orientation).startEdge.value]: `${offsetStart.value}%`,
          [unref307(orientation).endEdge.value]: `${offsetEnd.value}%`
        })
      }, {
        default: withCtx301(() => [renderSlot306(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "data-disabled",
        "data-orientation",
        "as-child",
        "as",
        "style"
      ]);
    };
  }
});
var SliderRange_default = SliderRange_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/SliderThumbImpl.js
import { computed as computed107, createBlock as createBlock297, createVNode as createVNode57, defineComponent as defineComponent315, mergeProps as mergeProps140, onMounted as onMounted47, onUnmounted as onUnmounted21, openBlock as openBlock306, renderSlot as renderSlot307, unref as unref308, withCtx as withCtx302 } from "vue";
var SliderThumbImpl_vue_vue_type_script_setup_true_lang_default = defineComponent315({
  inheritAttrs: false,
  __name: "SliderThumbImpl",
  props: {
    index: {
      type: Number,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectSliderRootContext();
    const orientation = injectSliderOrientationContext();
    const { forwardRef, currentElement: thumbElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const value = computed107(() => rootContext.modelValue?.value?.[props2.index]);
    const percent = computed107(() => value.value === void 0 ? 0 : convertValueToPercentage(value.value, rootContext.min.value ?? 0, rootContext.max.value ?? 100));
    const label = computed107(() => getLabel(props2.index, rootContext.modelValue?.value?.length ?? 0));
    const size3 = useSize(thumbElement);
    const orientationSize = computed107(() => size3[orientation.size].value);
    const thumbInBoundsOffset = computed107(() => {
      if (rootContext.thumbAlignment.value === "overflow" || !orientationSize.value) return 0;
      else return getThumbInBoundsOffset(orientationSize.value, percent.value, orientation.direction.value);
    });
    const isMounted = useMounted();
    onMounted47(() => {
      rootContext.thumbElements.value.push(thumbElement.value);
    });
    onUnmounted21(() => {
      const i = rootContext.thumbElements.value.findIndex((i$1) => i$1 === thumbElement.value) ?? -1;
      rootContext.thumbElements.value.splice(i, 1);
    });
    return (_ctx, _cache) => {
      return openBlock306(), createBlock297(unref308(CollectionItem), null, {
        default: withCtx302(() => [createVNode57(unref308(Primitive), mergeProps140(_ctx.$attrs, {
          ref: unref308(forwardRef),
          role: "slider",
          tabindex: unref308(rootContext).disabled.value ? void 0 : 0,
          "aria-label": _ctx.$attrs["aria-label"] || label.value,
          "data-disabled": unref308(rootContext).disabled.value ? "" : void 0,
          "data-orientation": unref308(rootContext).orientation.value,
          "aria-valuenow": value.value,
          "aria-valuemin": unref308(rootContext).min.value,
          "aria-valuemax": unref308(rootContext).max.value,
          "aria-orientation": unref308(rootContext).orientation.value,
          "as-child": _ctx.asChild,
          as: _ctx.as,
          style: {
            transform: "var(--reka-slider-thumb-transform)",
            position: "absolute",
            [unref308(orientation).startEdge.value]: `calc(${percent.value}% + ${thumbInBoundsOffset.value}px)`,
            display: !unref308(isMounted) && value.value === void 0 ? "none" : void 0
          },
          onFocus: _cache[0] || (_cache[0] = () => {
            unref308(rootContext).valueIndexToChangeRef.value = _ctx.index;
          })
        }), {
          default: withCtx302(() => [renderSlot307(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "tabindex",
          "aria-label",
          "data-disabled",
          "data-orientation",
          "aria-valuenow",
          "aria-valuemin",
          "aria-valuemax",
          "aria-orientation",
          "as-child",
          "as",
          "style"
        ])]),
        _: 3
      });
    };
  }
});
var SliderThumbImpl_default = SliderThumbImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/SliderThumb.js
import { computed as computed108, createBlock as createBlock298, defineComponent as defineComponent316, mergeProps as mergeProps141, openBlock as openBlock307, renderSlot as renderSlot308, unref as unref309, withCtx as withCtx303 } from "vue";
var SliderThumb_vue_vue_type_script_setup_true_lang_default = defineComponent316({
  __name: "SliderThumb",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { getItems } = useCollection();
    const { forwardRef, currentElement: thumbElement } = useForwardExpose();
    const index = computed108(() => thumbElement.value ? getItems(true).findIndex((i) => i.ref === thumbElement.value) : -1);
    return (_ctx, _cache) => {
      return openBlock307(), createBlock298(SliderThumbImpl_default, mergeProps141({ ref: unref309(forwardRef) }, props2, { index: index.value }), {
        default: withCtx303(() => [renderSlot308(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["index"]);
    };
  }
});
var SliderThumb_default = SliderThumb_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Slider/SliderTrack.js
import { createBlock as createBlock299, defineComponent as defineComponent317, openBlock as openBlock308, renderSlot as renderSlot309, unref as unref310, withCtx as withCtx304 } from "vue";
var SliderTrack_vue_vue_type_script_setup_true_lang_default = defineComponent317({
  __name: "SliderTrack",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const rootContext = injectSliderRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock308(), createBlock299(unref310(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "data-disabled": unref310(rootContext).disabled.value ? "" : void 0,
        "data-orientation": unref310(rootContext).orientation.value
      }, {
        default: withCtx304(() => [renderSlot309(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "data-disabled",
        "data-orientation"
      ]);
    };
  }
});
var SliderTrack_default = SliderTrack_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/utils/assert.js
function assert(expectedCondition, message = "Assertion failed!") {
  if (!expectedCondition) {
    console.error(message);
    throw new Error(message);
  }
}

// node_modules/reka-ui/dist/utils/dom.js
function getPanelGroupElement(id, rootElement = document) {
  if (!isBrowser) return null;
  if (rootElement instanceof HTMLElement && rootElement?.dataset?.panelGroupId === id) return rootElement;
  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id}"]`);
  if (element) return element;
  return null;
}
function getResizeHandleElement(id, scope = document) {
  if (!isBrowser) return null;
  const element = scope.querySelector(`[data-panel-resize-handle-id="${id}"]`);
  if (element) return element;
  return null;
}
function getResizeHandleElementIndex(groupId, id, scope = document) {
  if (!isBrowser) return null;
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handles.findIndex((handle) => handle.getAttribute("data-panel-resize-handle-id") === id);
  return index ?? null;
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  if (!isBrowser) return [];
  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`));
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  const handle = getResizeHandleElement(handleId, scope);
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handle ? handles.indexOf(handle) : -1;
  const idBefore = panelsArray[index]?.id ?? null;
  const idAfter = panelsArray[index + 1]?.id ?? null;
  return [idBefore, idAfter];
}

// node_modules/reka-ui/dist/utils/events.js
function isKeyDown(event) {
  return event.type === "keydown";
}
function isMouseEvent2(event) {
  return event.type.startsWith("mouse");
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
function getResizeEventCoordinates(event) {
  if (isMouseEvent2(event)) return {
    x: event.clientX,
    y: event.clientY
  };
  else if (isTouchEvent(event)) {
    const touch = event.touches[0];
    if (touch && touch.clientX && touch.clientY) return {
      x: touch.clientX,
      y: touch.clientY
    };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal";
  const { x, y } = getResizeEventCoordinates(event);
  return isHorizontal ? x : y;
}

// node_modules/reka-ui/dist/utils/calculate.js
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement);
  const groupId = handleElement.getAttribute("data-panel-group-id");
  assert(groupId);
  const { initialCursorPosition } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event);
  const groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    if (event.shiftKey) delta = 100;
    else delta = keyboardResizeBy ?? 10;
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null) return 0;
    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
  }
}
function calculateAriaValues({ layout, panelsArray, pivotIndices }) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  assert(firstIndex != null);
  panelsArray.forEach((panelData, index) => {
    const { constraints } = panelData;
    const { maxSize = 100, minSize = 0 } = constraints;
    if (index === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function calculateUnsafeDefaultLayout({ panelDataArray }) {
  const layout = Array.from({ length: panelDataArray.length });
  const panelConstraintsArray = panelDataArray.map((panelData) => panelData.constraints);
  let numPanelsWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints);
    const { defaultSize } = panelConstraints;
    if (defaultSize != null) {
      numPanelsWithSizes++;
      layout[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints);
    const { defaultSize } = panelConstraints;
    if (defaultSize != null) continue;
    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;
    const size3 = remainingSize / numRemainingPanels;
    numPanelsWithSizes++;
    layout[index] = size3;
    remainingSize -= size3;
  }
  return layout;
}

// node_modules/reka-ui/dist/utils/callPanelCallbacks.js
function callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {
  layout.forEach((size3, index) => {
    const panelData = panelsArray[index];
    assert(panelData);
    const { callbacks, constraints, id: panelId } = panelData;
    const { collapsedSize = 0, collapsible } = constraints;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size3 !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size3;
      const { onCollapse, onExpand, onResize } = callbacks;
      if (onResize) onResize(size3, lastNotifiedSize);
      if (collapsible && (onCollapse || onExpand)) {
        if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size3 !== collapsedSize) onExpand();
        if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size3 === collapsedSize) onCollapse();
      }
    }
  });
}

// node_modules/reka-ui/dist/utils/debounce.js
function debounce2(callback, durationMs = 10) {
  let timeoutId = null;
  const callable = (...args) => {
    if (timeoutId !== null) clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}

// node_modules/reka-ui/dist/utils/constants.js
var PRECISION = 10;

// node_modules/reka-ui/dist/utils/compare.js
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  actual = Number.parseFloat(actual.toFixed(fractionDigits));
  expected = Number.parseFloat(expected.toFixed(fractionDigits));
  const delta = actual - expected;
  if (delta === 0) return 0;
  else return delta > 0 ? 1 : -1;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}

// node_modules/reka-ui/dist/utils/resizePanel.js
function resizePanel({ panelConstraints: panelConstraintsArray, panelIndex, size: size3 }) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null);
  const { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panelConstraints;
  if (fuzzyCompareNumbers(size3, minSize) < 0) if (collapsible) {
    const halfwayPoint = (collapsedSize + minSize) / 2;
    if (fuzzyCompareNumbers(size3, halfwayPoint) < 0) size3 = collapsedSize;
    else size3 = minSize;
  } else size3 = minSize;
  size3 = Math.min(maxSize, size3);
  size3 = Number.parseFloat(size3.toFixed(PRECISION));
  return size3;
}

// node_modules/reka-ui/dist/utils/layout.js
function compareLayouts(a, b) {
  if (a.length !== b.length) return false;
  else for (let index = 0; index < a.length; index++) if (a[index] !== b[index]) return false;
  return true;
}
function adjustLayoutByDelta({ delta, layout: prevLayout, panelConstraints: panelConstraintsArray, pivotIndices, trigger }) {
  if (fuzzyNumbersEqual(delta, 0)) return prevLayout;
  const nextLayout = [...prevLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null);
  assert(secondPivotIndex != null);
  let deltaApplied = 0;
  if (trigger === "keyboard") {
    {
      const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
      const panelConstraints = panelConstraintsArray[index];
      assert(panelConstraints);
      if (panelConstraints.collapsible) {
        const prevSize = prevLayout[index];
        assert(prevSize != null);
        const panelConstraints$1 = panelConstraintsArray[index];
        assert(panelConstraints$1);
        const { collapsedSize = 0, minSize = 0 } = panelConstraints$1;
        if (fuzzyNumbersEqual(prevSize, collapsedSize)) {
          const localDelta = minSize - prevSize;
          if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) delta = delta < 0 ? 0 - localDelta : localDelta;
        }
      }
    }
    {
      const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
      const panelConstraints = panelConstraintsArray[index];
      assert(panelConstraints);
      const { collapsible } = panelConstraints;
      if (collapsible) {
        const prevSize = prevLayout[index];
        assert(prevSize != null);
        const panelConstraints$1 = panelConstraintsArray[index];
        assert(panelConstraints$1);
        const { collapsedSize = 0, minSize = 0 } = panelConstraints$1;
        if (fuzzyNumbersEqual(prevSize, minSize)) {
          const localDelta = prevSize - collapsedSize;
          if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) delta = delta < 0 ? 0 - localDelta : localDelta;
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const maxSafeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: 100
      });
      const delta$1 = maxSafeSize - prevSize;
      maxAvailableDelta += delta$1;
      index += increment;
      if (index < 0 || index >= panelConstraintsArray.length) break;
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < panelConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = prevLayout[index];
      assert(prevSize != null);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, { numeric: true }) >= 0) break;
      }
      if (delta < 0) index--;
      else index++;
    }
  }
  if (fuzzyNumbersEqual(deltaApplied, 0)) return prevLayout;
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = prevLayout[pivotIndex];
    assert(prevSize != null);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex$1 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex$1;
      while (index >= 0 && index < panelConstraintsArray.length) {
        const prevSize$1 = nextLayout[index];
        assert(prevSize$1 != null);
        const unsafeSize$1 = prevSize$1 + deltaRemaining;
        const safeSize$1 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index,
          size: unsafeSize$1
        });
        if (!fuzzyNumbersEqual(prevSize$1, safeSize$1)) {
          deltaRemaining -= safeSize$1 - prevSize$1;
          nextLayout[index] = safeSize$1;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0)) break;
        if (delta > 0) index--;
        else index++;
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size3) => size3 + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100)) return prevLayout;
  return nextLayout;
}

// node_modules/reka-ui/dist/utils/pivot.js
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
  return index != null ? [index, index + 1] : [-1, -1];
}

// node_modules/reka-ui/dist/utils/rects.js
function intersects(rectOne, rectTwo, strict) {
  if (strict) return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
  else return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;
}

// node_modules/reka-ui/dist/utils/stackingOrder.js
function compare3(a, b) {
  if (a === b) throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: getAncestors(a),
    b: getAncestors(b)
  };
  let common_ancestor;
  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {
    a = ancestors.a.pop();
    b = ancestors.b.pop();
    common_ancestor = a;
  }
  assert(common_ancestor);
  const z_indexes = {
    a: getZIndex(findStackingContext(ancestors.a)),
    b: getZIndex(findStackingContext(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes;
    const furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i = children.length;
    while (i--) {
      const child = children[i];
      if (child === furthest_ancestors.a) return 1;
      if (child === furthest_ancestors.b) return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
var props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function isFlexItem(node) {
  const display = getComputedStyle(getParent(node)).display;
  return display === "flex" || display === "inline-flex";
}
function createsStackingContext(node) {
  const style = getComputedStyle(node);
  if (style.position === "fixed") return true;
  if (style.zIndex !== "auto" && (style.position !== "static" || isFlexItem(node))) return true;
  if (+style.opacity < 1) return true;
  if ("transform" in style && style.transform !== "none") return true;
  if ("webkitTransform" in style && style.webkitTransform !== "none") return true;
  if ("mixBlendMode" in style && style.mixBlendMode !== "normal") return true;
  if ("filter" in style && style.filter !== "none") return true;
  if ("webkitFilter" in style && style.webkitFilter !== "none") return true;
  if ("isolation" in style && style.isolation === "isolate") return true;
  if (props.test(style.willChange)) return true;
  if (style.webkitOverflowScrolling === "touch") return true;
  return false;
}
function findStackingContext(nodes) {
  let i = nodes.length;
  while (i--) {
    const node = nodes[i];
    assert(node);
    if (createsStackingContext(node)) return node;
  }
  return null;
}
function getZIndex(node) {
  return node && Number(getComputedStyle(node).zIndex) || 0;
}
function getAncestors(node) {
  const ancestors = [];
  while (node) {
    ancestors.push(node);
    node = getParent(node);
  }
  return ancestors;
}
function getParent(node) {
  return node.parentNode instanceof DocumentFragment && node.parentNode?.host || node.parentNode;
}

// node_modules/reka-ui/dist/utils/registry.js
var EXCEEDED_HORIZONTAL_MIN = 1;
var EXCEEDED_HORIZONTAL_MAX = 2;
var EXCEEDED_VERTICAL_MIN = 4;
var EXCEEDED_VERTICAL_MAX = 8;
function getInputType() {
  if (typeof matchMedia === "function") return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
var isCoarsePointer = getInputType() === "coarse";
var intersectingHandles = [];
var isPointerDown = false;
var ownerDocumentCounts = /* @__PURE__ */ new Map();
var panelConstraintFlags = /* @__PURE__ */ new Map();
var registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, nonce, setResizeHandlerState) {
  const { ownerDocument } = element;
  const data = {
    direction,
    element,
    hitAreaMargins,
    nonce,
    setResizeHandlerState
  };
  const count3 = ownerDocumentCounts.get(ownerDocument) ?? 0;
  ownerDocumentCounts.set(ownerDocument, count3 + 1);
  registeredResizeHandlers.add(data);
  updateListeners();
  return function unregisterResizeHandle() {
    panelConstraintFlags.delete(resizeHandleId);
    registeredResizeHandlers.delete(data);
    const count$1 = ownerDocumentCounts.get(ownerDocument) ?? 1;
    ownerDocumentCounts.set(ownerDocument, count$1 - 1);
    updateListeners();
    resetGlobalCursorStyle();
    if (count$1 === 1) ownerDocumentCounts.delete(ownerDocument);
  };
}
function handlePointerDown(event) {
  const { target } = event;
  const { x, y } = getResizeEventCoordinates(event);
  isPointerDown = true;
  recalculateIntersectingHandles({
    target,
    x,
    y
  });
  updateListeners();
  if (intersectingHandles.length > 0) {
    updateResizeHandlerStates("down", event);
    event.preventDefault();
  }
}
function handlePointerMove(event) {
  const { x, y } = getResizeEventCoordinates(event);
  if (!isPointerDown) {
    const { target } = event;
    recalculateIntersectingHandles({
      target,
      x,
      y
    });
  }
  updateResizeHandlerStates("move", event);
  updateCursor();
  if (intersectingHandles.length > 0) event.preventDefault();
}
function handlePointerUp(event) {
  const { target } = event;
  const { x, y } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear();
  isPointerDown = false;
  if (intersectingHandles.length > 0) event.preventDefault();
  updateResizeHandlerStates("up", event);
  recalculateIntersectingHandles({
    target,
    x,
    y
  });
  updateCursor();
  updateListeners();
}
function recalculateIntersectingHandles({ target, x, y }) {
  intersectingHandles.splice(0);
  let targetElement = null;
  if (target instanceof HTMLElement) targetElement = target;
  registeredResizeHandlers.forEach((data) => {
    const { element: dragHandleElement, hitAreaMargins } = data;
    const dragHandleRect = dragHandleElement.getBoundingClientRect();
    const { bottom, left, right, top } = dragHandleRect;
    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;
    if (eventIntersects) {
      if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && compare3(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement;
        let didIntersect = false;
        while (currentElement) {
          if (currentElement.contains(dragHandleElement)) break;
          else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {
            didIntersect = true;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect) return;
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = false;
  let intersectsVertical = false;
  let nonce;
  intersectingHandles.forEach((data) => {
    const { direction, nonce: _nonce } = data;
    if (direction.value === "horizontal") intersectsHorizontal = true;
    else intersectsVertical = true;
    nonce = _nonce.value;
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  });
  if (intersectsHorizontal && intersectsVertical) setGlobalCursorStyle("intersection", constraintFlags, nonce);
  else if (intersectsHorizontal) setGlobalCursorStyle("horizontal", constraintFlags, nonce);
  else if (intersectsVertical) setGlobalCursorStyle("vertical", constraintFlags, nonce);
  else resetGlobalCursorStyle();
}
function updateListeners() {
  ownerDocumentCounts.forEach((_, ownerDocument) => {
    const { body } = ownerDocument;
    body.removeEventListener("contextmenu", handlePointerUp);
    body.removeEventListener("mousedown", handlePointerDown);
    body.removeEventListener("mouseleave", handlePointerMove);
    body.removeEventListener("mousemove", handlePointerMove);
    body.removeEventListener("touchmove", handlePointerMove);
    body.removeEventListener("touchstart", handlePointerDown);
  });
  window.removeEventListener("mouseup", handlePointerUp);
  window.removeEventListener("touchcancel", handlePointerUp);
  window.removeEventListener("touchend", handlePointerUp);
  if (registeredResizeHandlers.size > 0) if (isPointerDown) {
    if (intersectingHandles.length > 0) ownerDocumentCounts.forEach((count3, ownerDocument) => {
      const { body } = ownerDocument;
      if (count3 > 0) {
        body.addEventListener("contextmenu", handlePointerUp);
        body.addEventListener("mouseleave", handlePointerMove);
        body.addEventListener("mousemove", handlePointerMove);
        body.addEventListener("touchmove", handlePointerMove, { passive: false });
      }
    });
    window.addEventListener("mouseup", handlePointerUp);
    window.addEventListener("touchcancel", handlePointerUp);
    window.addEventListener("touchend", handlePointerUp);
  } else ownerDocumentCounts.forEach((count3, ownerDocument) => {
    const { body } = ownerDocument;
    if (count3 > 0) {
      body.addEventListener("mousedown", handlePointerDown);
      body.addEventListener("mousemove", handlePointerMove);
      body.addEventListener("touchmove", handlePointerMove, { passive: false });
      body.addEventListener("touchstart", handlePointerDown);
    }
  });
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const { setResizeHandlerState } = data;
    const isActive = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive, event);
  });
}

// node_modules/reka-ui/dist/utils/style.js
var currentCursorStyle = null;
var styleElement = null;
function getCursorStyle(state, constraintFlags) {
  if (constraintFlags) {
    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;
    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;
    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;
    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
    if (horizontalMin) if (verticalMin) return "se-resize";
    else if (verticalMax) return "ne-resize";
    else return "e-resize";
    else if (horizontalMax) if (verticalMin) return "sw-resize";
    else if (verticalMax) return "nw-resize";
    else return "w-resize";
    else if (verticalMin) return "s-resize";
    else if (verticalMax) return "n-resize";
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  if (styleElement !== null) {
    document.head.removeChild(styleElement);
    currentCursorStyle = null;
    styleElement = null;
  }
}
function setGlobalCursorStyle(state, constraintFlags, nonce) {
  const style = getCursorStyle(state, constraintFlags);
  if (currentCursorStyle === style) return;
  currentCursorStyle = style;
  if (styleElement === null) {
    styleElement = document.createElement("style");
    if (nonce) styleElement.nonce = nonce;
    document.head.appendChild(styleElement);
  }
  styleElement.innerHTML = `*{cursor: ${style}!important;}`;
}
function computePanelFlexBoxStyle({ defaultSize, dragState, layout, panelData, panelIndex, precision = 3 }) {
  const size3 = layout[panelIndex];
  let flexGrow;
  if (size3 == null) flexGrow = defaultSize !== void 0 ? defaultSize.toPrecision(precision) : "1";
  else if (panelData.length === 1) flexGrow = "1";
  else flexGrow = size3.toPrecision(precision);
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    overflow: "hidden",
    pointerEvents: dragState !== null ? "none" : void 0
  };
}

// node_modules/reka-ui/dist/utils/validation.js
function validatePanelGroupLayout({ layout: prevLayout, panelConstraints }) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== panelConstraints.length) throw new Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size3) => `${size3}%`).join(", ")}`);
  else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {
    console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size3) => `${size3}%`).join(", ")}. Layout normalization will be applied.`);
    for (let index = 0; index < panelConstraints.length; index++) {
      const unsafeSize = nextLayout[index];
      assert(unsafeSize != null);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < panelConstraints.length; index++) {
    const unsafeSize = nextLayout[index];
    assert(unsafeSize != null);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index,
      size: unsafeSize
    });
    if (unsafeSize !== safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) for (let index = 0; index < panelConstraints.length; index++) {
    const prevSize = nextLayout[index];
    assert(prevSize != null);
    const unsafeSize = prevSize + remainingSize;
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index,
      size: unsafeSize
    });
    if (prevSize !== safeSize) {
      remainingSize -= safeSize - prevSize;
      nextLayout[index] = safeSize;
      if (fuzzyNumbersEqual(remainingSize, 0)) break;
    }
  }
  return nextLayout;
}

// node_modules/reka-ui/dist/composables/useWindowSplitterPanelGroupBehavior.js
import { watchEffect as watchEffect23 } from "vue";
function useWindowSplitterPanelGroupBehavior({ eagerValuesRef, groupId, layout, panelDataArray, panelGroupElement, setLayout }) {
  watchEffect23((onCleanup) => {
    const _panelGroupElement = panelGroupElement.value;
    if (!_panelGroupElement) return;
    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, _panelGroupElement);
    for (let index = 0; index < panelDataArray.length - 1; index++) {
      const { valueMax, valueMin, valueNow } = calculateAriaValues({
        layout: layout.value,
        panelsArray: panelDataArray,
        pivotIndices: [index, index + 1]
      });
      const resizeHandleElement = resizeHandleElements[index];
      if (resizeHandleElement == null) {
      } else {
        const panelData = panelDataArray[index];
        assert(panelData);
        resizeHandleElement.setAttribute("aria-controls", panelData.id);
        resizeHandleElement.setAttribute("aria-valuemax", `${Math.round(valueMax)}`);
        resizeHandleElement.setAttribute("aria-valuemin", `${Math.round(valueMin)}`);
        resizeHandleElement.setAttribute("aria-valuenow", valueNow != null ? `${Math.round(valueNow)}` : "");
      }
    }
    onCleanup(() => {
      resizeHandleElements.forEach((resizeHandleElement) => {
        resizeHandleElement.removeAttribute("aria-controls");
        resizeHandleElement.removeAttribute("aria-valuemax");
        resizeHandleElement.removeAttribute("aria-valuemin");
        resizeHandleElement.removeAttribute("aria-valuenow");
      });
    });
  });
  watchEffect23((onCleanup) => {
    const _panelGroupElement = panelGroupElement.value;
    if (!_panelGroupElement) return;
    const eagerValues = eagerValuesRef.value;
    assert(eagerValues);
    const { panelDataArray: panelDataArray$1 } = eagerValues;
    const groupElement = getPanelGroupElement(groupId, _panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, _panelGroupElement);
    assert(handles);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute("data-panel-resize-handle-id");
      assert(handleId);
      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray$1, _panelGroupElement);
      if (idBefore == null || idAfter == null) return () => {
      };
      const onKeyDown = (event) => {
        if (event.defaultPrevented) return;
        switch (event.key) {
          case "Enter": {
            event.preventDefault();
            const index = panelDataArray$1.findIndex((panelData) => panelData.id === idBefore);
            if (index >= 0) {
              const panelData = panelDataArray$1[index];
              assert(panelData);
              const size3 = layout.value[index];
              const { collapsedSize = 0, collapsible, minSize = 0 } = panelData.constraints;
              if (size3 != null && collapsible) {
                const nextLayout = adjustLayoutByDelta({
                  delta: fuzzyNumbersEqual(size3, collapsedSize) ? minSize - collapsedSize : collapsedSize - size3,
                  layout: layout.value,
                  panelConstraints: panelDataArray$1.map((panelData$1) => panelData$1.constraints),
                  pivotIndices: determinePivotIndices(groupId, handleId, _panelGroupElement),
                  trigger: "keyboard"
                });
                if (layout.value !== nextLayout) setLayout(nextLayout);
              }
            }
            break;
          }
        }
      };
      handle.addEventListener("keydown", onKeyDown);
      return () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    onCleanup(() => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    });
  });
}

// node_modules/reka-ui/dist/utils/storage.js
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name) => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else throw new TypeError("localStorage not supported in this environment");
  } catch (error) {
    console.error(error);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `reka:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel) => {
    const { constraints, id, idIsFromProps, order } = panel;
    if (idIsFromProps) return id;
    else return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
  }).sort((a, b) => a.localeCompare(b)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId);
    const serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed === "object" && parsed != null) return parsed;
    }
  } catch (error) {
  }
  return null;
}
function loadPanelGroupState(autoSaveId, panels, storage) {
  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {};
  const panelKey = getPanelKey(panels);
  return state[panelKey] ?? null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {
  const panelGroupKey = getPanelGroupKey(autoSaveId);
  const panelKey = getPanelKey(panels);
  const state = loadSerializedPanelGroupState(autoSaveId, storage) ?? {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}

// node_modules/reka-ui/dist/Splitter/SplitterGroup.js
import { computed as computed109, createBlock as createBlock300, defineComponent as defineComponent318, normalizeStyle as normalizeStyle14, openBlock as openBlock309, ref as ref99, renderSlot as renderSlot310, toRefs as toRefs45, unref as unref311, watch as watch38, watchEffect as watchEffect24, withCtx as withCtx305 } from "vue";
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var defaultStorage = {
  getItem: (name) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var [injectPanelGroupContext, providePanelGroupContext] = createContext("PanelGroup");
var SplitterGroup_vue_vue_type_script_setup_true_lang_default = defineComponent318({
  __name: "SplitterGroup",
  props: {
    id: {
      type: [String, null],
      required: false
    },
    autoSaveId: {
      type: [String, null],
      required: false,
      default: null
    },
    direction: {
      type: String,
      required: true
    },
    keyboardResizeBy: {
      type: [Number, null],
      required: false,
      default: 10
    },
    storage: {
      type: Object,
      required: false,
      default: () => defaultStorage
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["layout"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const debounceMap = {};
    const { direction } = toRefs45(props2);
    const groupId = useId2(props2.id, "reka-splitter-group");
    const dir = useDirection();
    const { forwardRef, currentElement: panelGroupElementRef } = useForwardExpose();
    const dragState = ref99(null);
    const layout = ref99([]);
    const panelIdToLastNotifiedSizeMapRef = ref99({});
    const panelSizeBeforeCollapseRef = ref99(/* @__PURE__ */ new Map());
    const prevDeltaRef = ref99(0);
    const committedValuesRef = computed109(() => ({
      autoSaveId: props2.autoSaveId,
      direction: props2.direction,
      dragState: dragState.value,
      id: groupId,
      keyboardResizeBy: props2.keyboardResizeBy,
      storage: props2.storage
    }));
    const eagerValuesRef = ref99({
      layout: layout.value,
      panelDataArray: [],
      panelDataArrayChanged: false
    });
    const setLayout = (val) => layout.value = val;
    useWindowSplitterPanelGroupBehavior({
      eagerValuesRef,
      groupId,
      layout,
      panelDataArray: eagerValuesRef.value.panelDataArray,
      setLayout,
      panelGroupElement: panelGroupElementRef
    });
    watchEffect24(() => {
      const { panelDataArray } = eagerValuesRef.value;
      const { autoSaveId } = props2;
      if (autoSaveId) {
        if (layout.value.length === 0 || layout.value.length !== panelDataArray.length) return;
        let debouncedSave = debounceMap[autoSaveId];
        if (!debouncedSave) {
          debouncedSave = debounce2(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
          debounceMap[autoSaveId] = debouncedSave;
        }
        const clonedPanelDataArray = [...panelDataArray];
        const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.value);
        debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout.value, props2.storage);
      }
    });
    function getPanelStyle(panelData, defaultSize) {
      const { panelDataArray } = eagerValuesRef.value;
      const panelIndex = findPanelDataIndex(panelDataArray, panelData);
      return computePanelFlexBoxStyle({
        defaultSize,
        dragState: dragState.value,
        layout: layout.value,
        panelData: panelDataArray,
        panelIndex
      });
    }
    function registerPanel(panelData) {
      const { panelDataArray } = eagerValuesRef.value;
      panelDataArray.push(panelData);
      panelDataArray.sort((panelA, panelB) => {
        const orderA = panelA.order;
        const orderB = panelB.order;
        if (orderA == null && orderB == null) return 0;
        else if (orderA == null) return -1;
        else if (orderB == null) return 1;
        else return orderA - orderB;
      });
      eagerValuesRef.value.panelDataArrayChanged = true;
    }
    watch38(() => eagerValuesRef.value.panelDataArrayChanged, () => {
      if (eagerValuesRef.value.panelDataArrayChanged) {
        eagerValuesRef.value.panelDataArrayChanged = false;
        const { autoSaveId, storage } = committedValuesRef.value;
        const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
        let unsafeLayout = null;
        if (autoSaveId) {
          const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);
          if (state) {
            panelSizeBeforeCollapseRef.value = new Map(Object.entries(state.expandToSizes));
            unsafeLayout = state.layout;
          }
        }
        if (unsafeLayout === null) unsafeLayout = calculateUnsafeDefaultLayout({ panelDataArray });
        const nextLayout = validatePanelGroupLayout({
          layout: unsafeLayout,
          panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
        });
        if (!areEqual(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.value.layout = nextLayout;
          emits("layout", nextLayout);
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.value);
        }
      }
    });
    function registerResizeHandle2(dragHandleId) {
      return function resizeHandler(event) {
        event.preventDefault();
        const panelGroupElement = panelGroupElementRef.value;
        if (!panelGroupElement) return () => null;
        const { direction: direction$1, dragState: dragState$1, id: groupId$1, keyboardResizeBy } = committedValuesRef.value;
        const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
        const { initialLayout } = dragState$1 ?? {};
        const pivotIndices = determinePivotIndices(groupId$1, dragHandleId, panelGroupElement);
        let delta = calculateDeltaPercentage(event, dragHandleId, direction$1, dragState$1, keyboardResizeBy, panelGroupElement);
        if (delta === 0) return;
        const isHorizontal = direction$1 === "horizontal";
        if (dir.value === "rtl" && isHorizontal) delta = -delta;
        const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
        const nextLayout = adjustLayoutByDelta({
          delta,
          layout: initialLayout ?? prevLayout,
          panelConstraints,
          pivotIndices,
          trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
        });
        const layoutChanged = !compareLayouts(prevLayout, nextLayout);
        if (isMouseEvent2(event) || isTouchEvent(event)) {
          if (prevDeltaRef.value !== delta) {
            prevDeltaRef.value = delta;
            if (!layoutChanged) if (isHorizontal) reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);
            else reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);
            else reportConstraintsViolation(dragHandleId, 0);
          }
        }
        if (layoutChanged) {
          setLayout(nextLayout);
          eagerValuesRef.value.layout = nextLayout;
          emits("layout", nextLayout);
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.value);
        }
      };
    }
    function resizePanel2(panelData, unsafePanelSize) {
      const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
      const panelConstraintsArray = panelDataArray.map((panelData$1) => panelData$1.constraints);
      const { panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);
      assert(panelSize != null);
      const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
      const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
      const nextLayout = adjustLayoutByDelta({
        delta,
        layout: prevLayout,
        panelConstraints: panelConstraintsArray,
        pivotIndices,
        trigger: "imperative-api"
      });
      if (!compareLayouts(prevLayout, nextLayout)) {
        setLayout(nextLayout);
        eagerValuesRef.value.layout = nextLayout;
        emits("layout", nextLayout);
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.value);
      }
    }
    function reevaluatePanelConstraints(panelData, prevConstraints) {
      const { layout: layout$1, panelDataArray } = eagerValuesRef.value;
      const index = findPanelDataIndex(panelDataArray, panelData);
      panelDataArray[index] = panelData;
      eagerValuesRef.value.panelDataArrayChanged = true;
      const { collapsedSize: prevCollapsedSize = 0, collapsible: prevCollapsible } = prevConstraints;
      const { collapsedSize: nextCollapsedSize = 0, collapsible: nextCollapsible, maxSize: nextMaxSize = 100, minSize: nextMinSize = 0 } = panelData.constraints;
      const { panelSize: prevPanelSize } = panelDataHelper(panelDataArray, panelData, layout$1);
      if (prevPanelSize === null) return;
      if (prevCollapsible && nextCollapsible && prevPanelSize === prevCollapsedSize) {
        if (prevCollapsedSize !== nextCollapsedSize) resizePanel2(panelData, nextCollapsedSize);
      } else if (prevPanelSize < nextMinSize) resizePanel2(panelData, nextMinSize);
      else if (prevPanelSize > nextMaxSize) resizePanel2(panelData, nextMaxSize);
    }
    function startDragging(dragHandleId, event) {
      const { direction: direction$1 } = committedValuesRef.value;
      const { layout: layout$1 } = eagerValuesRef.value;
      if (!panelGroupElementRef.value) return;
      const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.value);
      assert(handleElement);
      const initialCursorPosition = getResizeEventCursorPosition(direction$1, event);
      dragState.value = {
        dragHandleId,
        dragHandleRect: handleElement.getBoundingClientRect(),
        initialCursorPosition,
        initialLayout: layout$1
      };
    }
    function stopDragging() {
      dragState.value = null;
    }
    function unregisterPanel(panelData) {
      const { panelDataArray } = eagerValuesRef.value;
      const index = findPanelDataIndex(panelDataArray, panelData);
      if (index >= 0) {
        panelDataArray.splice(index, 1);
        delete panelIdToLastNotifiedSizeMapRef.value[panelData.id];
        eagerValuesRef.value.panelDataArrayChanged = true;
      }
    }
    function collapsePanel(panelData) {
      const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
      if (panelData.constraints.collapsible) {
        const panelConstraintsArray = panelDataArray.map((panelData$1) => panelData$1.constraints);
        const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);
        assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
        if (panelSize !== collapsedSize) {
          panelSizeBeforeCollapseRef.value.set(panelData.id, panelSize);
          const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
          const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
          const nextLayout = adjustLayoutByDelta({
            delta,
            layout: prevLayout,
            panelConstraints: panelConstraintsArray,
            pivotIndices,
            trigger: "imperative-api"
          });
          if (!compareLayouts(prevLayout, nextLayout)) {
            setLayout(nextLayout);
            eagerValuesRef.value.layout = nextLayout;
            emits("layout", nextLayout);
            callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.value);
          }
        }
      }
    }
    function expandPanel(panelData) {
      const { layout: prevLayout, panelDataArray } = eagerValuesRef.value;
      if (panelData.constraints.collapsible) {
        const panelConstraintsArray = panelDataArray.map((panelData$1) => panelData$1.constraints);
        const { collapsedSize = 0, panelSize, minSize = 0, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);
        if (panelSize === collapsedSize) {
          const prevPanelSize = panelSizeBeforeCollapseRef.value.get(panelData.id);
          const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
          const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
          const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
          const nextLayout = adjustLayoutByDelta({
            delta,
            layout: prevLayout,
            panelConstraints: panelConstraintsArray,
            pivotIndices,
            trigger: "imperative-api"
          });
          if (!compareLayouts(prevLayout, nextLayout)) {
            setLayout(nextLayout);
            eagerValuesRef.value.layout = nextLayout;
            emits("layout", nextLayout);
            callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.value);
          }
        }
      }
    }
    function getPanelSize(panelData) {
      const { layout: layout$1, panelDataArray } = eagerValuesRef.value;
      const { panelSize } = panelDataHelper(panelDataArray, panelData, layout$1);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      return panelSize;
    }
    function isPanelCollapsed(panelData) {
      const { layout: layout$1, panelDataArray } = eagerValuesRef.value;
      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout$1);
      if (!collapsible) return false;
      if (panelSize === void 0) return panelData.constraints.defaultSize === panelData.constraints.collapsedSize;
      else return panelSize === collapsedSize;
    }
    function isPanelExpanded(panelData) {
      const { layout: layout$1, panelDataArray } = eagerValuesRef.value;
      const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout$1);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      return !collapsible || panelSize > collapsedSize;
    }
    providePanelGroupContext({
      direction,
      dragState: dragState.value,
      groupId,
      reevaluatePanelConstraints,
      registerPanel,
      registerResizeHandle: registerResizeHandle2,
      resizePanel: resizePanel2,
      startDragging,
      stopDragging,
      unregisterPanel,
      panelGroupElement: panelGroupElementRef,
      collapsePanel,
      expandPanel,
      isPanelCollapsed,
      isPanelExpanded,
      getPanelSize,
      getPanelStyle
    });
    function findPanelDataIndex(panelDataArray, panelData) {
      return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
    }
    function panelDataHelper(panelDataArray, panelData, layout$1) {
      const panelIndex = findPanelDataIndex(panelDataArray, panelData);
      const isLastPanel = panelIndex === panelDataArray.length - 1;
      const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];
      const panelSize = layout$1[panelIndex];
      return {
        ...panelData.constraints,
        panelSize,
        pivotIndices
      };
    }
    return (_ctx, _cache) => {
      return openBlock309(), createBlock300(unref311(Primitive), {
        ref: unref311(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        style: normalizeStyle14({
          display: "flex",
          flexDirection: unref311(direction) === "horizontal" ? "row" : "column",
          height: "100%",
          overflow: "hidden",
          width: "100%"
        }),
        "data-panel-group": "",
        "data-orientation": unref311(direction),
        "data-panel-group-id": unref311(groupId)
      }, {
        default: withCtx305(() => [renderSlot310(_ctx.$slots, "default", { layout: layout.value })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "style",
        "data-orientation",
        "data-panel-group-id"
      ]);
    };
  }
});
var SplitterGroup_default = SplitterGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Splitter/SplitterPanel.js
import { computed as computed110, createBlock as createBlock301, defineComponent as defineComponent319, normalizeStyle as normalizeStyle15, onMounted as onMounted48, onUnmounted as onUnmounted22, openBlock as openBlock310, renderSlot as renderSlot311, unref as unref312, watch as watch39, withCtx as withCtx306 } from "vue";
var SplitterPanel_vue_vue_type_script_setup_true_lang_default = defineComponent319({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {
      type: Number,
      required: false
    },
    collapsible: {
      type: Boolean,
      required: false
    },
    defaultSize: {
      type: Number,
      required: false
    },
    id: {
      type: String,
      required: false
    },
    maxSize: {
      type: Number,
      required: false
    },
    minSize: {
      type: Number,
      required: false
    },
    order: {
      type: Number,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: [
    "collapse",
    "expand",
    "resize"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const panelGroupContext = injectPanelGroupContext();
    if (panelGroupContext === null) throw new Error("SplitterPanel components must be rendered within a SplitterGroup container");
    const { collapsePanel, expandPanel, getPanelSize, getPanelStyle, isPanelCollapsed, resizePanel: resizePanel2, groupId, reevaluatePanelConstraints, registerPanel, unregisterPanel } = panelGroupContext;
    const panelId = useId2(props2.id, "reka-splitter-panel");
    const panelDataRef = computed110(() => ({
      callbacks: {
        onCollapse: () => emits("collapse"),
        onExpand: () => emits("expand"),
        onResize: (...args) => emits("resize", ...args)
      },
      constraints: {
        collapsedSize: props2.collapsedSize && Number.parseFloat(props2.collapsedSize.toFixed(PRECISION)),
        collapsible: props2.collapsible,
        defaultSize: props2.defaultSize,
        maxSize: props2.maxSize,
        minSize: props2.minSize
      },
      id: panelId,
      idIsFromProps: props2.id !== void 0,
      order: props2.order
    }));
    watch39(() => panelDataRef.value.constraints, (constraints, prevConstraints) => {
      if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) reevaluatePanelConstraints(panelDataRef.value, prevConstraints);
    }, { deep: true });
    onMounted48(() => {
      registerPanel(panelDataRef.value);
    });
    onUnmounted22(() => {
      unregisterPanel(panelDataRef.value);
    });
    const style = computed110(() => getPanelStyle(panelDataRef.value, props2.defaultSize));
    const isCollapsed = computed110(() => isPanelCollapsed(panelDataRef.value));
    const isExpanded = computed110(() => !isCollapsed.value);
    function collapse() {
      collapsePanel(panelDataRef.value);
    }
    function expand() {
      expandPanel(panelDataRef.value);
    }
    function resize(size3) {
      resizePanel2(panelDataRef.value, size3);
    }
    __expose({
      collapse,
      expand,
      getSize() {
        return getPanelSize(panelDataRef.value);
      },
      resize,
      isCollapsed,
      isExpanded
    });
    return (_ctx, _cache) => {
      return openBlock310(), createBlock301(unref312(Primitive), {
        id: unref312(panelId),
        style: normalizeStyle15(style.value),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-panel": "",
        "data-panel-collapsible": _ctx.collapsible || void 0,
        "data-panel-group-id": unref312(groupId),
        "data-panel-id": unref312(panelId),
        "data-panel-size": Number.parseFloat(`${style.value.flexGrow}`).toFixed(1),
        "data-state": _ctx.collapsible ? isCollapsed.value ? "collapsed" : "expanded" : void 0
      }, {
        default: withCtx306(() => [renderSlot311(_ctx.$slots, "default", {
          isCollapsed: isCollapsed.value,
          isExpanded: isExpanded.value,
          expand,
          collapse,
          resize
        })]),
        _: 3
      }, 8, [
        "id",
        "style",
        "as",
        "as-child",
        "data-panel-collapsible",
        "data-panel-group-id",
        "data-panel-id",
        "data-panel-size",
        "data-state"
      ]);
    };
  }
});
var SplitterPanel_default = SplitterPanel_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/composables/useWindowSplitterBehavior.js
import { watchEffect as watchEffect25 } from "vue";
function useWindowSplitterResizeHandlerBehavior({ disabled, handleId, resizeHandler, panelGroupElement }) {
  watchEffect25((onCleanup) => {
    const _panelGroupElement = panelGroupElement.value;
    if (disabled.value || resizeHandler.value === null || _panelGroupElement === null) return;
    const handleElement = getResizeHandleElement(handleId, _panelGroupElement);
    if (handleElement == null) return;
    const onKeyDown = (event) => {
      if (event.defaultPrevented) return;
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home": {
          event.preventDefault();
          resizeHandler.value?.(event);
          break;
        }
        case "F6": {
          event.preventDefault();
          const groupId = handleElement.getAttribute("data-panel-group-id");
          assert(groupId);
          const handles = getResizeHandleElementsForGroup(groupId, _panelGroupElement);
          const index = getResizeHandleElementIndex(groupId, handleId, _panelGroupElement);
          assert(index !== null);
          const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;
          const nextHandle = handles[nextIndex];
          nextHandle.focus();
          break;
        }
      }
    };
    handleElement.addEventListener("keydown", onKeyDown);
    onCleanup(() => {
      handleElement.removeEventListener("keydown", onKeyDown);
    });
  });
}

// node_modules/reka-ui/dist/Splitter/SplitterResizeHandle.js
import { createBlock as createBlock302, defineComponent as defineComponent320, openBlock as openBlock311, ref as ref100, renderSlot as renderSlot312, toRefs as toRefs46, unref as unref313, watch as watch40, watchEffect as watchEffect26, withCtx as withCtx307 } from "vue";
var SplitterResizeHandle_vue_vue_type_script_setup_true_lang_default = defineComponent320({
  __name: "SplitterResizeHandle",
  props: {
    id: {
      type: String,
      required: false
    },
    hitAreaMargins: {
      type: Object,
      required: false
    },
    tabindex: {
      type: Number,
      required: false,
      default: 0
    },
    disabled: {
      type: Boolean,
      required: false
    },
    nonce: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["dragging"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const { disabled } = toRefs46(props2);
    const panelGroupContext = injectPanelGroupContext();
    if (panelGroupContext === null) throw new Error("PanelResizeHandle components must be rendered within a PanelGroup container");
    const { direction, groupId, registerResizeHandle: registerResizeHandleWithParentGroup, startDragging, stopDragging, panelGroupElement } = panelGroupContext;
    const resizeHandleId = useId2(props2.id, "reka-splitter-resize-handle");
    const state = ref100("inactive");
    const isFocused = ref100(false);
    const resizeHandler = ref100(null);
    const { nonce: propNonce } = toRefs46(props2);
    const nonce = useNonce(propNonce);
    watch40(disabled, () => {
      if (!isBrowser) return;
      if (disabled.value) resizeHandler.value = null;
      else resizeHandler.value = registerResizeHandleWithParentGroup(resizeHandleId);
    }, { immediate: true });
    watchEffect26((onCleanup) => {
      if (disabled.value || resizeHandler.value === null) return;
      const element = currentElement.value;
      if (!element) return;
      assert(element);
      const setResizeHandlerState = (action, isActive, event) => {
        if (isActive) switch (action) {
          case "down": {
            state.value = "drag";
            startDragging(resizeHandleId, event);
            emits("dragging", true);
            break;
          }
          case "move": {
            if (state.value !== "drag") state.value = "hover";
            resizeHandler.value?.(event);
            break;
          }
          case "up": {
            state.value = "hover";
            stopDragging();
            emits("dragging", false);
            break;
          }
        }
        else state.value = "inactive";
      };
      onCleanup(registerResizeHandle(resizeHandleId, element, direction, {
        coarse: props2.hitAreaMargins?.coarse ?? 15,
        fine: props2.hitAreaMargins?.fine ?? 5
      }, nonce, setResizeHandlerState));
    });
    useWindowSplitterResizeHandlerBehavior({
      disabled,
      resizeHandler,
      handleId: resizeHandleId,
      panelGroupElement
    });
    return (_ctx, _cache) => {
      return openBlock311(), createBlock302(unref313(Primitive), {
        id: unref313(resizeHandleId),
        ref: unref313(forwardRef),
        style: {
          touchAction: "none",
          userSelect: "none"
        },
        as: _ctx.as,
        "as-child": _ctx.asChild,
        role: "separator",
        "data-resize-handle": "",
        tabindex: _ctx.tabindex,
        "data-state": state.value,
        "data-disabled": unref313(disabled) ? "" : void 0,
        "data-orientation": unref313(direction),
        "data-panel-group-id": unref313(groupId),
        "data-resize-handle-active": state.value === "drag" ? "pointer" : isFocused.value ? "keyboard" : void 0,
        "data-resize-handle-state": state.value,
        "data-panel-resize-handle-enabled": !unref313(disabled),
        "data-panel-resize-handle-id": unref313(resizeHandleId),
        onBlur: _cache[0] || (_cache[0] = ($event) => isFocused.value = false),
        onFocus: _cache[1] || (_cache[1] = ($event) => isFocused.value = false)
      }, {
        default: withCtx307(() => [renderSlot312(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "as",
        "as-child",
        "tabindex",
        "data-state",
        "data-disabled",
        "data-orientation",
        "data-panel-group-id",
        "data-resize-handle-active",
        "data-resize-handle-state",
        "data-panel-resize-handle-enabled",
        "data-panel-resize-handle-id"
      ]);
    };
  }
});
var SplitterResizeHandle_default = SplitterResizeHandle_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Stepper/StepperRoot.js
import { computed as computed111, createBlock as createBlock303, createElementVNode as createElementVNode5, defineComponent as defineComponent321, nextTick as nextTick30, openBlock as openBlock312, ref as ref101, renderSlot as renderSlot313, toDisplayString as toDisplayString13, toRefs as toRefs47, unref as unref314, watch as watch41, withCtx as withCtx308 } from "vue";
var _hoisted_17 = {
  "aria-live": "polite",
  "aria-atomic": "true",
  role: "status",
  style: {
    transform: "translateX(-100%)",
    position: "absolute",
    pointerEvents: "none",
    opacity: 0,
    margin: 0
  }
};
var [injectStepperRootContext, provideStepperRootContext] = createContext("StepperRoot");
var StepperRoot_vue_vue_type_script_setup_true_lang_default = defineComponent321({
  __name: "StepperRoot",
  props: {
    defaultValue: {
      type: Number,
      required: false,
      default: 1
    },
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: false
    },
    modelValue: {
      type: Number,
      required: false
    },
    linear: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { dir: propDir, orientation: propOrientation, linear } = toRefs47(props2);
    const dir = useDirection(propDir);
    const totalStepperItems = ref101(/* @__PURE__ */ new Set());
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const totalStepperItemsArray = computed111(() => Array.from(totalStepperItems.value));
    const isFirstStep = computed111(() => modelValue.value === 1);
    const isLastStep = computed111(() => modelValue.value === totalStepperItemsArray.value.length);
    const totalSteps = computed111(() => totalStepperItems.value.size);
    function goToStep(step) {
      if (step > totalSteps.value) return;
      if (step < 1) return;
      if (totalStepperItems.value.size && !!totalStepperItemsArray.value[step] && !!totalStepperItemsArray.value[step].getAttribute("disabled")) return;
      if (linear.value) {
        if (step > (modelValue.value ?? 1) + 1) return;
      }
      modelValue.value = step;
    }
    function nextStep() {
      goToStep((modelValue.value ?? 1) + 1);
    }
    function prevStep() {
      goToStep((modelValue.value ?? 1) - 1);
    }
    function hasNext() {
      return (modelValue.value ?? 1) < totalSteps.value;
    }
    function hasPrev() {
      return (modelValue.value ?? 1) > 1;
    }
    const nextStepperItem = ref101(null);
    const prevStepperItem = ref101(null);
    const isNextDisabled = computed111(() => nextStepperItem.value ? nextStepperItem.value.getAttribute("disabled") === "" : true);
    const isPrevDisabled = computed111(() => prevStepperItem.value ? prevStepperItem.value.getAttribute("disabled") === "" : true);
    watch41(modelValue, async () => {
      await nextTick30(() => {
        nextStepperItem.value = totalStepperItemsArray.value.length && modelValue.value < totalStepperItemsArray.value.length ? totalStepperItemsArray.value[modelValue.value] : null;
        prevStepperItem.value = totalStepperItemsArray.value.length && modelValue.value > 1 ? totalStepperItemsArray.value[modelValue.value - 2] : null;
      });
    });
    watch41(totalStepperItemsArray, async () => {
      await nextTick30(() => {
        nextStepperItem.value = totalStepperItemsArray.value.length && modelValue.value < totalStepperItemsArray.value.length ? totalStepperItemsArray.value[modelValue.value] : null;
        prevStepperItem.value = totalStepperItemsArray.value.length && modelValue.value > 1 ? totalStepperItemsArray.value[modelValue.value - 2] : null;
      });
    });
    provideStepperRootContext({
      modelValue,
      changeModelValue: (value) => {
        modelValue.value = value;
      },
      orientation: propOrientation,
      dir,
      linear,
      totalStepperItems
    });
    __expose({
      goToStep,
      nextStep,
      prevStep,
      modelValue,
      totalSteps,
      isNextDisabled,
      isPrevDisabled,
      isFirstStep,
      isLastStep,
      hasNext,
      hasPrev
    });
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock312(), createBlock303(unref314(Primitive), {
        role: "group",
        "aria-label": "progress",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-linear": unref314(linear) ? "" : void 0,
        "data-orientation": _ctx.orientation
      }, {
        default: withCtx308(() => [renderSlot313(_ctx.$slots, "default", {
          modelValue: unref314(modelValue),
          totalSteps: totalStepperItems.value.size,
          isNextDisabled: isNextDisabled.value,
          isPrevDisabled: isPrevDisabled.value,
          isFirstStep: isFirstStep.value,
          isLastStep: isLastStep.value,
          goToStep,
          nextStep,
          prevStep,
          hasNext,
          hasPrev
        }), createElementVNode5("div", _hoisted_17, " Step " + toDisplayString13(unref314(modelValue)) + " of " + toDisplayString13(totalStepperItems.value.size), 1)]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-linear",
        "data-orientation"
      ]);
    };
  }
});
var StepperRoot_default = StepperRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Stepper/StepperItem.js
import { computed as computed112, createBlock as createBlock304, defineComponent as defineComponent322, openBlock as openBlock313, renderSlot as renderSlot314, toRefs as toRefs48, unref as unref315, withCtx as withCtx309 } from "vue";
var [injectStepperItemContext, provideStepperItemContext] = createContext("StepperItem");
var StepperItem_vue_vue_type_script_setup_true_lang_default = defineComponent322({
  __name: "StepperItem",
  props: {
    step: {
      type: Number,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    completed: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { disabled, step, completed } = toRefs48(props2);
    const { forwardRef } = useForwardExpose();
    const rootContext = injectStepperRootContext();
    const titleId = useId2(void 0, "reka-stepper-item-title");
    const descriptionId = useId2(void 0, "reka-stepper-item-description");
    const itemState = computed112(() => {
      if (completed.value) return "completed";
      if (rootContext.modelValue.value === step.value) return "active";
      if (rootContext.modelValue.value > step.value) return "completed";
      return "inactive";
    });
    const isFocusable = computed112(() => {
      if (disabled.value) return false;
      if (rootContext.linear.value) return step.value <= rootContext.modelValue.value || step.value === rootContext.modelValue.value + 1;
      return true;
    });
    provideStepperItemContext({
      titleId,
      descriptionId,
      state: itemState,
      disabled,
      step,
      isFocusable
    });
    return (_ctx, _cache) => {
      return openBlock313(), createBlock304(unref315(Primitive), {
        ref: unref315(forwardRef),
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-current": itemState.value === "active" ? "true" : void 0,
        "data-state": itemState.value,
        disabled: unref315(disabled) || !isFocusable.value ? "" : void 0,
        "data-disabled": unref315(disabled) || !isFocusable.value ? "" : void 0,
        "data-orientation": unref315(rootContext).orientation.value
      }, {
        default: withCtx309(() => [renderSlot314(_ctx.$slots, "default", { state: itemState.value })]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-current",
        "data-state",
        "disabled",
        "data-disabled",
        "data-orientation"
      ]);
    };
  }
});
var StepperItem_default = StepperItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Stepper/StepperDescription.js
import { createBlock as createBlock305, defineComponent as defineComponent323, mergeProps as mergeProps142, openBlock as openBlock314, renderSlot as renderSlot315, unref as unref316, withCtx as withCtx310 } from "vue";
var StepperDescription_vue_vue_type_script_setup_true_lang_default = defineComponent323({
  __name: "StepperDescription",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "p"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const itemContext = injectStepperItemContext();
    return (_ctx, _cache) => {
      return openBlock314(), createBlock305(unref316(Primitive), mergeProps142(props2, { id: unref316(itemContext).descriptionId }), {
        default: withCtx310(() => [renderSlot315(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var StepperDescription_default = StepperDescription_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Stepper/StepperIndicator.js
import { createBlock as createBlock306, createTextVNode as createTextVNode28, defineComponent as defineComponent324, guardReactiveProps as guardReactiveProps102, normalizeProps as normalizeProps102, openBlock as openBlock315, renderSlot as renderSlot316, toDisplayString as toDisplayString14, unref as unref317, withCtx as withCtx311 } from "vue";
var StepperIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent324({
  __name: "StepperIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectStepperItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock315(), createBlock306(unref317(Primitive), normalizeProps102(guardReactiveProps102(props2)), {
        default: withCtx311(() => [renderSlot316(_ctx.$slots, "default", { step: unref317(itemContext).step.value }, () => [createTextVNode28(" Step " + toDisplayString14(unref317(itemContext).step.value), 1)])]),
        _: 3
      }, 16);
    };
  }
});
var StepperIndicator_default = StepperIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Stepper/StepperSeparator.js
import { createBlock as createBlock307, defineComponent as defineComponent325, mergeProps as mergeProps143, openBlock as openBlock316, renderSlot as renderSlot317, unref as unref318, withCtx as withCtx312 } from "vue";
var StepperSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent325({
  __name: "StepperSeparator",
  props: {
    orientation: {
      type: String,
      required: false
    },
    decorative: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectStepperRootContext();
    const itemContext = injectStepperItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock316(), createBlock307(unref318(Separator_default), mergeProps143(props2, {
        decorative: "",
        orientation: unref318(rootContext).orientation.value,
        "data-state": unref318(itemContext).state.value
      }), {
        default: withCtx312(() => [renderSlot317(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["orientation", "data-state"]);
    };
  }
});
var StepperSeparator_default = StepperSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Stepper/StepperTitle.js
import { createBlock as createBlock308, defineComponent as defineComponent326, mergeProps as mergeProps144, openBlock as openBlock317, renderSlot as renderSlot318, unref as unref319, withCtx as withCtx313 } from "vue";
var StepperTitle_vue_vue_type_script_setup_true_lang_default = defineComponent326({
  __name: "StepperTitle",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "h4"
    }
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectStepperItemContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock317(), createBlock308(unref319(Primitive), mergeProps144(props2, { id: unref319(itemContext).titleId }), {
        default: withCtx313(() => [renderSlot318(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var StepperTitle_default = StepperTitle_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Stepper/StepperTrigger.js
import { computed as computed113, createBlock as createBlock309, defineComponent as defineComponent327, onMounted as onMounted49, onUnmounted as onUnmounted23, openBlock as openBlock318, renderSlot as renderSlot319, unref as unref320, withCtx as withCtx314, withKeys as withKeys20, withModifiers as withModifiers20 } from "vue";
var StepperTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent327({
  __name: "StepperTrigger",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const rootContext = injectStepperRootContext();
    const itemContext = injectStepperItemContext();
    const kbd = useKbd();
    const stepperItems = computed113(() => Array.from(rootContext.totalStepperItems.value));
    function handleMouseDown(event) {
      if (itemContext.disabled.value) return;
      if (rootContext.linear.value) {
        if (itemContext.step.value <= rootContext.modelValue.value || itemContext.step.value === rootContext.modelValue.value + 1) {
          if (event.ctrlKey === false) {
            rootContext.changeModelValue(itemContext.step.value);
            return;
          }
        }
      } else if (event.ctrlKey === false) {
        rootContext.changeModelValue(itemContext.step.value);
        return;
      }
      event.preventDefault();
    }
    function handleKeyDown(event) {
      event.preventDefault();
      if (itemContext.disabled.value) return;
      if ((event.key === kbd.ENTER || event.key === kbd.SPACE) && !event.ctrlKey && !event.shiftKey) rootContext.changeModelValue(itemContext.step.value);
      if ([
        kbd.ARROW_LEFT,
        kbd.ARROW_RIGHT,
        kbd.ARROW_UP,
        kbd.ARROW_DOWN
      ].includes(event.key)) useArrowNavigation(event, getActiveElement(), void 0, {
        itemsArray: stepperItems.value,
        focus: true,
        loop: false,
        arrowKeyOptions: rootContext.orientation.value,
        dir: rootContext.dir.value
      });
    }
    const { forwardRef, currentElement } = useForwardExpose();
    onMounted49(() => {
      rootContext.totalStepperItems.value.add(currentElement.value);
    });
    onUnmounted23(() => {
      rootContext.totalStepperItems.value.delete(currentElement.value);
    });
    return (_ctx, _cache) => {
      return openBlock318(), createBlock309(unref320(Primitive), {
        ref: unref320(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-state": unref320(itemContext).state.value,
        disabled: unref320(itemContext).disabled.value || !unref320(itemContext).isFocusable.value ? "" : void 0,
        "data-disabled": unref320(itemContext).disabled.value || !unref320(itemContext).isFocusable.value ? "" : void 0,
        "data-orientation": unref320(rootContext).orientation.value,
        tabindex: unref320(itemContext).isFocusable.value ? 0 : -1,
        "aria-describedby": unref320(itemContext).descriptionId,
        "aria-labelledby": unref320(itemContext).titleId,
        onMousedown: withModifiers20(handleMouseDown, ["left"]),
        onKeydown: withKeys20(handleKeyDown, [
          "enter",
          "space",
          "left",
          "right",
          "up",
          "down"
        ])
      }, {
        default: withCtx314(() => [renderSlot319(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "type",
        "as",
        "as-child",
        "data-state",
        "disabled",
        "data-disabled",
        "data-orientation",
        "tabindex",
        "aria-describedby",
        "aria-labelledby"
      ]);
    };
  }
});
var StepperTrigger_default = StepperTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Switch/SwitchRoot.js
import { computed as computed114, createBlock as createBlock310, createCommentVNode as createCommentVNode34, defineComponent as defineComponent328, mergeProps as mergeProps145, openBlock as openBlock319, renderSlot as renderSlot320, toRefs as toRefs49, unref as unref321, withCtx as withCtx315, withKeys as withKeys21, withModifiers as withModifiers21 } from "vue";
var [injectSwitchRootContext, provideSwitchRootContext] = createContext("SwitchRoot");
var SwitchRoot_vue_vue_type_script_setup_true_lang_default = defineComponent328({
  __name: "SwitchRoot",
  props: {
    defaultValue: {
      type: Boolean,
      required: false
    },
    modelValue: {
      type: [Boolean, null],
      required: false,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: false
    },
    id: {
      type: String,
      required: false
    },
    value: {
      type: String,
      required: false,
      default: "on"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    const { disabled } = toRefs49(props2);
    const modelValue = useVModel(props2, "modelValue", emit, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    function toggleCheck() {
      if (disabled.value) return;
      modelValue.value = !modelValue.value;
    }
    const { forwardRef, currentElement } = useForwardExpose();
    const isFormControl = useFormControl(currentElement);
    const ariaLabel = computed114(() => props2.id && currentElement.value ? document.querySelector(`[for="${props2.id}"]`)?.innerText : void 0);
    provideSwitchRootContext({
      modelValue,
      toggleCheck,
      disabled
    });
    return (_ctx, _cache) => {
      return openBlock319(), createBlock310(unref321(Primitive), mergeProps145(_ctx.$attrs, {
        id: _ctx.id,
        ref: unref321(forwardRef),
        role: "switch",
        type: _ctx.as === "button" ? "button" : void 0,
        value: _ctx.value,
        "aria-label": _ctx.$attrs["aria-label"] || ariaLabel.value,
        "aria-checked": unref321(modelValue),
        "aria-required": _ctx.required,
        "data-state": unref321(modelValue) ? "checked" : "unchecked",
        "data-disabled": unref321(disabled) ? "" : void 0,
        "as-child": _ctx.asChild,
        as: _ctx.as,
        disabled: unref321(disabled),
        onClick: toggleCheck,
        onKeydown: withKeys21(withModifiers21(toggleCheck, ["prevent"]), ["enter"])
      }), {
        default: withCtx315(() => [renderSlot320(_ctx.$slots, "default", { modelValue: unref321(modelValue) }), unref321(isFormControl) && _ctx.name ? (openBlock319(), createBlock310(unref321(VisuallyHiddenInput_default), {
          key: 0,
          type: "checkbox",
          name: _ctx.name,
          disabled: unref321(disabled),
          required: _ctx.required,
          value: _ctx.value,
          checked: !!unref321(modelValue)
        }, null, 8, [
          "name",
          "disabled",
          "required",
          "value",
          "checked"
        ])) : createCommentVNode34("v-if", true)]),
        _: 3
      }, 16, [
        "id",
        "type",
        "value",
        "aria-label",
        "aria-checked",
        "aria-required",
        "data-state",
        "data-disabled",
        "as-child",
        "as",
        "disabled",
        "onKeydown"
      ]);
    };
  }
});
var SwitchRoot_default = SwitchRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Switch/SwitchThumb.js
import { createBlock as createBlock311, defineComponent as defineComponent329, openBlock as openBlock320, renderSlot as renderSlot321, unref as unref322, withCtx as withCtx316 } from "vue";
var SwitchThumb_vue_vue_type_script_setup_true_lang_default = defineComponent329({
  __name: "SwitchThumb",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const rootContext = injectSwitchRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock320(), createBlock311(unref322(Primitive), {
        "data-state": unref322(rootContext).modelValue?.value ? "checked" : "unchecked",
        "data-disabled": unref322(rootContext).disabled.value ? "" : void 0,
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx316(() => [renderSlot321(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "data-state",
        "data-disabled",
        "as-child",
        "as"
      ]);
    };
  }
});
var SwitchThumb_default = SwitchThumb_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tabs/TabsRoot.js
import { createBlock as createBlock312, defineComponent as defineComponent330, openBlock as openBlock321, ref as ref102, renderSlot as renderSlot322, toRefs as toRefs50, unref as unref323, withCtx as withCtx317 } from "vue";
var [injectTabsRootContext, provideTabsRootContext] = createContext("TabsRoot");
var TabsRoot_vue_vue_type_script_setup_true_lang_default = defineComponent330({
  __name: "TabsRoot",
  props: {
    defaultValue: {
      type: null,
      required: false
    },
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: false
    },
    activationMode: {
      type: String,
      required: false,
      default: "automatic"
    },
    modelValue: {
      type: null,
      required: false
    },
    unmountOnHide: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { orientation, unmountOnHide, dir: propDir } = toRefs50(props2);
    const dir = useDirection(propDir);
    useForwardExpose();
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    const tabsList = ref102();
    provideTabsRootContext({
      modelValue,
      changeModelValue: (value) => {
        modelValue.value = value;
      },
      orientation,
      dir,
      unmountOnHide,
      activationMode: props2.activationMode,
      baseId: useId2(void 0, "reka-tabs"),
      tabsList
    });
    return (_ctx, _cache) => {
      return openBlock321(), createBlock312(unref323(Primitive), {
        dir: unref323(dir),
        "data-orientation": unref323(orientation),
        "as-child": _ctx.asChild,
        as: _ctx.as
      }, {
        default: withCtx317(() => [renderSlot322(_ctx.$slots, "default", { modelValue: unref323(modelValue) })]),
        _: 3
      }, 8, [
        "dir",
        "data-orientation",
        "as-child",
        "as"
      ]);
    };
  }
});
var TabsRoot_default = TabsRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tabs/utils.js
function makeTriggerId2(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId2(baseId, value) {
  return `${baseId}-content-${value}`;
}

// node_modules/reka-ui/dist/Tabs/TabsContent.js
import { computed as computed115, createBlock as createBlock313, createCommentVNode as createCommentVNode35, createVNode as createVNode58, defineComponent as defineComponent331, normalizeStyle as normalizeStyle16, onMounted as onMounted50, openBlock as openBlock322, ref as ref103, renderSlot as renderSlot323, unref as unref324, withCtx as withCtx318 } from "vue";
var TabsContent_vue_vue_type_script_setup_true_lang_default = defineComponent331({
  __name: "TabsContent",
  props: {
    value: {
      type: [String, Number],
      required: true
    },
    forceMount: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectTabsRootContext();
    const triggerId = computed115(() => makeTriggerId2(rootContext.baseId, props2.value));
    const contentId = computed115(() => makeContentId2(rootContext.baseId, props2.value));
    const isSelected = computed115(() => props2.value === rootContext.modelValue.value);
    const isMountAnimationPreventedRef = ref103(isSelected.value);
    onMounted50(() => {
      requestAnimationFrame(() => {
        isMountAnimationPreventedRef.value = false;
      });
    });
    return (_ctx, _cache) => {
      return openBlock322(), createBlock313(unref324(Presence_default), {
        present: _ctx.forceMount || isSelected.value,
        "force-mount": ""
      }, {
        default: withCtx318(({ present }) => [createVNode58(unref324(Primitive), {
          id: contentId.value,
          ref: unref324(forwardRef),
          "as-child": _ctx.asChild,
          as: _ctx.as,
          role: "tabpanel",
          "data-state": isSelected.value ? "active" : "inactive",
          "data-orientation": unref324(rootContext).orientation.value,
          "aria-labelledby": triggerId.value,
          hidden: !present,
          tabindex: "0",
          style: normalizeStyle16({ animationDuration: isMountAnimationPreventedRef.value ? "0s" : void 0 })
        }, {
          default: withCtx318(() => [(unref324(rootContext).unmountOnHide.value ? present : true) ? renderSlot323(_ctx.$slots, "default", { key: 0 }) : createCommentVNode35("v-if", true)]),
          _: 2
        }, 1032, [
          "id",
          "as-child",
          "as",
          "data-state",
          "data-orientation",
          "aria-labelledby",
          "hidden",
          "style"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var TabsContent_default = TabsContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tabs/TabsIndicator.js
import { createBlock as createBlock314, createCommentVNode as createCommentVNode36, defineComponent as defineComponent332, mergeProps as mergeProps146, nextTick as nextTick31, openBlock as openBlock323, ref as ref104, renderSlot as renderSlot324, unref as unref325, watch as watch42, withCtx as withCtx319 } from "vue";
var TabsIndicator_vue_vue_type_script_setup_true_lang_default = defineComponent332({
  __name: "TabsIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectTabsRootContext();
    useForwardExpose();
    const activeTab = ref104();
    const indicatorStyle = ref104({
      size: null,
      position: null
    });
    watch42(() => [context2.modelValue.value, context2?.dir.value], async () => {
      await nextTick31();
      updateIndicatorStyle();
    }, { immediate: true });
    useResizeObserver([context2.tabsList, activeTab], updateIndicatorStyle);
    function updateIndicatorStyle() {
      activeTab.value = context2.tabsList.value?.querySelector('[role="tab"][data-state="active"]');
      if (!activeTab.value) return;
      if (context2.orientation.value === "horizontal") indicatorStyle.value = {
        size: activeTab.value.offsetWidth,
        position: activeTab.value.offsetLeft
      };
      else indicatorStyle.value = {
        size: activeTab.value.offsetHeight,
        position: activeTab.value.offsetTop
      };
    }
    return (_ctx, _cache) => {
      return typeof indicatorStyle.value.size === "number" ? (openBlock323(), createBlock314(unref325(Primitive), mergeProps146({ key: 0 }, props2, { style: {
        "--reka-tabs-indicator-size": `${indicatorStyle.value.size}px`,
        "--reka-tabs-indicator-position": `${indicatorStyle.value.position}px`
      } }), {
        default: withCtx319(() => [renderSlot324(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["style"])) : createCommentVNode36("v-if", true);
    };
  }
});
var TabsIndicator_default = TabsIndicator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tabs/TabsList.js
import { createBlock as createBlock315, createVNode as createVNode59, defineComponent as defineComponent333, openBlock as openBlock324, renderSlot as renderSlot325, toRefs as toRefs51, unref as unref326, withCtx as withCtx320 } from "vue";
var TabsList_vue_vue_type_script_setup_true_lang_default = defineComponent333({
  __name: "TabsList",
  props: {
    loop: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { loop } = toRefs51(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const context2 = injectTabsRootContext();
    context2.tabsList = currentElement;
    return (_ctx, _cache) => {
      return openBlock324(), createBlock315(unref326(RovingFocusGroup_default), {
        "as-child": "",
        orientation: unref326(context2).orientation.value,
        dir: unref326(context2).dir.value,
        loop: unref326(loop)
      }, {
        default: withCtx320(() => [createVNode59(unref326(Primitive), {
          ref: unref326(forwardRef),
          role: "tablist",
          "as-child": _ctx.asChild,
          as: _ctx.as,
          "aria-orientation": unref326(context2).orientation.value
        }, {
          default: withCtx320(() => [renderSlot325(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as-child",
          "as",
          "aria-orientation"
        ])]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]);
    };
  }
});
var TabsList_default = TabsList_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tabs/TabsTrigger.js
import { computed as computed116, createBlock as createBlock316, createVNode as createVNode60, defineComponent as defineComponent334, openBlock as openBlock325, renderSlot as renderSlot326, unref as unref327, withCtx as withCtx321, withKeys as withKeys22, withModifiers as withModifiers22 } from "vue";
var TabsTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent334({
  __name: "TabsTrigger",
  props: {
    value: {
      type: [String, Number],
      required: true
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const rootContext = injectTabsRootContext();
    const triggerId = computed116(() => makeTriggerId2(rootContext.baseId, props2.value));
    const contentId = computed116(() => makeContentId2(rootContext.baseId, props2.value));
    const isSelected = computed116(() => props2.value === rootContext.modelValue.value);
    return (_ctx, _cache) => {
      return openBlock325(), createBlock316(unref327(RovingFocusItem_default), {
        "as-child": "",
        focusable: !_ctx.disabled,
        active: isSelected.value
      }, {
        default: withCtx321(() => [createVNode60(unref327(Primitive), {
          id: triggerId.value,
          ref: unref327(forwardRef),
          role: "tab",
          type: _ctx.as === "button" ? "button" : void 0,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "aria-selected": isSelected.value ? "true" : "false",
          "aria-controls": contentId.value,
          "data-state": isSelected.value ? "active" : "inactive",
          disabled: _ctx.disabled,
          "data-disabled": _ctx.disabled ? "" : void 0,
          "data-orientation": unref327(rootContext).orientation.value,
          onMousedown: _cache[0] || (_cache[0] = withModifiers22((event) => {
            if (!_ctx.disabled && event.ctrlKey === false) unref327(rootContext).changeModelValue(_ctx.value);
            else event.preventDefault();
          }, ["left"])),
          onKeydown: _cache[1] || (_cache[1] = withKeys22(($event) => unref327(rootContext).changeModelValue(_ctx.value), ["enter", "space"])),
          onFocus: _cache[2] || (_cache[2] = () => {
            const isAutomaticActivation = unref327(rootContext).activationMode !== "manual";
            if (!isSelected.value && !_ctx.disabled && isAutomaticActivation) unref327(rootContext).changeModelValue(_ctx.value);
          })
        }, {
          default: withCtx321(() => [renderSlot326(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "id",
          "type",
          "as",
          "as-child",
          "aria-selected",
          "aria-controls",
          "data-state",
          "disabled",
          "data-disabled",
          "data-orientation"
        ])]),
        _: 3
      }, 8, ["focusable", "active"]);
    };
  }
});
var TabsTrigger_default = TabsTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TagsInput/TagsInputRoot.js
import { computed as computed117, createBlock as createBlock317, createCommentVNode as createCommentVNode37, createVNode as createVNode61, defineComponent as defineComponent335, openBlock as openBlock326, ref as ref105, renderSlot as renderSlot327, toRefs as toRefs52, unref as unref328, withCtx as withCtx322 } from "vue";
var [injectTagsInputRootContext, provideTagsInputRootContext] = createContext("TagsInputRoot");
var TagsInputRoot_vue_vue_type_script_setup_true_lang_default = defineComponent335({
  __name: "TagsInputRoot",
  props: {
    modelValue: {
      type: [Array, null],
      required: false
    },
    defaultValue: {
      type: Array,
      required: false,
      default: () => []
    },
    addOnPaste: {
      type: Boolean,
      required: false
    },
    addOnTab: {
      type: Boolean,
      required: false
    },
    addOnBlur: {
      type: Boolean,
      required: false
    },
    duplicate: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    delimiter: {
      type: null,
      required: false,
      default: ","
    },
    dir: {
      type: String,
      required: false
    },
    max: {
      type: Number,
      required: false,
      default: 0
    },
    id: {
      type: String,
      required: false
    },
    convertValue: {
      type: Function,
      required: false
    },
    displayValue: {
      type: Function,
      required: false,
      default: (value) => value.toString()
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: [
    "update:modelValue",
    "invalid",
    "addTag",
    "removeTag"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { addOnPaste, disabled, delimiter, max: max2, id, dir: propDir, addOnBlur, addOnTab } = toRefs52(props2);
    const dir = useDirection(propDir);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: true,
      deep: true
    });
    const { forwardRef, currentElement } = useForwardExpose();
    const { focused } = useFocusWithin(currentElement);
    const isFormControl = useFormControl(currentElement);
    const { getItems, CollectionSlot } = useCollection({ isProvider: true });
    const selectedElement = ref105();
    const isInvalidInput = ref105(false);
    const currentModelValue = computed117(() => Array.isArray(modelValue.value) ? [...modelValue.value] : []);
    function handleRemoveTag(index) {
      if (index !== -1) {
        const collection = getItems().filter((i) => i.ref.dataset.disabled !== "");
        modelValue.value = modelValue.value.filter((_, i) => i !== index);
        emits("removeTag", collection[index].value);
      }
    }
    provideTagsInputRootContext({
      modelValue,
      onAddValue: (_payload) => {
        const array = [...currentModelValue.value];
        const modelValueIsObject = array.length > 0 && typeof array[0] === "object";
        const defaultValueIsObject = array.length > 0 && typeof props2.defaultValue[0] === "object";
        if ((modelValueIsObject || defaultValueIsObject) && typeof props2.convertValue !== "function") throw new Error("You must provide a `convertValue` function when using objects as values.");
        const payload = props2.convertValue ? props2.convertValue(_payload) : _payload;
        if (array.length >= max2.value && !!max2.value) {
          emits("invalid", payload);
          return false;
        }
        if (props2.duplicate) {
          modelValue.value = [...array, payload];
          emits("addTag", payload);
          return true;
        } else {
          const exist = array.includes(payload);
          if (!exist) {
            modelValue.value = [...array, payload];
            emits("addTag", payload);
            return true;
          } else isInvalidInput.value = true;
        }
        emits("invalid", payload);
        return false;
      },
      onRemoveValue: handleRemoveTag,
      onInputKeydown: (event) => {
        const target = event.target;
        const collection = getItems().map((i) => i.ref).filter((i) => i.dataset.disabled !== "");
        if (!collection.length) return;
        const lastTag = collection.at(-1);
        switch (event.key) {
          case "Delete":
          case "Backspace": {
            if (target.selectionStart !== 0 || target.selectionEnd !== 0) break;
            if (selectedElement.value) {
              const index = collection.findIndex((i) => i === selectedElement.value);
              handleRemoveTag(index);
              selectedElement.value = selectedElement.value === lastTag ? collection.at(index - 1) : collection.at(index + 1);
              event.preventDefault();
            } else if (event.key === "Backspace") {
              selectedElement.value = lastTag;
              event.preventDefault();
            }
            break;
          }
          case "Home":
          case "End":
          case "ArrowRight":
          case "ArrowLeft": {
            const isArrowRight = event.key === "ArrowRight" && dir.value === "ltr" || event.key === "ArrowLeft" && dir.value === "rtl";
            const isArrowLeft = !isArrowRight;
            if (target.selectionStart !== 0 || target.selectionEnd !== 0) break;
            if (isArrowLeft && !selectedElement.value) {
              selectedElement.value = lastTag;
              event.preventDefault();
            } else if (isArrowRight && lastTag && selectedElement.value === lastTag) {
              selectedElement.value = void 0;
              event.preventDefault();
            } else if (selectedElement.value) {
              const el = useArrowNavigation(event, selectedElement.value, void 0, {
                itemsArray: collection,
                loop: false,
                dir: dir.value
              });
              if (el) selectedElement.value = el;
              event.preventDefault();
            }
            break;
          }
          case "ArrowUp":
          case "ArrowDown": {
            if (selectedElement.value) event.preventDefault();
            break;
          }
          default:
            selectedElement.value = void 0;
        }
      },
      selectedElement,
      isInvalidInput,
      addOnPaste,
      addOnBlur,
      addOnTab,
      dir,
      disabled,
      delimiter,
      max: max2,
      id,
      displayValue: props2.displayValue
    });
    return (_ctx, _cache) => {
      return openBlock326(), createBlock317(unref328(CollectionSlot), null, {
        default: withCtx322(() => [createVNode61(unref328(Primitive), {
          ref: unref328(forwardRef),
          dir: unref328(dir),
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-invalid": isInvalidInput.value ? "" : void 0,
          "data-disabled": unref328(disabled) ? "" : void 0,
          "data-focused": unref328(focused) ? "" : void 0
        }, {
          default: withCtx322(() => [renderSlot327(_ctx.$slots, "default", { modelValue: unref328(modelValue) }), unref328(isFormControl) && _ctx.name ? (openBlock326(), createBlock317(unref328(VisuallyHiddenInput_default), {
            key: 0,
            name: _ctx.name,
            value: unref328(modelValue),
            required: _ctx.required,
            disabled: unref328(disabled)
          }, null, 8, [
            "name",
            "value",
            "required",
            "disabled"
          ])) : createCommentVNode37("v-if", true)]),
          _: 3
        }, 8, [
          "dir",
          "as",
          "as-child",
          "data-invalid",
          "data-disabled",
          "data-focused"
        ])]),
        _: 3
      });
    };
  }
});
var TagsInputRoot_default = TagsInputRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TagsInput/TagsInputClear.js
import { createBlock as createBlock318, defineComponent as defineComponent336, mergeProps as mergeProps147, openBlock as openBlock327, renderSlot as renderSlot328, unref as unref329, withCtx as withCtx323 } from "vue";
var TagsInputClear_vue_vue_type_script_setup_true_lang_default = defineComponent336({
  __name: "TagsInputClear",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const context2 = injectTagsInputRootContext();
    function handleCancel() {
      if (context2.disabled.value) return;
      context2.modelValue.value = [];
    }
    return (_ctx, _cache) => {
      return openBlock327(), createBlock318(unref329(Primitive), mergeProps147(props2, {
        type: _ctx.as === "button" ? "button" : void 0,
        "data-disabled": unref329(context2).disabled.value ? "" : void 0,
        onClick: handleCancel
      }), {
        default: withCtx323(() => [renderSlot328(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["type", "data-disabled"]);
    };
  }
});
var TagsInputClear_default = TagsInputClear_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TagsInput/TagsInputInput.js
import { createBlock as createBlock319, defineComponent as defineComponent337, nextTick as nextTick32, onMounted as onMounted51, openBlock as openBlock328, ref as ref106, renderSlot as renderSlot329, unref as unref330, withCtx as withCtx324, withKeys as withKeys23 } from "vue";
var TagsInputInput_vue_vue_type_script_setup_true_lang_default = defineComponent337({
  __name: "TagsInputInput",
  props: {
    placeholder: {
      type: String,
      required: false
    },
    autoFocus: {
      type: Boolean,
      required: false
    },
    maxLength: {
      type: Number,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "input"
    }
  },
  setup(__props) {
    const props2 = __props;
    const context2 = injectTagsInputRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    function handleBlur(event) {
      context2.selectedElement.value = void 0;
      if (!context2.addOnBlur.value) return;
      const target = event.target;
      if (!target.value) return;
      const isAdded = context2.onAddValue(target.value);
      if (isAdded) target.value = "";
    }
    function handleTab(event) {
      if (!context2.addOnTab.value) return;
      handleCustomKeydown(event);
    }
    const isComposing = ref106(false);
    function onCompositionStart() {
      isComposing.value = true;
    }
    function onCompositionEnd() {
      nextTick32(() => {
        isComposing.value = false;
      });
    }
    async function handleCustomKeydown(event) {
      if (isComposing.value) return;
      await nextTick32();
      if (event.defaultPrevented) return;
      const target = event.target;
      if (!target.value) return;
      const isAdded = context2.onAddValue(target.value);
      if (isAdded) target.value = "";
      event.preventDefault();
    }
    function handleInput(event) {
      context2.isInvalidInput.value = false;
      if (event.data === null) return;
      const delimiter = context2.delimiter.value;
      const matchesDelimiter = delimiter === event.data || delimiter instanceof RegExp && delimiter.test(event.data);
      if (matchesDelimiter) {
        const target = event.target;
        target.value = target.value.replace(delimiter, "");
        if (target.value.trim() === "") {
          target.value = "";
          return;
        }
        const isAdded = context2.onAddValue(target.value);
        if (isAdded) target.value = "";
      }
    }
    function handlePaste(event) {
      if (context2.addOnPaste.value) {
        event.preventDefault();
        const clipboardData = event.clipboardData;
        if (!clipboardData) return;
        const value = clipboardData.getData("text");
        if (context2.delimiter.value) {
          const splitValue = value.split(context2.delimiter.value);
          splitValue.forEach((v) => {
            context2.onAddValue(v);
          });
        } else context2.onAddValue(value);
      }
    }
    onMounted51(() => {
      const inputEl = currentElement.value.nodeName === "INPUT" ? currentElement.value : currentElement.value.querySelector("input");
      if (!inputEl) return;
      setTimeout(() => {
        if (props2.autoFocus) inputEl?.focus();
      }, 1);
    });
    return (_ctx, _cache) => {
      return openBlock328(), createBlock319(unref330(Primitive), {
        id: unref330(context2).id?.value,
        ref: unref330(forwardRef),
        type: "text",
        autocomplete: "off",
        autocorrect: "off",
        autocapitalize: "off",
        as: _ctx.as,
        "as-child": _ctx.asChild,
        maxlength: _ctx.maxLength,
        placeholder: _ctx.placeholder,
        disabled: unref330(context2).disabled.value,
        "data-invalid": unref330(context2).isInvalidInput.value ? "" : void 0,
        onInput: handleInput,
        onKeydown: [
          withKeys23(handleCustomKeydown, ["enter"]),
          withKeys23(handleTab, ["tab"]),
          unref330(context2).onInputKeydown
        ],
        onBlur: handleBlur,
        onCompositionstart: onCompositionStart,
        onCompositionend: onCompositionEnd,
        onPaste: handlePaste
      }, {
        default: withCtx324(() => [renderSlot329(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "id",
        "as",
        "as-child",
        "maxlength",
        "placeholder",
        "disabled",
        "data-invalid",
        "onKeydown"
      ]);
    };
  }
});
var TagsInputInput_default = TagsInputInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TagsInput/TagsInputItem.js
import { computed as computed118, createBlock as createBlock320, createVNode as createVNode62, defineComponent as defineComponent338, openBlock as openBlock329, renderSlot as renderSlot330, toRefs as toRefs53, unref as unref331, withCtx as withCtx325 } from "vue";
var [injectTagsInputItemContext, provideTagsInputItemContext] = createContext("TagsInputItem");
var TagsInputItem_vue_vue_type_script_setup_true_lang_default = defineComponent338({
  __name: "TagsInputItem",
  props: {
    value: {
      type: [String, Object],
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { value } = toRefs53(props2);
    const context2 = injectTagsInputRootContext();
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const isSelected = computed118(() => context2.selectedElement.value === currentElement.value);
    const disabled = computed118(() => props2.disabled || context2.disabled.value);
    const itemContext = provideTagsInputItemContext({
      value,
      isSelected,
      disabled,
      textId: "",
      displayValue: computed118(() => context2.displayValue(value.value))
    });
    return (_ctx, _cache) => {
      return openBlock329(), createBlock320(unref331(CollectionItem), { value: unref331(value) }, {
        default: withCtx325(() => [createVNode62(unref331(Primitive), {
          ref: unref331(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "aria-labelledby": unref331(itemContext).textId,
          "aria-current": isSelected.value,
          "data-disabled": disabled.value ? "" : void 0,
          "data-state": isSelected.value ? "active" : "inactive"
        }, {
          default: withCtx325(() => [renderSlot330(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "aria-labelledby",
          "aria-current",
          "data-disabled",
          "data-state"
        ])]),
        _: 3
      }, 8, ["value"]);
    };
  }
});
var TagsInputItem_default = TagsInputItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TagsInput/TagsInputItemDelete.js
import { computed as computed119, createBlock as createBlock321, defineComponent as defineComponent339, mergeProps as mergeProps148, openBlock as openBlock330, renderSlot as renderSlot331, unref as unref332, withCtx as withCtx326 } from "vue";
var TagsInputItemDelete_vue_vue_type_script_setup_true_lang_default = defineComponent339({
  __name: "TagsInputItemDelete",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    const context2 = injectTagsInputRootContext();
    const itemContext = injectTagsInputItemContext();
    const disabled = computed119(() => itemContext.disabled?.value || context2.disabled.value);
    function handleDelete() {
      if (disabled.value) return;
      const index = context2.modelValue.value.findIndex((i) => isEqual(i, itemContext.value.value));
      context2.onRemoveValue(index);
    }
    return (_ctx, _cache) => {
      return openBlock330(), createBlock321(unref332(Primitive), mergeProps148({ tabindex: "-1" }, props2, {
        "aria-labelledby": unref332(itemContext).textId,
        "aria-current": unref332(itemContext).isSelected.value,
        "data-state": unref332(itemContext).isSelected.value ? "active" : "inactive",
        "data-disabled": disabled.value ? "" : void 0,
        type: _ctx.as === "button" ? "button" : void 0,
        onClick: handleDelete
      }), {
        default: withCtx326(() => [renderSlot331(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "aria-labelledby",
        "aria-current",
        "data-state",
        "data-disabled",
        "type"
      ]);
    };
  }
});
var TagsInputItemDelete_default = TagsInputItemDelete_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TagsInput/TagsInputItemText.js
import { createBlock as createBlock322, createTextVNode as createTextVNode29, defineComponent as defineComponent340, mergeProps as mergeProps149, openBlock as openBlock331, renderSlot as renderSlot332, toDisplayString as toDisplayString15, unref as unref333, withCtx as withCtx327 } from "vue";
var TagsInputItemText_vue_vue_type_script_setup_true_lang_default = defineComponent340({
  __name: "TagsInputItemText",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    const props2 = __props;
    const itemContext = injectTagsInputItemContext();
    useForwardExpose();
    itemContext.textId ||= useId2(void 0, "reka-tags-input-item-text");
    return (_ctx, _cache) => {
      return openBlock331(), createBlock322(unref333(Primitive), mergeProps149(props2, { id: unref333(itemContext).textId }), {
        default: withCtx327(() => [renderSlot332(_ctx.$slots, "default", {}, () => [createTextVNode29(toDisplayString15(unref333(itemContext).displayValue.value), 1)])]),
        _: 3
      }, 16, ["id"]);
    };
  }
});
var TagsInputItemText_default = TagsInputItemText_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TimeField/TimeFieldRoot.js
import { computed as computed120, createBlock as createBlock323, createVNode as createVNode63, defineComponent as defineComponent341, mergeProps as mergeProps150, nextTick as nextTick33, onMounted as onMounted52, openBlock as openBlock332, ref as ref107, renderSlot as renderSlot333, toRefs as toRefs54, unref as unref334, watch as watch43, withCtx as withCtx328, withKeys as withKeys24 } from "vue";
var [injectTimeFieldRootContext, provideTimeFieldRootContext] = createContext("TimeFieldRoot");
function convertValue(value, date = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3($14e0f24ef4ac5c92$export$aa8b41735afcabd2())) {
  if (value && "day" in value) return value;
  return $11d87f3f76e88657$export$b21e0b124e224484(date, value);
}
var TimeFieldRoot_vue_vue_type_script_setup_true_lang_default = defineComponent341({
  inheritAttrs: false,
  __name: "TimeFieldRoot",
  props: {
    defaultValue: {
      type: Object,
      required: false,
      default: void 0
    },
    defaultPlaceholder: {
      type: Object,
      required: false
    },
    placeholder: {
      type: Object,
      required: false,
      default: void 0
    },
    modelValue: {
      type: [Object, null],
      required: false
    },
    hourCycle: {
      type: null,
      required: false
    },
    step: {
      type: Object,
      required: false
    },
    granularity: {
      type: String,
      required: false
    },
    hideTimeZone: {
      type: Boolean,
      required: false
    },
    maxValue: {
      type: Object,
      required: false
    },
    minValue: {
      type: Object,
      required: false
    },
    locale: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    readonly: {
      type: Boolean,
      required: false,
      default: false
    },
    id: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { disabled, readonly: readonly3, granularity, defaultValue, minValue, maxValue, dir: propDir, locale: propLocale } = toRefs54(props2);
    const locale = useLocale(propLocale);
    const dir = useDirection(propDir);
    const formatter = useDateFormatter(locale.value, { hourCycle: normalizeHourCycle(props2.hourCycle) });
    const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
    const segmentElements = ref107(/* @__PURE__ */ new Set());
    const step = computed120(() => normalizeDateStep(props2));
    const convertedMinValue = computed120(() => minValue.value ? convertValue(minValue.value) : void 0);
    const convertedMaxValue = computed120(() => maxValue.value ? convertValue(maxValue.value) : void 0);
    onMounted52(() => {
      getTimeFieldSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
    });
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: defaultValue.value,
      passive: props2.modelValue === void 0
    });
    const convertedModelValue = computed120({
      get() {
        if (isNullish(modelValue.value)) return modelValue.value;
        return convertValue(modelValue.value);
      },
      set(newValue) {
        if (newValue) modelValue.value = modelValue.value && "day" in modelValue.value ? newValue : new $35ea8db9cb2ccb90$export$680ea196effce5f(newValue.hour, newValue.minute, newValue.second, modelValue.value?.millisecond);
        else modelValue.value = newValue;
        return newValue;
      }
    });
    const defaultDate = getDefaultTime({
      defaultPlaceholder: props2.placeholder,
      defaultValue: modelValue.value
    });
    const placeholder = useVModel(props2, "placeholder", emits, {
      defaultValue: props2.defaultPlaceholder ?? defaultDate.copy(),
      passive: props2.placeholder === void 0
    });
    const convertedPlaceholder = computed120({
      get() {
        return convertValue(placeholder.value);
      },
      set(newValue) {
        if (newValue) placeholder.value = "day" in placeholder.value ? newValue.copy() : new $35ea8db9cb2ccb90$export$680ea196effce5f(newValue.hour, newValue.minute, newValue.second, placeholder.value?.millisecond);
        return newValue;
      }
    });
    const inferredGranularity = computed120(() => {
      if (granularity.value) return granularity.value;
      return "minute";
    });
    const isInvalid = computed120(() => {
      if (!modelValue.value) return false;
      if (convertedMinValue.value && isBefore(convertedModelValue.value, convertedMinValue.value)) return true;
      if (convertedMaxValue.value && isBefore(convertedMaxValue.value, convertedModelValue.value)) return true;
      return false;
    });
    const initialSegments = initializeTimeSegmentValues(inferredGranularity.value);
    const segmentValues = ref107(modelValue.value ? { ...syncTimeSegmentValues({
      value: convertedModelValue.value,
      formatter
    }) } : { ...initialSegments });
    const allSegmentContent = computed120(() => createContent({
      granularity: inferredGranularity.value,
      dateRef: convertedPlaceholder.value,
      formatter,
      hideTimeZone: props2.hideTimeZone,
      hourCycle: props2.hourCycle,
      segmentValues: segmentValues.value,
      locale,
      isTimeValue: true
    }));
    const segmentContents = computed120(() => allSegmentContent.value.arr);
    const editableSegmentContents = computed120(() => segmentContents.value.filter(({ part }) => part !== "literal"));
    watch43(locale, (value) => {
      if (formatter.getLocale() !== value) {
        formatter.setLocale(value);
        nextTick33(() => {
          segmentElements.value.clear();
          getTimeFieldSegmentElements(parentElement.value).forEach((item) => segmentElements.value.add(item));
        });
      }
    });
    watch43(convertedModelValue, (_modelValue) => {
      if (!isNullish(_modelValue) && (!$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(convertedPlaceholder.value, _modelValue) || convertedPlaceholder.value.compare(_modelValue) !== 0)) placeholder.value = _modelValue.copy();
    });
    watch43([convertedModelValue, locale], ([_modelValue]) => {
      if (!isNullish(_modelValue)) segmentValues.value = { ...syncTimeSegmentValues({
        value: _modelValue,
        formatter
      }) };
      else if (Object.values(segmentValues.value).every((value) => value !== null) && isNullish(_modelValue)) segmentValues.value = { ...initialSegments };
    });
    const currentFocusedElement = ref107(null);
    const currentSegmentIndex = computed120(() => Array.from(segmentElements.value).findIndex((el) => el.getAttribute("data-reka-time-field-segment") === currentFocusedElement.value?.getAttribute("data-reka-time-field-segment")));
    const nextFocusableSegment = computed120(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const nextCondition = sign < 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (nextCondition) return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value + sign];
      return segmentToFocus;
    });
    const prevFocusableSegment = computed120(() => {
      const sign = dir.value === "rtl" ? -1 : 1;
      const prevCondition = sign > 0 ? currentSegmentIndex.value < 0 : currentSegmentIndex.value > segmentElements.value.size - 1;
      if (prevCondition) return null;
      const segmentToFocus = Array.from(segmentElements.value)[currentSegmentIndex.value - sign];
      return segmentToFocus;
    });
    const kbd = useKbd();
    function handleKeydown(e) {
      if (!isSegmentNavigationKey(e.key)) return;
      if (e.key === kbd.ARROW_LEFT) prevFocusableSegment.value?.focus();
      if (e.key === kbd.ARROW_RIGHT) nextFocusableSegment.value?.focus();
    }
    function setFocusedElement(el) {
      currentFocusedElement.value = el;
    }
    provideTimeFieldRootContext({
      locale,
      modelValue: convertedModelValue,
      placeholder: convertedPlaceholder,
      disabled,
      formatter,
      hourCycle: props2.hourCycle,
      step,
      readonly: readonly3,
      segmentValues,
      isInvalid,
      segmentContents: editableSegmentContents,
      elements: segmentElements,
      setFocusedElement,
      focusNext() {
        nextFocusableSegment.value?.focus();
      }
    });
    __expose({ setFocusedElement });
    return (_ctx, _cache) => {
      return openBlock332(), createBlock323(unref334(Primitive), mergeProps150(_ctx.$attrs, {
        ref_key: "primitiveElement",
        ref: primitiveElement,
        role: "group",
        "aria-disabled": unref334(disabled) ? true : void 0,
        "data-disabled": unref334(disabled) ? "" : void 0,
        "data-readonly": unref334(readonly3) ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        dir: unref334(dir),
        onKeydown: withKeys24(handleKeydown, ["left", "right"])
      }), {
        default: withCtx328(() => [renderSlot333(_ctx.$slots, "default", {
          modelValue: unref334(modelValue),
          segments: segmentContents.value,
          isInvalid: isInvalid.value
        }), createVNode63(unref334(VisuallyHidden_default), {
          id: _ctx.id,
          as: "input",
          feature: "focusable",
          tabindex: "-1",
          value: unref334(modelValue) ? unref334(modelValue).toString() : "",
          name: _ctx.name,
          disabled: unref334(disabled),
          required: _ctx.required,
          onFocus: _cache[0] || (_cache[0] = ($event) => Array.from(segmentElements.value)?.[0]?.focus())
        }, null, 8, [
          "id",
          "value",
          "name",
          "disabled",
          "required"
        ])]),
        _: 3
      }, 16, [
        "aria-disabled",
        "data-disabled",
        "data-readonly",
        "data-invalid",
        "dir"
      ]);
    };
  }
});
var TimeFieldRoot_default = TimeFieldRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/TimeField/TimeFieldInput.js
import { computed as computed121, createBlock as createBlock324, defineComponent as defineComponent342, mergeProps as mergeProps151, openBlock as openBlock333, ref as ref108, renderSlot as renderSlot334, toHandlers as toHandlers3, unref as unref335, withCtx as withCtx329 } from "vue";
var TimeFieldInput_vue_vue_type_script_setup_true_lang_default = defineComponent342({
  __name: "TimeFieldInput",
  props: {
    part: {
      type: null,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectTimeFieldRootContext();
    const hasLeftFocus = ref108(true);
    const lastKeyZero = ref108(false);
    const { handleSegmentClick, handleSegmentKeydown, attributes } = useDateField({
      hasLeftFocus,
      lastKeyZero,
      placeholder: rootContext.placeholder,
      hourCycle: rootContext.hourCycle,
      step: rootContext.step,
      segmentValues: rootContext.segmentValues,
      formatter: rootContext.formatter,
      part: props2.part,
      disabled: rootContext.disabled,
      readonly: rootContext.readonly,
      focusNext: rootContext.focusNext,
      modelValue: rootContext.modelValue
    });
    const disabled = computed121(() => rootContext.disabled.value);
    const readonly3 = computed121(() => rootContext.readonly.value);
    const isInvalid = computed121(() => rootContext.isInvalid.value);
    return (_ctx, _cache) => {
      return openBlock333(), createBlock324(unref335(Primitive), mergeProps151({
        as: _ctx.as,
        "as-child": _ctx.asChild
      }, unref335(attributes), {
        contenteditable: disabled.value || readonly3.value ? false : _ctx.part !== "literal",
        "data-reka-time-field-segment": _ctx.part,
        "aria-disabled": disabled.value ? true : void 0,
        "aria-readonly": readonly3.value ? true : void 0,
        "data-disabled": disabled.value ? "" : void 0,
        "data-invalid": isInvalid.value ? "" : void 0,
        "aria-invalid": isInvalid.value ? true : void 0
      }, toHandlers3(_ctx.part !== "literal" ? {
        mousedown: unref335(handleSegmentClick),
        keydown: unref335(handleSegmentKeydown),
        focusout: () => {
          hasLeftFocus.value = true;
        },
        focusin: (e) => {
          unref335(rootContext).setFocusedElement(e.target);
        }
      } : {})), {
        default: withCtx329(() => [renderSlot334(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "as",
        "as-child",
        "contenteditable",
        "data-reka-time-field-segment",
        "aria-disabled",
        "aria-readonly",
        "data-disabled",
        "data-invalid",
        "aria-invalid"
      ]);
    };
  }
});
var TimeFieldInput_default = TimeFieldInput_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastAnnounceExclude.js
import { createBlock as createBlock325, defineComponent as defineComponent343, openBlock as openBlock334, renderSlot as renderSlot335, unref as unref336, withCtx as withCtx330 } from "vue";
var ToastAnnounceExclude_vue_vue_type_script_setup_true_lang_default = defineComponent343({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock334(), createBlock325(unref336(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-reka-toast-announce-exclude": "",
        "data-reka-toast-announce-alt": _ctx.altText || void 0
      }, {
        default: withCtx330(() => [renderSlot335(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-reka-toast-announce-alt"
      ]);
    };
  }
});
var ToastAnnounceExclude_default = ToastAnnounceExclude_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastProvider.js
import { defineComponent as defineComponent344, ref as ref109, renderSlot as renderSlot336, toRefs as toRefs55 } from "vue";
var [injectToastProviderContext, provideToastProviderContext] = createContext("ToastProvider");
var ToastProvider_vue_vue_type_script_setup_true_lang_default = defineComponent344({
  inheritAttrs: false,
  __name: "ToastProvider",
  props: {
    label: {
      type: String,
      required: false,
      default: "Notification"
    },
    duration: {
      type: Number,
      required: false,
      default: 5e3
    },
    swipeDirection: {
      type: String,
      required: false,
      default: "right"
    },
    swipeThreshold: {
      type: Number,
      required: false,
      default: 50
    }
  },
  setup(__props) {
    const props2 = __props;
    const { label, duration, swipeDirection, swipeThreshold } = toRefs55(props2);
    useCollection({ isProvider: true });
    const viewport = ref109();
    const toastCount = ref109(0);
    const isFocusedToastEscapeKeyDownRef = ref109(false);
    const isClosePausedRef = ref109(false);
    if (props2.label && typeof props2.label === "string" && !props2.label.trim()) {
      const error = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(error);
    }
    provideToastProviderContext({
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange(el) {
        viewport.value = el;
      },
      onToastAdd() {
        toastCount.value++;
      },
      onToastRemove() {
        toastCount.value--;
      },
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef
    });
    return (_ctx, _cache) => {
      return renderSlot336(_ctx.$slots, "default");
    };
  }
});
var ToastProvider_default = ToastProvider_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastAnnounce.js
import { createBlock as createBlock326, createCommentVNode as createCommentVNode38, createTextVNode as createTextVNode30, defineComponent as defineComponent345, openBlock as openBlock335, ref as ref110, renderSlot as renderSlot337, toDisplayString as toDisplayString16, unref as unref337, withCtx as withCtx331 } from "vue";
var ToastAnnounce_vue_vue_type_script_setup_true_lang_default = defineComponent345({
  __name: "ToastAnnounce",
  setup(__props) {
    const providerContext = injectToastProviderContext();
    const isAnnounced = useTimeout(1e3);
    const renderAnnounceText = ref110(false);
    useRafFn(() => {
      renderAnnounceText.value = true;
    });
    return (_ctx, _cache) => {
      return unref337(isAnnounced) || renderAnnounceText.value ? (openBlock335(), createBlock326(unref337(VisuallyHidden_default), { key: 0 }, {
        default: withCtx331(() => [createTextVNode30(toDisplayString16(unref337(providerContext).label.value) + " ", 1), renderSlot337(_ctx.$slots, "default")]),
        _: 3
      })) : createCommentVNode38("v-if", true);
    };
  }
});
var ToastAnnounce_default = ToastAnnounce_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/utils.js
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
function handleAndDispatchCustomEvent2(name, handler, detail) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler) currentTarget.addEventListener(name, handler, { once: true });
  currentTarget.dispatchEvent(event);
}
function isDeltaInDirection(delta, direction, threshold = 0) {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") return isDeltaX && deltaX > threshold;
  else return !isDeltaX && deltaY > threshold;
}
function isHTMLElement2(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement2(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.rekaToastAnnounceExclude === "";
      if (!isHidden2) if (isExcluded) {
        const altText = node.dataset.rekaToastAnnounceAlt;
        if (altText) textContent.push(altText);
      } else textContent.push(...getAnnounceTextContent(node));
    }
  });
  return textContent;
}

// node_modules/reka-ui/dist/Toast/ToastRootImpl.js
import { Fragment as Fragment11, Teleport as Teleport5, computed as computed122, createBlock as createBlock327, createCommentVNode as createCommentVNode39, createElementBlock as createElementBlock15, createTextVNode as createTextVNode31, createVNode as createVNode64, defineComponent as defineComponent346, mergeProps as mergeProps152, onMounted as onMounted53, onUnmounted as onUnmounted24, openBlock as openBlock336, ref as ref111, renderSlot as renderSlot338, toDisplayString as toDisplayString17, unref as unref338, watch as watch44, watchEffect as watchEffect27, withCtx as withCtx332, withModifiers as withModifiers23 } from "vue";
var [injectToastRootContext, provideToastRootContext] = createContext("ToastRoot");
var ToastRootImpl_vue_vue_type_script_setup_true_lang_default = defineComponent346({
  inheritAttrs: false,
  __name: "ToastRootImpl",
  props: {
    type: {
      type: String,
      required: false
    },
    open: {
      type: Boolean,
      required: false,
      default: false
    },
    duration: {
      type: Number,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "li"
    }
  },
  emits: [
    "close",
    "escapeKeyDown",
    "pause",
    "resume",
    "swipeStart",
    "swipeMove",
    "swipeCancel",
    "swipeEnd"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const providerContext = injectToastProviderContext();
    const pointerStartRef = ref111(null);
    const swipeDeltaRef = ref111(null);
    const duration = computed122(() => typeof props2.duration === "number" ? props2.duration : providerContext.duration.value);
    const closeTimerStartTimeRef = ref111(0);
    const closeTimerRemainingTimeRef = ref111(duration.value);
    const closeTimerRef = ref111(0);
    const remainingTime = ref111(duration.value);
    const remainingRaf = useRafFn(() => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
      remainingTime.value = Math.max(closeTimerRemainingTimeRef.value - elapsedTime, 0);
    }, { fpsLimit: 60 });
    function startTimer(duration$1) {
      if (duration$1 <= 0 || duration$1 === Number.POSITIVE_INFINITY) return;
      if (!isClient) return;
      window.clearTimeout(closeTimerRef.value);
      closeTimerStartTimeRef.value = (/* @__PURE__ */ new Date()).getTime();
      closeTimerRef.value = window.setTimeout(handleClose, duration$1);
    }
    function handleClose(event) {
      const isNonPointerEvent = event?.pointerType === "";
      const isFocusInToast = currentElement.value?.contains(getActiveElement());
      if (isFocusInToast && isNonPointerEvent) providerContext.viewport.value?.focus();
      if (isNonPointerEvent) providerContext.isClosePausedRef.value = false;
      emits("close");
    }
    const announceTextContent = computed122(() => currentElement.value ? getAnnounceTextContent(currentElement.value) : null);
    if (props2.type && !["foreground", "background"].includes(props2.type)) {
      const error = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(error);
    }
    watchEffect27((cleanupFn) => {
      const viewport = providerContext.viewport.value;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.value);
          remainingRaf.resume();
          emits("resume");
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
          closeTimerRemainingTimeRef.value = closeTimerRemainingTimeRef.value - elapsedTime;
          window.clearTimeout(closeTimerRef.value);
          remainingRaf.pause();
          emits("pause");
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    });
    watch44(() => [props2.open, duration.value], () => {
      closeTimerRemainingTimeRef.value = duration.value;
      if (props2.open && !providerContext.isClosePausedRef.value) startTimer(duration.value);
    }, { immediate: true });
    onKeyStroke("Escape", (event) => {
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented) {
        providerContext.isFocusedToastEscapeKeyDownRef.value = true;
        handleClose();
      }
    });
    onMounted53(() => {
      providerContext.onToastAdd();
    });
    onUnmounted24(() => {
      providerContext.onToastRemove();
    });
    provideToastRootContext({ onClose: handleClose });
    return (_ctx, _cache) => {
      return openBlock336(), createElementBlock15(Fragment11, null, [announceTextContent.value ? (openBlock336(), createBlock327(ToastAnnounce_default, {
        key: 0,
        role: "alert",
        "aria-live": _ctx.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": "true"
      }, {
        default: withCtx332(() => [createTextVNode31(toDisplayString17(announceTextContent.value), 1)]),
        _: 1
      }, 8, ["aria-live"])) : createCommentVNode39("v-if", true), unref338(providerContext).viewport.value ? (openBlock336(), createBlock327(Teleport5, {
        key: 1,
        to: unref338(providerContext).viewport.value
      }, [createVNode64(unref338(CollectionItem), null, {
        default: withCtx332(() => [createVNode64(unref338(Primitive), mergeProps152({
          ref: unref338(forwardRef),
          role: "alert",
          "aria-live": "off",
          "aria-atomic": "true",
          tabindex: "0"
        }, _ctx.$attrs, {
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-state": _ctx.open ? "open" : "closed",
          "data-swipe-direction": unref338(providerContext).swipeDirection.value,
          style: {
            userSelect: "none",
            touchAction: "none"
          },
          onPointerdown: _cache[0] || (_cache[0] = withModifiers23((event) => {
            pointerStartRef.value = {
              x: event.clientX,
              y: event.clientY
            };
          }, ["left"])),
          onPointermove: _cache[1] || (_cache[1] = (event) => {
            if (!pointerStartRef.value) return;
            const x = event.clientX - pointerStartRef.value.x;
            const y = event.clientY - pointerStartRef.value.y;
            const hasSwipeMoveStarted = Boolean(swipeDeltaRef.value);
            const isHorizontalSwipe = ["left", "right"].includes(unref338(providerContext).swipeDirection.value);
            const clamp4 = ["left", "up"].includes(unref338(providerContext).swipeDirection.value) ? Math.min : Math.max;
            const clampedX = isHorizontalSwipe ? clamp4(0, x) : 0;
            const clampedY = !isHorizontalSwipe ? clamp4(0, y) : 0;
            const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
            const delta = {
              x: clampedX,
              y: clampedY
            };
            const eventDetail = {
              originalEvent: event,
              delta
            };
            if (hasSwipeMoveStarted) {
              swipeDeltaRef.value = delta;
              unref338(handleAndDispatchCustomEvent2)(unref338(TOAST_SWIPE_MOVE), (ev) => emits("swipeMove", ev), eventDetail);
            } else if (unref338(isDeltaInDirection)(delta, unref338(providerContext).swipeDirection.value, moveStartBuffer)) {
              swipeDeltaRef.value = delta;
              unref338(handleAndDispatchCustomEvent2)(unref338(TOAST_SWIPE_START), (ev) => emits("swipeStart", ev), eventDetail);
              event.target.setPointerCapture(event.pointerId);
            } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) pointerStartRef.value = null;
          }),
          onPointerup: _cache[2] || (_cache[2] = (event) => {
            const delta = swipeDeltaRef.value;
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) target.releasePointerCapture(event.pointerId);
            swipeDeltaRef.value = null;
            pointerStartRef.value = null;
            if (delta) {
              const toast = event.currentTarget;
              const eventDetail = {
                originalEvent: event,
                delta
              };
              if (unref338(isDeltaInDirection)(delta, unref338(providerContext).swipeDirection.value, unref338(providerContext).swipeThreshold.value)) unref338(handleAndDispatchCustomEvent2)(unref338(TOAST_SWIPE_END), (ev) => emits("swipeEnd", ev), eventDetail);
              else unref338(handleAndDispatchCustomEvent2)(unref338(TOAST_SWIPE_CANCEL), (ev) => emits("swipeCancel", ev), eventDetail);
              toast?.addEventListener("click", (event$1) => event$1.preventDefault(), { once: true });
            }
          })
        }), {
          default: withCtx332(() => [renderSlot338(_ctx.$slots, "default", {
            remaining: remainingTime.value,
            duration: duration.value
          })]),
          _: 3
        }, 16, [
          "as",
          "as-child",
          "data-state",
          "data-swipe-direction"
        ])]),
        _: 3
      })], 8, ["to"])) : createCommentVNode39("v-if", true)], 64);
    };
  }
});
var ToastRootImpl_default = ToastRootImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastClose.js
import { createBlock as createBlock328, createVNode as createVNode65, defineComponent as defineComponent347, mergeProps as mergeProps153, openBlock as openBlock337, renderSlot as renderSlot339, unref as unref339, withCtx as withCtx333 } from "vue";
var ToastClose_vue_vue_type_script_setup_true_lang_default = defineComponent347({
  __name: "ToastClose",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectToastRootContext();
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock337(), createBlock328(ToastAnnounceExclude_default, { "as-child": "" }, {
        default: withCtx333(() => [createVNode65(unref339(Primitive), mergeProps153(props2, {
          ref: unref339(forwardRef),
          type: _ctx.as === "button" ? "button" : void 0,
          onClick: unref339(rootContext).onClose
        }), {
          default: withCtx333(() => [renderSlot339(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["type", "onClick"])]),
        _: 3
      });
    };
  }
});
var ToastClose_default = ToastClose_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastAction.js
import { createBlock as createBlock329, createCommentVNode as createCommentVNode40, createVNode as createVNode66, defineComponent as defineComponent348, openBlock as openBlock338, renderSlot as renderSlot340, unref as unref340, withCtx as withCtx334 } from "vue";
var ToastAction_vue_vue_type_script_setup_true_lang_default = defineComponent348({
  __name: "ToastAction",
  props: {
    altText: {
      type: String,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    if (!props2.altText) throw new Error("Missing prop `altText` expected on `ToastAction`");
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return _ctx.altText ? (openBlock338(), createBlock329(ToastAnnounceExclude_default, {
        key: 0,
        "alt-text": _ctx.altText,
        "as-child": ""
      }, {
        default: withCtx334(() => [createVNode66(ToastClose_default, {
          ref: unref340(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild
        }, {
          default: withCtx334(() => [renderSlot340(_ctx.$slots, "default")]),
          _: 3
        }, 8, ["as", "as-child"])]),
        _: 3
      }, 8, ["alt-text"])) : createCommentVNode40("v-if", true);
    };
  }
});
var ToastAction_default = ToastAction_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastDescription.js
import { createBlock as createBlock330, defineComponent as defineComponent349, guardReactiveProps as guardReactiveProps103, normalizeProps as normalizeProps103, openBlock as openBlock339, renderSlot as renderSlot341, unref as unref341, withCtx as withCtx335 } from "vue";
var ToastDescription_vue_vue_type_script_setup_true_lang_default = defineComponent349({
  __name: "ToastDescription",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock339(), createBlock330(unref341(Primitive), normalizeProps103(guardReactiveProps103(props2)), {
        default: withCtx335(() => [renderSlot341(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ToastDescription_default = ToastDescription_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastPortal.js
import { createBlock as createBlock331, defineComponent as defineComponent350, guardReactiveProps as guardReactiveProps104, normalizeProps as normalizeProps104, openBlock as openBlock340, renderSlot as renderSlot342, unref as unref342, withCtx as withCtx336 } from "vue";
var ToastPortal_vue_vue_type_script_setup_true_lang_default = defineComponent350({
  __name: "ToastPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock340(), createBlock331(unref342(Teleport_default), normalizeProps104(guardReactiveProps104(props2)), {
        default: withCtx336(() => [renderSlot342(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ToastPortal_default = ToastPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastRoot.js
import { createBlock as createBlock332, createVNode as createVNode67, defineComponent as defineComponent351, mergeProps as mergeProps154, openBlock as openBlock341, renderSlot as renderSlot343, unref as unref343, withCtx as withCtx337 } from "vue";
var ToastRoot_vue_vue_type_script_setup_true_lang_default = defineComponent351({
  __name: "ToastRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false,
      default: true
    },
    forceMount: {
      type: Boolean,
      required: false
    },
    type: {
      type: String,
      required: false,
      default: "foreground"
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    duration: {
      type: Number,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "li"
    }
  },
  emits: [
    "escapeKeyDown",
    "pause",
    "resume",
    "swipeStart",
    "swipeMove",
    "swipeCancel",
    "swipeEnd",
    "update:open"
  ],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef } = useForwardExpose();
    const open = useVModel(props2, "open", emits, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    return (_ctx, _cache) => {
      return openBlock341(), createBlock332(unref343(Presence_default), { present: _ctx.forceMount || unref343(open) }, {
        default: withCtx337(() => [createVNode67(ToastRootImpl_default, mergeProps154({
          ref: unref343(forwardRef),
          open: unref343(open),
          type: _ctx.type,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          duration: _ctx.duration
        }, _ctx.$attrs, {
          onClose: _cache[0] || (_cache[0] = ($event) => open.value = false),
          onPause: _cache[1] || (_cache[1] = ($event) => emits("pause")),
          onResume: _cache[2] || (_cache[2] = ($event) => emits("resume")),
          onEscapeKeyDown: _cache[3] || (_cache[3] = ($event) => emits("escapeKeyDown", $event)),
          onSwipeStart: _cache[4] || (_cache[4] = (event) => {
            emits("swipeStart", event);
            if (!event.defaultPrevented) event.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: _cache[5] || (_cache[5] = (event) => {
            emits("swipeMove", event);
            if (!event.defaultPrevented) {
              const { x, y } = event.detail.delta;
              const target = event.currentTarget;
              target.setAttribute("data-swipe", "move");
              target.style.setProperty("--reka-toast-swipe-move-x", `${x}px`);
              target.style.setProperty("--reka-toast-swipe-move-y", `${y}px`);
            }
          }),
          onSwipeCancel: _cache[6] || (_cache[6] = (event) => {
            emits("swipeCancel", event);
            if (!event.defaultPrevented) {
              const target = event.currentTarget;
              target.setAttribute("data-swipe", "cancel");
              target.style.removeProperty("--reka-toast-swipe-move-x");
              target.style.removeProperty("--reka-toast-swipe-move-y");
              target.style.removeProperty("--reka-toast-swipe-end-x");
              target.style.removeProperty("--reka-toast-swipe-end-y");
            }
          }),
          onSwipeEnd: _cache[7] || (_cache[7] = (event) => {
            emits("swipeEnd", event);
            if (!event.defaultPrevented) {
              const { x, y } = event.detail.delta;
              const target = event.currentTarget;
              target.setAttribute("data-swipe", "end");
              target.style.removeProperty("--reka-toast-swipe-move-x");
              target.style.removeProperty("--reka-toast-swipe-move-y");
              target.style.setProperty("--reka-toast-swipe-end-x", `${x}px`);
              target.style.setProperty("--reka-toast-swipe-end-y", `${y}px`);
              open.value = false;
            }
          })
        }), {
          default: withCtx337(({ remaining, duration: _duration }) => [renderSlot343(_ctx.$slots, "default", {
            remaining,
            duration: _duration,
            open: unref343(open)
          })]),
          _: 3
        }, 16, [
          "open",
          "type",
          "as",
          "as-child",
          "duration"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var ToastRoot_default = ToastRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastTitle.js
import { createBlock as createBlock333, defineComponent as defineComponent352, guardReactiveProps as guardReactiveProps105, normalizeProps as normalizeProps105, openBlock as openBlock342, renderSlot as renderSlot344, unref as unref344, withCtx as withCtx338 } from "vue";
var ToastTitle_vue_vue_type_script_setup_true_lang_default = defineComponent352({
  __name: "ToastTitle",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock342(), createBlock333(unref344(Primitive), normalizeProps105(guardReactiveProps105(props2)), {
        default: withCtx338(() => [renderSlot344(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ToastTitle_default = ToastTitle_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/FocusProxy.js
import { createBlock as createBlock334, defineComponent as defineComponent353, openBlock as openBlock343, renderSlot as renderSlot345, unref as unref345, withCtx as withCtx339 } from "vue";
var FocusProxy_vue_vue_type_script_setup_true_lang_default = defineComponent353({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const providerContext = injectToastProviderContext();
    return (_ctx, _cache) => {
      return openBlock343(), createBlock334(unref345(VisuallyHidden_default), {
        "aria-hidden": "true",
        tabindex: "0",
        style: { "position": "fixed" },
        onFocus: _cache[0] || (_cache[0] = (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !unref345(providerContext).viewport.value?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) emits("focusFromOutsideViewport");
        })
      }, {
        default: withCtx339(() => [renderSlot345(_ctx.$slots, "default")]),
        _: 3
      });
    };
  }
});
var FocusProxy_default = FocusProxy_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toast/ToastViewport.js
import { computed as computed123, createBlock as createBlock335, createCommentVNode as createCommentVNode41, createVNode as createVNode68, defineComponent as defineComponent354, mergeProps as mergeProps155, normalizeStyle as normalizeStyle17, onMounted as onMounted54, openBlock as openBlock344, ref as ref112, renderSlot as renderSlot346, toRefs as toRefs56, unref as unref346, watchEffect as watchEffect28, withCtx as withCtx340 } from "vue";
var ToastViewport_vue_vue_type_script_setup_true_lang_default = defineComponent354({
  inheritAttrs: false,
  __name: "ToastViewport",
  props: {
    hotkey: {
      type: Array,
      required: false,
      default: () => ["F8"]
    },
    label: {
      type: [String, Function],
      required: false,
      default: "Notifications ({hotkey})"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "ol"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { hotkey, label } = toRefs56(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionSlot, getItems } = useCollection();
    const providerContext = injectToastProviderContext();
    const hasToasts = computed123(() => providerContext.toastCount.value > 0);
    const headFocusProxyRef = ref112();
    const tailFocusProxyRef = ref112();
    const hotkeyMessage = computed123(() => hotkey.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    onKeyStroke(hotkey.value, () => {
      currentElement.value.focus();
    });
    onMounted54(() => {
      providerContext.onViewportChange(currentElement.value);
    });
    watchEffect28((cleanupFn) => {
      const viewport = currentElement.value;
      if (hasToasts.value && viewport) {
        const handlePause = () => {
          if (!providerContext.isClosePausedRef.value) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            providerContext.isClosePausedRef.value = true;
          }
        };
        const handleResume = () => {
          if (providerContext.isClosePausedRef.value) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            providerContext.isClosePausedRef.value = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !viewport.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = viewport.contains(getActiveElement());
          if (!isFocusInside) handleResume();
        };
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = getActiveElement();
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.value?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index + 1))) event.preventDefault();
            else isTabbingBackwards ? headFocusProxyRef.value?.focus() : tailFocusProxyRef.value?.focus();
          }
        };
        viewport.addEventListener("focusin", handlePause);
        viewport.addEventListener("focusout", handleFocusOutResume);
        viewport.addEventListener("pointermove", handlePause);
        viewport.addEventListener("pointerleave", handlePointerLeaveResume);
        viewport.addEventListener("keydown", handleKeyDown);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        cleanupFn(() => {
          viewport.removeEventListener("focusin", handlePause);
          viewport.removeEventListener("focusout", handleFocusOutResume);
          viewport.removeEventListener("pointermove", handlePause);
          viewport.removeEventListener("pointerleave", handlePointerLeaveResume);
          viewport.removeEventListener("keydown", handleKeyDown);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        });
      }
    });
    function getSortedTabbableCandidates({ tabbingDirection }) {
      const toastItems = getItems().map((i) => i.ref);
      const tabbableCandidates = toastItems.map((toastNode) => {
        const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
        return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
      });
      return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
    }
    return (_ctx, _cache) => {
      return openBlock344(), createBlock335(unref346(DismissableLayerBranch_default), {
        role: "region",
        "aria-label": typeof unref346(label) === "string" ? unref346(label).replace("{hotkey}", hotkeyMessage.value) : unref346(label)(hotkeyMessage.value),
        tabindex: "-1",
        style: normalizeStyle17({ pointerEvents: hasToasts.value ? void 0 : "none" })
      }, {
        default: withCtx340(() => [
          hasToasts.value ? (openBlock344(), createBlock335(FocusProxy_default, {
            key: 0,
            ref: (node) => {
              headFocusProxyRef.value = unref346(unrefElement)(node);
              return void 0;
            },
            onFocusFromOutsideViewport: _cache[0] || (_cache[0] = () => {
              const tabbableCandidates = getSortedTabbableCandidates({ tabbingDirection: "forwards" });
              unref346(focusFirst)(tabbableCandidates);
            })
          }, null, 512)) : createCommentVNode41("v-if", true),
          createVNode68(unref346(CollectionSlot), null, {
            default: withCtx340(() => [createVNode68(unref346(Primitive), mergeProps155({
              ref: unref346(forwardRef),
              tabindex: "-1",
              as: _ctx.as,
              "as-child": _ctx.asChild
            }, _ctx.$attrs), {
              default: withCtx340(() => [renderSlot346(_ctx.$slots, "default")]),
              _: 3
            }, 16, ["as", "as-child"])]),
            _: 3
          }),
          hasToasts.value ? (openBlock344(), createBlock335(FocusProxy_default, {
            key: 1,
            ref: (node) => {
              tailFocusProxyRef.value = unref346(unrefElement)(node);
              return void 0;
            },
            onFocusFromOutsideViewport: _cache[1] || (_cache[1] = () => {
              const tabbableCandidates = getSortedTabbableCandidates({ tabbingDirection: "backwards" });
              unref346(focusFirst)(tabbableCandidates);
            })
          }, null, 512)) : createCommentVNode41("v-if", true)
        ]),
        _: 3
      }, 8, ["aria-label", "style"]);
    };
  }
});
var ToastViewport_default = ToastViewport_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ToggleGroup/ToggleGroupRoot.js
import { createBlock as createBlock336, createCommentVNode as createCommentVNode42, createVNode as createVNode69, defineComponent as defineComponent355, openBlock as openBlock345, renderSlot as renderSlot347, resolveDynamicComponent as resolveDynamicComponent8, toRefs as toRefs57, unref as unref347, withCtx as withCtx341 } from "vue";
var [injectToggleGroupRootContext, provideToggleGroupRootContext] = createContext("ToggleGroupRoot");
var ToggleGroupRoot_vue_vue_type_script_setup_true_lang_default = defineComponent355({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: {
      type: Boolean,
      required: false,
      default: true
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    orientation: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    loop: {
      type: Boolean,
      required: false,
      default: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    },
    type: {
      type: String,
      required: false
    },
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { loop, rovingFocus, disabled, dir: propDir } = toRefs57(props2);
    const dir = useDirection(propDir);
    const { forwardRef, currentElement } = useForwardExpose();
    const { modelValue, changeModelValue, isSingle } = useSingleOrMultipleValue(props2, emits);
    const isFormControl = useFormControl(currentElement);
    provideToggleGroupRootContext({
      isSingle,
      modelValue,
      changeModelValue,
      dir,
      orientation: props2.orientation,
      loop,
      rovingFocus,
      disabled
    });
    return (_ctx, _cache) => {
      return openBlock345(), createBlock336(resolveDynamicComponent8(unref347(rovingFocus) ? unref347(RovingFocusGroup_default) : unref347(Primitive)), {
        "as-child": "",
        orientation: unref347(rovingFocus) ? _ctx.orientation : void 0,
        dir: unref347(dir),
        loop: unref347(rovingFocus) ? unref347(loop) : void 0
      }, {
        default: withCtx341(() => [createVNode69(unref347(Primitive), {
          ref: unref347(forwardRef),
          role: "group",
          "as-child": _ctx.asChild,
          as: _ctx.as
        }, {
          default: withCtx341(() => [renderSlot347(_ctx.$slots, "default", { modelValue: unref347(modelValue) }), unref347(isFormControl) && _ctx.name ? (openBlock345(), createBlock336(VisuallyHiddenInput_default, {
            key: 0,
            name: _ctx.name,
            required: _ctx.required,
            value: unref347(modelValue)
          }, null, 8, [
            "name",
            "required",
            "value"
          ])) : createCommentVNode42("v-if", true)]),
          _: 3
        }, 8, ["as-child", "as"])]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]);
    };
  }
});
var ToggleGroupRoot_default = ToggleGroupRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toggle/Toggle.js
import { computed as computed124, createBlock as createBlock337, createCommentVNode as createCommentVNode43, defineComponent as defineComponent356, openBlock as openBlock346, renderSlot as renderSlot348, unref as unref348, withCtx as withCtx342 } from "vue";
var Toggle_vue_vue_type_script_setup_true_lang_default = defineComponent356({
  __name: "Toggle",
  props: {
    defaultValue: {
      type: Boolean,
      required: false
    },
    modelValue: {
      type: [Boolean, null],
      required: false,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const toggleGroupContext = injectToggleGroupRootContext(null);
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue,
      passive: props2.modelValue === void 0
    });
    function togglePressed() {
      modelValue.value = !modelValue.value;
    }
    const dataState = computed124(() => {
      return modelValue.value ? "on" : "off";
    });
    const isFormControl = useFormControl(currentElement);
    return (_ctx, _cache) => {
      return openBlock346(), createBlock337(unref348(Primitive), {
        ref: unref348(forwardRef),
        type: _ctx.as === "button" ? "button" : void 0,
        "as-child": props2.asChild,
        as: _ctx.as,
        "aria-pressed": unref348(modelValue),
        "data-state": dataState.value,
        "data-disabled": _ctx.disabled ? "" : void 0,
        disabled: _ctx.disabled,
        onClick: togglePressed
      }, {
        default: withCtx342(() => [renderSlot348(_ctx.$slots, "default", {
          modelValue: unref348(modelValue),
          disabled: _ctx.disabled,
          pressed: unref348(modelValue),
          state: dataState.value
        }), unref348(isFormControl) && _ctx.name && !unref348(toggleGroupContext) ? (openBlock346(), createBlock337(VisuallyHiddenInput_default, {
          key: 0,
          type: "checkbox",
          name: _ctx.name,
          value: unref348(modelValue),
          required: _ctx.required
        }, null, 8, [
          "name",
          "value",
          "required"
        ])) : createCommentVNode43("v-if", true)]),
        _: 3
      }, 8, [
        "type",
        "as-child",
        "as",
        "aria-pressed",
        "data-state",
        "data-disabled",
        "disabled"
      ]);
    };
  }
});
var Toggle_default = Toggle_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/ToggleGroup/ToggleGroupItem.js
import { computed as computed125, createBlock as createBlock338, createVNode as createVNode70, defineComponent as defineComponent357, guardReactiveProps as guardReactiveProps106, mergeProps as mergeProps156, normalizeProps as normalizeProps106, openBlock as openBlock347, renderSlot as renderSlot349, resolveDynamicComponent as resolveDynamicComponent9, unref as unref349, withCtx as withCtx343 } from "vue";
var ToggleGroupItem_vue_vue_type_script_setup_true_lang_default = defineComponent357({
  __name: "ToggleGroupItem",
  props: {
    value: {
      type: null,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectToggleGroupRootContext();
    const disabled = computed125(() => rootContext.disabled?.value || props2.disabled);
    const pressed = computed125(() => isValueEqualOrExist(rootContext.modelValue.value, props2.value));
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock347(), createBlock338(resolveDynamicComponent9(unref349(rootContext).rovingFocus.value ? unref349(RovingFocusItem_default) : unref349(Primitive)), mergeProps156({ "as-child": "" }, unref349(rootContext).rovingFocus.value ? {
        focusable: !disabled.value,
        active: pressed.value
      } : {}), {
        default: withCtx343(() => [createVNode70(unref349(Toggle_default), mergeProps156(props2, {
          ref: unref349(forwardRef),
          disabled: disabled.value,
          "model-value": pressed.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref349(rootContext).changeModelValue(_ctx.value))
        }), {
          default: withCtx343((slotProps) => [renderSlot349(_ctx.$slots, "default", normalizeProps106(guardReactiveProps106(slotProps)))]),
          _: 3
        }, 16, ["disabled", "model-value"])]),
        _: 3
      }, 16);
    };
  }
});
var ToggleGroupItem_default = ToggleGroupItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toolbar/ToolbarButton.js
import { createBlock as createBlock339, createVNode as createVNode71, defineComponent as defineComponent358, mergeProps as mergeProps157, openBlock as openBlock348, renderSlot as renderSlot350, unref as unref350, withCtx as withCtx344 } from "vue";
var ToolbarButton_vue_vue_type_script_setup_true_lang_default = defineComponent358({
  __name: "ToolbarButton",
  props: {
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock348(), createBlock339(unref350(RovingFocusItem_default), {
        "as-child": "",
        focusable: !_ctx.disabled
      }, {
        default: withCtx344(() => [createVNode71(unref350(Primitive), mergeProps157({
          ref: unref350(forwardRef),
          type: _ctx.as === "button" ? "button" : void 0
        }, props2), {
          default: withCtx344(() => [renderSlot350(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["type"])]),
        _: 3
      }, 8, ["focusable"]);
    };
  }
});
var ToolbarButton_default = ToolbarButton_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toolbar/ToolbarLink.js
import { createBlock as createBlock340, createVNode as createVNode72, defineComponent as defineComponent359, mergeProps as mergeProps158, openBlock as openBlock349, renderSlot as renderSlot351, unref as unref351, withCtx as withCtx345 } from "vue";
var ToolbarLink_vue_vue_type_script_setup_true_lang_default = defineComponent359({
  __name: "ToolbarLink",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "a"
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock349(), createBlock340(unref351(RovingFocusItem_default), {
        "as-child": "",
        focusable: ""
      }, {
        default: withCtx345(() => [createVNode72(unref351(Primitive), mergeProps158(props2, {
          ref: unref351(forwardRef),
          onKeydown: _cache[0] || (_cache[0] = (event) => {
            if (event.key === " ") event.currentTarget?.click();
          })
        }), {
          default: withCtx345(() => [renderSlot351(_ctx.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      });
    };
  }
});
var ToolbarLink_default = ToolbarLink_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toolbar/ToolbarRoot.js
import { createBlock as createBlock341, createVNode as createVNode73, defineComponent as defineComponent360, openBlock as openBlock350, renderSlot as renderSlot352, toRefs as toRefs58, unref as unref352, withCtx as withCtx346 } from "vue";
var [injectToolbarRootContext, provideToolbarRootContext] = createContext("ToolbarRoot");
var ToolbarRoot_vue_vue_type_script_setup_true_lang_default = defineComponent360({
  __name: "ToolbarRoot",
  props: {
    orientation: {
      type: String,
      required: false,
      default: "horizontal"
    },
    dir: {
      type: String,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { orientation, dir: propDir } = toRefs58(props2);
    const dir = useDirection(propDir);
    const { forwardRef } = useForwardExpose();
    provideToolbarRootContext({
      orientation,
      dir
    });
    return (_ctx, _cache) => {
      return openBlock350(), createBlock341(unref352(RovingFocusGroup_default), {
        "as-child": "",
        orientation: unref352(orientation),
        dir: unref352(dir),
        loop: _ctx.loop
      }, {
        default: withCtx346(() => [createVNode73(unref352(Primitive), {
          ref: unref352(forwardRef),
          role: "toolbar",
          "aria-orientation": unref352(orientation),
          "as-child": _ctx.asChild,
          as: _ctx.as
        }, {
          default: withCtx346(() => [renderSlot352(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "aria-orientation",
          "as-child",
          "as"
        ])]),
        _: 3
      }, 8, [
        "orientation",
        "dir",
        "loop"
      ]);
    };
  }
});
var ToolbarRoot_default = ToolbarRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toolbar/ToolbarSeparator.js
import { createBlock as createBlock342, defineComponent as defineComponent361, openBlock as openBlock351, renderSlot as renderSlot353, unref as unref353, withCtx as withCtx347 } from "vue";
var ToolbarSeparator_vue_vue_type_script_setup_true_lang_default = defineComponent361({
  __name: "ToolbarSeparator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectToolbarRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock351(), createBlock342(BaseSeparator_default, {
        orientation: unref353(rootContext).orientation.value,
        "as-child": props2.asChild,
        as: _ctx.as
      }, {
        default: withCtx347(() => [renderSlot353(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "orientation",
        "as-child",
        "as"
      ]);
    };
  }
});
var ToolbarSeparator_default = ToolbarSeparator_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toolbar/ToolbarToggleGroup.js
import { createBlock as createBlock343, defineComponent as defineComponent362, mergeProps as mergeProps159, openBlock as openBlock352, renderSlot as renderSlot354, unref as unref354, withCtx as withCtx348 } from "vue";
var ToolbarToggleGroup_vue_vue_type_script_setup_true_lang_default = defineComponent362({
  __name: "ToolbarToggleGroup",
  props: {
    rovingFocus: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    orientation: {
      type: String,
      required: false
    },
    dir: {
      type: String,
      required: false
    },
    loop: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    name: {
      type: String,
      required: false
    },
    required: {
      type: Boolean,
      required: false
    },
    type: {
      type: String,
      required: false
    },
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectToolbarRootContext();
    const emitsAsProps = useEmitAsProps(emits);
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock352(), createBlock343(unref354(ToggleGroupRoot_default), mergeProps159({
        ...props2,
        ...unref354(emitsAsProps)
      }, {
        "data-orientation": unref354(rootContext).orientation.value,
        dir: unref354(rootContext).dir.value,
        "roving-focus": false
      }), {
        default: withCtx348(() => [renderSlot354(_ctx.$slots, "default")]),
        _: 3
      }, 16, ["data-orientation", "dir"]);
    };
  }
});
var ToolbarToggleGroup_default = ToolbarToggleGroup_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Toolbar/ToolbarToggleItem.js
import { createBlock as createBlock344, createVNode as createVNode74, defineComponent as defineComponent363, mergeProps as mergeProps160, openBlock as openBlock353, renderSlot as renderSlot355, unref as unref355, withCtx as withCtx349 } from "vue";
var ToolbarToggleItem_vue_vue_type_script_setup_true_lang_default = defineComponent363({
  __name: "ToolbarToggleItem",
  props: {
    value: {
      type: null,
      required: true
    },
    disabled: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock353(), createBlock344(ToolbarButton_default, { "as-child": "" }, {
        default: withCtx349(() => [createVNode74(unref355(ToggleGroupItem_default), mergeProps160(props2, { ref: unref355(forwardRef) }), {
          default: withCtx349(() => [renderSlot355(_ctx.$slots, "default")]),
          _: 3
        }, 16)]),
        _: 3
      });
    };
  }
});
var ToolbarToggleItem_default = ToolbarToggleItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/TooltipArrow.js
import { createBlock as createBlock345, defineComponent as defineComponent364, guardReactiveProps as guardReactiveProps107, normalizeProps as normalizeProps107, openBlock as openBlock354, renderSlot as renderSlot356, unref as unref356, withCtx as withCtx350 } from "vue";
var TooltipArrow_vue_vue_type_script_setup_true_lang_default = defineComponent364({
  __name: "TooltipArrow",
  props: {
    width: {
      type: Number,
      required: false,
      default: 10
    },
    height: {
      type: Number,
      required: false,
      default: 5
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "svg"
    }
  },
  setup(__props) {
    const props2 = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock354(), createBlock345(unref356(PopperArrow_default), normalizeProps107(guardReactiveProps107(props2)), {
        default: withCtx350(() => [renderSlot356(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var TooltipArrow_default = TooltipArrow_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/TooltipProvider.js
import { defineComponent as defineComponent365, ref as ref113, renderSlot as renderSlot357, toRefs as toRefs59 } from "vue";
var [injectTooltipProviderContext, provideTooltipProviderContext] = createContext("TooltipProvider");
var TooltipProvider_vue_vue_type_script_setup_true_lang_default = defineComponent365({
  inheritAttrs: false,
  __name: "TooltipProvider",
  props: {
    delayDuration: {
      type: Number,
      required: false,
      default: 700
    },
    skipDelayDuration: {
      type: Number,
      required: false,
      default: 300
    },
    disableHoverableContent: {
      type: Boolean,
      required: false,
      default: false
    },
    disableClosingTrigger: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { delayDuration, skipDelayDuration, disableHoverableContent, disableClosingTrigger, ignoreNonKeyboardFocus, disabled } = toRefs59(props2);
    useForwardExpose();
    const isOpenDelayed = ref113(true);
    const isPointerInTransitRef = ref113(false);
    const { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {
      isOpenDelayed.value = true;
    }, skipDelayDuration, { immediate: false });
    provideTooltipProviderContext({
      isOpenDelayed,
      delayDuration,
      onOpen() {
        clearTimer();
        isOpenDelayed.value = false;
      },
      onClose() {
        startTimer();
      },
      isPointerInTransitRef,
      disableHoverableContent,
      disableClosingTrigger,
      disabled,
      ignoreNonKeyboardFocus
    });
    return (_ctx, _cache) => {
      return renderSlot357(_ctx.$slots, "default");
    };
  }
});
var TooltipProvider_default = TooltipProvider_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/utils.js
var TOOLTIP_OPEN = "tooltip.open";

// node_modules/reka-ui/dist/Tooltip/TooltipRoot.js
import { computed as computed126, createBlock as createBlock346, defineComponent as defineComponent366, openBlock as openBlock355, ref as ref114, renderSlot as renderSlot358, unref as unref357, watch as watch45, withCtx as withCtx351 } from "vue";
var [injectTooltipRootContext, provideTooltipRootContext] = createContext("TooltipRoot");
var TooltipRoot_vue_vue_type_script_setup_true_lang_default = defineComponent366({
  __name: "TooltipRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false,
      default: false
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    delayDuration: {
      type: Number,
      required: false,
      default: void 0
    },
    disableHoverableContent: {
      type: Boolean,
      required: false,
      default: void 0
    },
    disableClosingTrigger: {
      type: Boolean,
      required: false,
      default: void 0
    },
    disabled: {
      type: Boolean,
      required: false,
      default: void 0
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: false,
      default: void 0
    }
  },
  emits: ["update:open"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emit = __emit;
    useForwardExpose();
    const providerContext = injectTooltipProviderContext();
    const disableHoverableContent = computed126(() => props2.disableHoverableContent ?? providerContext.disableHoverableContent.value);
    const disableClosingTrigger = computed126(() => props2.disableClosingTrigger ?? providerContext.disableClosingTrigger.value);
    const disableTooltip = computed126(() => props2.disabled ?? providerContext.disabled.value);
    const delayDuration = computed126(() => props2.delayDuration ?? providerContext.delayDuration.value);
    const ignoreNonKeyboardFocus = computed126(() => props2.ignoreNonKeyboardFocus ?? providerContext.ignoreNonKeyboardFocus.value);
    const open = useVModel(props2, "open", emit, {
      defaultValue: props2.defaultOpen,
      passive: props2.open === void 0
    });
    watch45(open, (isOpen) => {
      if (!providerContext.onClose) return;
      if (isOpen) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else providerContext.onClose();
    });
    const wasOpenDelayedRef = ref114(false);
    const trigger = ref114();
    const stateAttribute = computed126(() => {
      if (!open.value) return "closed";
      return wasOpenDelayedRef.value ? "delayed-open" : "instant-open";
    });
    const { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {
      wasOpenDelayedRef.value = true;
      open.value = true;
    }, delayDuration, { immediate: false });
    function handleOpen() {
      clearTimer();
      wasOpenDelayedRef.value = false;
      open.value = true;
    }
    function handleClose() {
      clearTimer();
      open.value = false;
    }
    function handleDelayedOpen() {
      startTimer();
    }
    provideTooltipRootContext({
      contentId: "",
      open,
      stateAttribute,
      trigger,
      onTriggerChange(el) {
        trigger.value = el;
      },
      onTriggerEnter() {
        if (providerContext.isOpenDelayed.value) handleDelayedOpen();
        else handleOpen();
      },
      onTriggerLeave() {
        if (disableHoverableContent.value) handleClose();
        else clearTimer();
      },
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      disableClosingTrigger,
      disabled: disableTooltip,
      ignoreNonKeyboardFocus
    });
    return (_ctx, _cache) => {
      return openBlock355(), createBlock346(unref357(PopperRoot_default), null, {
        default: withCtx351(() => [renderSlot358(_ctx.$slots, "default", { open: unref357(open) })]),
        _: 3
      });
    };
  }
});
var TooltipRoot_default = TooltipRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/TooltipContentImpl.js
import { Comment as Comment2, computed as computed127, createBlock as createBlock347, createTextVNode as createTextVNode32, createVNode as createVNode75, defineComponent as defineComponent367, mergeProps as mergeProps161, onMounted as onMounted55, openBlock as openBlock356, renderSlot as renderSlot359, toDisplayString as toDisplayString18, unref as unref358, useSlots as useSlots2, withCtx as withCtx352, withModifiers as withModifiers24 } from "vue";
var TooltipContentImpl_vue_vue_type_script_setup_true_lang_default = defineComponent367({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    side: {
      type: null,
      required: false,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: false,
      default: 0
    },
    align: {
      type: null,
      required: false,
      default: "center"
    },
    alignOffset: {
      type: Number,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false,
      default: true
    },
    collisionBoundary: {
      type: null,
      required: false,
      default: () => []
    },
    collisionPadding: {
      type: [Number, Object],
      required: false,
      default: 0
    },
    arrowPadding: {
      type: Number,
      required: false,
      default: 0
    },
    sticky: {
      type: String,
      required: false,
      default: "partial"
    },
    hideWhenDetached: {
      type: Boolean,
      required: false,
      default: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectTooltipRootContext();
    const { forwardRef } = useForwardExpose();
    const slot = useSlots2();
    const defaultSlot = computed127(() => slot.default?.({}));
    const ariaLabel = computed127(() => {
      if (props2.ariaLabel) return props2.ariaLabel;
      let content = "";
      function recursiveTextSearch(node) {
        if (typeof node.children === "string" && node.type !== Comment2) content += node.children;
        else if (Array.isArray(node.children)) node.children.forEach((child) => recursiveTextSearch(child));
      }
      defaultSlot.value?.forEach((node) => recursiveTextSearch(node));
      return content;
    });
    const popperContentProps = computed127(() => {
      const { ariaLabel: _, ...restProps } = props2;
      return restProps;
    });
    onMounted55(() => {
      useEventListener(window, "scroll", (event) => {
        const target = event.target;
        if (target?.contains(rootContext.trigger.value)) rootContext.onClose();
      });
      useEventListener(window, TOOLTIP_OPEN, rootContext.onClose);
    });
    return (_ctx, _cache) => {
      return openBlock356(), createBlock347(unref358(DismissableLayer_default), {
        "as-child": "",
        "disable-outside-pointer-events": false,
        onEscapeKeyDown: _cache[0] || (_cache[0] = ($event) => emits("escapeKeyDown", $event)),
        onPointerDownOutside: _cache[1] || (_cache[1] = (event) => {
          if (unref358(rootContext).disableClosingTrigger.value && unref358(rootContext).trigger.value?.contains(event.target)) event.preventDefault();
          emits("pointerDownOutside", event);
        }),
        onFocusOutside: _cache[2] || (_cache[2] = withModifiers24(() => {
        }, ["prevent"])),
        onDismiss: _cache[3] || (_cache[3] = ($event) => unref358(rootContext).onClose())
      }, {
        default: withCtx352(() => [createVNode75(unref358(PopperContent_default), mergeProps161({
          ref: unref358(forwardRef),
          "data-state": unref358(rootContext).stateAttribute.value
        }, {
          ..._ctx.$attrs,
          ...popperContentProps.value
        }, { style: {
          "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
          "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
          "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
        } }), {
          default: withCtx352(() => [renderSlot359(_ctx.$slots, "default"), createVNode75(unref358(VisuallyHidden_default), {
            id: unref358(rootContext).contentId,
            role: "tooltip"
          }, {
            default: withCtx352(() => [createTextVNode32(toDisplayString18(ariaLabel.value), 1)]),
            _: 1
          }, 8, ["id"])]),
          _: 3
        }, 16, ["data-state"])]),
        _: 3
      });
    };
  }
});
var TooltipContentImpl_default = TooltipContentImpl_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/TooltipContentHoverable.js
import { createBlock as createBlock348, defineComponent as defineComponent368, mergeProps as mergeProps162, openBlock as openBlock357, renderSlot as renderSlot360, unref as unref359, withCtx as withCtx353 } from "vue";
var TooltipContentHoverable_vue_vue_type_script_setup_true_lang_default = defineComponent368({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    side: {
      type: null,
      required: false
    },
    sideOffset: {
      type: Number,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const forwardedProps = useForwardProps(props2);
    const { forwardRef, currentElement } = useForwardExpose();
    const { trigger, onClose } = injectTooltipRootContext();
    const providerContext = injectTooltipProviderContext();
    const { isPointerInTransit, onPointerExit } = useGraceArea(trigger, currentElement);
    providerContext.isPointerInTransitRef = isPointerInTransit;
    onPointerExit(() => {
      onClose();
    });
    return (_ctx, _cache) => {
      return openBlock357(), createBlock348(TooltipContentImpl_default, mergeProps162({ ref: unref359(forwardRef) }, unref359(forwardedProps)), {
        default: withCtx353(() => [renderSlot360(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var TooltipContentHoverable_default = TooltipContentHoverable_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/TooltipContent.js
import { createBlock as createBlock349, defineComponent as defineComponent369, mergeProps as mergeProps163, openBlock as openBlock358, renderSlot as renderSlot361, resolveDynamicComponent as resolveDynamicComponent10, unref as unref360, withCtx as withCtx354 } from "vue";
var TooltipContent_vue_vue_type_script_setup_true_lang_default = defineComponent369({
  __name: "TooltipContent",
  props: {
    forceMount: {
      type: Boolean,
      required: false
    },
    ariaLabel: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    },
    side: {
      type: null,
      required: false,
      default: "top"
    },
    sideOffset: {
      type: Number,
      required: false
    },
    align: {
      type: null,
      required: false
    },
    alignOffset: {
      type: Number,
      required: false
    },
    avoidCollisions: {
      type: Boolean,
      required: false
    },
    collisionBoundary: {
      type: null,
      required: false
    },
    collisionPadding: {
      type: [Number, Object],
      required: false
    },
    arrowPadding: {
      type: Number,
      required: false
    },
    sticky: {
      type: String,
      required: false
    },
    hideWhenDetached: {
      type: Boolean,
      required: false
    },
    positionStrategy: {
      type: String,
      required: false
    },
    updatePositionStrategy: {
      type: String,
      required: false
    }
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectTooltipRootContext();
    const forwarded = useForwardPropsEmits(props2, emits);
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock358(), createBlock349(unref360(Presence_default), { present: _ctx.forceMount || unref360(rootContext).open.value }, {
        default: withCtx354(() => [(openBlock358(), createBlock349(resolveDynamicComponent10(unref360(rootContext).disableHoverableContent.value ? TooltipContentImpl_default : TooltipContentHoverable_default), mergeProps163({ ref: unref360(forwardRef) }, unref360(forwarded)), {
          default: withCtx354(() => [renderSlot361(_ctx.$slots, "default")]),
          _: 3
        }, 16))]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var TooltipContent_default = TooltipContent_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/TooltipPortal.js
import { createBlock as createBlock350, defineComponent as defineComponent370, guardReactiveProps as guardReactiveProps108, normalizeProps as normalizeProps108, openBlock as openBlock359, renderSlot as renderSlot362, unref as unref361, withCtx as withCtx355 } from "vue";
var TooltipPortal_vue_vue_type_script_setup_true_lang_default = defineComponent370({
  __name: "TooltipPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    return (_ctx, _cache) => {
      return openBlock359(), createBlock350(unref361(Teleport_default), normalizeProps108(guardReactiveProps108(props2)), {
        default: withCtx355(() => [renderSlot362(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var TooltipPortal_default = TooltipPortal_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tooltip/TooltipTrigger.js
import { computed as computed128, createBlock as createBlock351, createVNode as createVNode76, defineComponent as defineComponent371, mergeProps as mergeProps164, onMounted as onMounted56, openBlock as openBlock360, ref as ref115, renderSlot as renderSlot363, toHandlers as toHandlers4, unref as unref362, withCtx as withCtx356 } from "vue";
var TooltipTrigger_vue_vue_type_script_setup_true_lang_default = defineComponent371({
  __name: "TooltipTrigger",
  props: {
    reference: {
      type: null,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props2 = __props;
    const rootContext = injectTooltipRootContext();
    const providerContext = injectTooltipProviderContext();
    rootContext.contentId ||= useId2(void 0, "reka-tooltip-content");
    const { forwardRef, currentElement: triggerElement } = useForwardExpose();
    const isPointerDown2 = ref115(false);
    const hasPointerMoveOpened = ref115(false);
    const tooltipListeners = computed128(() => {
      if (rootContext.disabled.value) return {};
      return {
        click: handleClick,
        focus: handleFocus,
        pointermove: handlePointerMove2,
        pointerleave: handlePointerLeave,
        pointerdown: handlePointerDown2,
        blur: handleBlur
      };
    });
    onMounted56(() => {
      rootContext.onTriggerChange(triggerElement.value);
    });
    function handlePointerUp2() {
      setTimeout(() => {
        isPointerDown2.value = false;
      }, 1);
    }
    function handlePointerDown2() {
      if (rootContext.open && !rootContext.disableClosingTrigger.value) rootContext.onClose();
      isPointerDown2.value = true;
      document.addEventListener("pointerup", handlePointerUp2, { once: true });
    }
    function handlePointerMove2(event) {
      if (event.pointerType === "touch") return;
      if (!hasPointerMoveOpened.value && !providerContext.isPointerInTransitRef.value) {
        rootContext.onTriggerEnter();
        hasPointerMoveOpened.value = true;
      }
    }
    function handlePointerLeave() {
      rootContext.onTriggerLeave();
      hasPointerMoveOpened.value = false;
    }
    function handleFocus(event) {
      if (isPointerDown2.value) return;
      if (rootContext.ignoreNonKeyboardFocus.value && !event.target.matches?.(":focus-visible")) return;
      rootContext.onOpen();
    }
    function handleBlur() {
      rootContext.onClose();
    }
    function handleClick() {
      if (!rootContext.disableClosingTrigger.value) rootContext.onClose();
    }
    return (_ctx, _cache) => {
      return openBlock360(), createBlock351(unref362(PopperAnchor_default), {
        "as-child": "",
        reference: _ctx.reference
      }, {
        default: withCtx356(() => [createVNode76(unref362(Primitive), mergeProps164({
          ref: unref362(forwardRef),
          "aria-describedby": unref362(rootContext).open.value ? unref362(rootContext).contentId : void 0,
          "data-state": unref362(rootContext).stateAttribute.value,
          as: _ctx.as,
          "as-child": props2.asChild,
          "data-grace-area-trigger": ""
        }, toHandlers4(tooltipListeners.value)), {
          default: withCtx356(() => [renderSlot363(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "aria-describedby",
          "data-state",
          "as",
          "as-child"
        ])]),
        _: 3
      }, 8, ["reference"]);
    };
  }
});
var TooltipTrigger_default = TooltipTrigger_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tree/utils.js
function flatten(items) {
  return items.reduce((acc, item) => {
    acc.push(item);
    if (item.children) acc.push(...flatten(item.children));
    return acc;
  }, []);
}

// node_modules/reka-ui/dist/Tree/TreeRoot.js
import { computed as computed129, createBlock as createBlock352, createVNode as createVNode77, defineComponent as defineComponent372, nextTick as nextTick34, openBlock as openBlock361, ref as ref116, renderSlot as renderSlot364, toRefs as toRefs60, unref as unref363, withCtx as withCtx357, withKeys as withKeys25, withModifiers as withModifiers25 } from "vue";
var [injectTreeRootContext, provideTreeRootContext] = createContext("TreeRoot");
var TreeRoot_vue_vue_type_script_setup_true_lang_default = defineComponent372({
  __name: "TreeRoot",
  props: {
    modelValue: {
      type: null,
      required: false
    },
    defaultValue: {
      type: null,
      required: false
    },
    items: {
      type: Array,
      required: false
    },
    expanded: {
      type: Array,
      required: false
    },
    defaultExpanded: {
      type: Array,
      required: false
    },
    getKey: {
      type: Function,
      required: true
    },
    getChildren: {
      type: Function,
      required: false,
      default: (val) => val.children
    },
    selectionBehavior: {
      type: String,
      required: false,
      default: "toggle"
    },
    multiple: {
      type: Boolean,
      required: false,
      skipCheck: true
    },
    dir: {
      type: String,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    propagateSelect: {
      type: Boolean,
      required: false
    },
    bubbleSelect: {
      type: Boolean,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "ul"
    }
  },
  emits: ["update:modelValue", "update:expanded"],
  setup(__props, { emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const { items, multiple, disabled, propagateSelect, dir: propDir, bubbleSelect } = toRefs60(props2);
    const { handleTypeaheadSearch } = useTypeahead();
    const dir = useDirection(propDir);
    const rovingFocusGroupRef = ref116();
    const isVirtual = ref116(false);
    const virtualKeydownHook = createEventHook();
    const modelValue = useVModel(props2, "modelValue", emits, {
      defaultValue: props2.defaultValue ?? (multiple.value ? [] : void 0),
      passive: true,
      deep: true
    });
    const expanded = useVModel(props2, "expanded", emits, {
      defaultValue: props2.defaultExpanded ?? [],
      passive: props2.expanded === void 0,
      deep: true
    });
    const { onSelectItem, handleMultipleReplace } = useSelectionBehavior(modelValue, props2);
    const selectedKeys = computed129(() => {
      if (multiple.value && Array.isArray(modelValue.value)) return modelValue.value.map((i) => props2.getKey(i));
      else return [props2.getKey(modelValue.value ?? {})];
    });
    function flattenItems(items$1, level = 1, parentItem) {
      return items$1.reduce((acc, item, index) => {
        const key = props2.getKey(item);
        const children = props2.getChildren(item);
        const isExpanded = expanded.value.includes(key);
        const flattenedItem = {
          _id: key,
          value: item,
          index,
          level,
          parentItem,
          hasChildren: !!children,
          bind: {
            "value": item,
            level,
            "aria-setsize": items$1.length,
            "aria-posinset": index + 1
          }
        };
        acc.push(flattenedItem);
        if (children && isExpanded) acc.push(...flattenItems(children, level + 1, item));
        return acc;
      }, []);
    }
    const expandedItems = computed129(() => {
      const items$1 = props2.items;
      const expandedKeys = expanded.value.map((i) => i);
      return flattenItems(items$1 ?? []);
    });
    function handleKeydown(event) {
      if (isVirtual.value) virtualKeydownHook.trigger(event);
      else {
        const collections = rovingFocusGroupRef.value?.getItems() ?? [];
        handleTypeaheadSearch(event.key, collections);
      }
    }
    function handleKeydownNavigation(event) {
      if (isVirtual.value) return;
      const intent = MAP_KEY_TO_FOCUS_INTENT[event.key];
      nextTick34(() => {
        handleMultipleReplace(intent, getActiveElement(), rovingFocusGroupRef.value?.getItems, expandedItems.value.map((i) => i.value));
      });
    }
    function handleBubbleSelect(item) {
      if (item.parentItem != null && Array.isArray(modelValue.value) && props2.multiple) {
        const parentItem = expandedItems.value.find((i) => {
          return item.parentItem != null && props2.getKey(i.value) === props2.getKey(item.parentItem);
        });
        if (parentItem != null) {
          const areAllChilredOfParentSelected = props2.getChildren(parentItem.value)?.every((i) => modelValue.value.find((v) => props2.getKey(v) === props2.getKey(i)));
          if (areAllChilredOfParentSelected) modelValue.value = [...modelValue.value, parentItem.value];
          else modelValue.value = modelValue.value.filter((v) => props2.getKey(v) !== props2.getKey(parentItem.value));
          handleBubbleSelect(parentItem);
        }
      }
    }
    provideTreeRootContext({
      modelValue,
      selectedKeys,
      onSelect: (val) => {
        const condition = (baseValue) => props2.getKey(baseValue ?? {}) === props2.getKey(val);
        const exist = props2.multiple && Array.isArray(modelValue.value) ? modelValue.value?.findIndex(condition) !== -1 : void 0;
        onSelectItem(val, condition);
        if (props2.bubbleSelect && props2.multiple && Array.isArray(modelValue.value)) {
          const item = expandedItems.value.find((i) => {
            return props2.getKey(i.value) === props2.getKey(val);
          });
          if (item != null) handleBubbleSelect(item);
        }
        if (props2.propagateSelect && props2.multiple && Array.isArray(modelValue.value)) {
          const children = flatten(props2.getChildren(val) ?? []);
          if (exist) modelValue.value = [...modelValue.value].filter((i) => !children.some((child) => props2.getKey(i ?? {}) === props2.getKey(child)));
          else modelValue.value = [...modelValue.value, ...children];
        }
      },
      expanded,
      onToggle(val) {
        const children = val ? props2.getChildren(val) : void 0;
        if (!children) return;
        const key = props2.getKey(val) ?? val;
        if (expanded.value.includes(key)) expanded.value = expanded.value.filter((val$1) => val$1 !== key);
        else expanded.value.push(key);
      },
      getKey: props2.getKey,
      getChildren: props2.getChildren,
      items,
      expandedItems,
      disabled,
      multiple,
      dir,
      propagateSelect,
      bubbleSelect,
      isVirtual,
      virtualKeydownHook,
      handleMultipleReplace
    });
    return (_ctx, _cache) => {
      return openBlock361(), createBlock352(unref363(RovingFocusGroup_default), {
        ref_key: "rovingFocusGroupRef",
        ref: rovingFocusGroupRef,
        "as-child": "",
        orientation: "vertical",
        dir: unref363(dir)
      }, {
        default: withCtx357(() => [createVNode77(unref363(Primitive), {
          role: "tree",
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "aria-multiselectable": unref363(multiple) ? true : void 0,
          onKeydown: [handleKeydown, withKeys25(withModifiers25(handleKeydownNavigation, ["shift"]), ["up", "down"])]
        }, {
          default: withCtx357(() => [renderSlot364(_ctx.$slots, "default", {
            flattenItems: expandedItems.value,
            modelValue: unref363(modelValue),
            expanded: unref363(expanded)
          })]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "aria-multiselectable",
          "onKeydown"
        ])]),
        _: 3
      }, 8, ["dir"]);
    };
  }
});
var TreeRoot_default = TreeRoot_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tree/TreeItem.js
import { computed as computed130, createBlock as createBlock353, createVNode as createVNode78, defineComponent as defineComponent373, mergeProps as mergeProps165, openBlock as openBlock362, renderSlot as renderSlot365, unref as unref364, withCtx as withCtx358, withKeys as withKeys26, withModifiers as withModifiers26 } from "vue";
var TREE_SELECT = "tree.select";
var TREE_TOGGLE = "tree.toggle";
var TreeItem_vue_vue_type_script_setup_true_lang_default = defineComponent373({
  inheritAttrs: false,
  __name: "TreeItem",
  props: {
    value: {
      type: null,
      required: true
    },
    level: {
      type: Number,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "li"
    }
  },
  emits: ["select", "toggle"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props2 = __props;
    const emits = __emit;
    const rootContext = injectTreeRootContext();
    const { getItems } = useCollection();
    const hasChildren = computed130(() => !!rootContext.getChildren(props2.value));
    const isExpanded = computed130(() => {
      const key = rootContext.getKey(props2.value);
      return rootContext.expanded.value.includes(key);
    });
    const isSelected = computed130(() => {
      const key = rootContext.getKey(props2.value);
      return rootContext.selectedKeys.value.includes(key);
    });
    const isIndeterminate3 = computed130(() => {
      if (rootContext.bubbleSelect.value && hasChildren.value && Array.isArray(rootContext.modelValue.value)) {
        const children = flatten(rootContext.getChildren(props2.value) || []);
        return children.some((child) => rootContext.modelValue.value.find((v) => rootContext.getKey(v) === rootContext.getKey(child))) && !children.every((child) => rootContext.modelValue.value.find((v) => rootContext.getKey(v) === rootContext.getKey(child)));
      } else if (rootContext.propagateSelect.value && isSelected.value && hasChildren.value && Array.isArray(rootContext.modelValue.value)) {
        const children = flatten(rootContext.getChildren(props2.value) || []);
        return !children.every((child) => rootContext.modelValue.value.find((v) => rootContext.getKey(v) === rootContext.getKey(child)));
      } else return void 0;
    });
    function handleKeydownRight(ev) {
      if (!hasChildren.value) return;
      if (isExpanded.value) {
        const collection = getItems().map((i) => i.ref);
        const currentElement = getActiveElement();
        const currentIndex = collection.indexOf(currentElement);
        const list = [...collection].slice(currentIndex);
        const nextElement = list.find((el) => Number(el.getAttribute("data-indent")) === props2.level + 1);
        if (nextElement) nextElement.focus();
      } else handleToggleCustomEvent(ev);
    }
    function handleKeydownLeft(ev) {
      if (isExpanded.value) handleToggleCustomEvent(ev);
      else {
        const collection = getItems().map((i) => i.ref);
        const currentElement = getActiveElement();
        const currentIndex = collection.indexOf(currentElement);
        const list = [...collection].slice(0, currentIndex).reverse();
        const parentElement = list.find((el) => Number(el.getAttribute("data-indent")) === props2.level - 1);
        if (parentElement) parentElement.focus();
      }
    }
    async function handleSelect2(ev) {
      emits("select", ev);
      if (ev?.defaultPrevented) return;
      rootContext.onSelect(props2.value);
    }
    async function handleToggle(ev) {
      emits("toggle", ev);
      if (ev?.defaultPrevented) return;
      rootContext.onToggle(props2.value);
    }
    async function handleSelectCustomEvent(ev) {
      if (!ev) return;
      const eventDetail = {
        originalEvent: ev,
        value: props2.value,
        isExpanded: isExpanded.value,
        isSelected: isSelected.value
      };
      handleAndDispatchCustomEvent(TREE_SELECT, handleSelect2, eventDetail);
    }
    async function handleToggleCustomEvent(ev) {
      if (!ev) return;
      const eventDetail = {
        originalEvent: ev,
        value: props2.value,
        isExpanded: isExpanded.value,
        isSelected: isSelected.value
      };
      handleAndDispatchCustomEvent(TREE_TOGGLE, handleToggle, eventDetail);
    }
    __expose({
      isExpanded,
      isSelected,
      isIndeterminate: isIndeterminate3,
      handleToggle: () => rootContext.onToggle(props2.value),
      handleSelect: () => rootContext.onSelect(props2.value)
    });
    return (_ctx, _cache) => {
      return openBlock362(), createBlock353(unref364(RovingFocusItem_default), {
        "as-child": "",
        value: _ctx.value,
        "allow-shift-key": ""
      }, {
        default: withCtx358(() => [createVNode78(unref364(Primitive), mergeProps165(_ctx.$attrs, {
          role: "treeitem",
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "aria-selected": isSelected.value,
          "aria-expanded": hasChildren.value ? isExpanded.value : void 0,
          "aria-level": _ctx.level,
          "data-indent": _ctx.level,
          "data-selected": isSelected.value ? "" : void 0,
          "data-expanded": isExpanded.value ? "" : void 0,
          onKeydown: [
            withKeys26(withModifiers26(handleSelectCustomEvent, ["self", "prevent"]), ["enter", "space"]),
            _cache[0] || (_cache[0] = withKeys26(withModifiers26((ev) => unref364(rootContext).dir.value === "ltr" ? handleKeydownRight(ev) : handleKeydownLeft(ev), ["prevent"]), ["right"])),
            _cache[1] || (_cache[1] = withKeys26(withModifiers26((ev) => unref364(rootContext).dir.value === "ltr" ? handleKeydownLeft(ev) : handleKeydownRight(ev), ["prevent"]), ["left"]))
          ],
          onClick: _cache[2] || (_cache[2] = withModifiers26((ev) => {
            handleSelectCustomEvent(ev);
            handleToggleCustomEvent(ev);
          }, ["stop"]))
        }), {
          default: withCtx358(() => [renderSlot365(_ctx.$slots, "default", {
            isExpanded: isExpanded.value,
            isSelected: isSelected.value,
            isIndeterminate: isIndeterminate3.value,
            handleSelect: () => unref364(rootContext).onSelect(_ctx.value),
            handleToggle: () => unref364(rootContext).onToggle(_ctx.value)
          })]),
          _: 3
        }, 16, [
          "as",
          "as-child",
          "aria-selected",
          "aria-expanded",
          "aria-level",
          "data-indent",
          "data-selected",
          "data-expanded",
          "onKeydown"
        ])]),
        _: 3
      }, 8, ["value"]);
    };
  }
});
var TreeItem_default = TreeItem_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Tree/TreeVirtualizer.js
import { Fragment as Fragment12, cloneVNode as cloneVNode3, computed as computed131, createBlock as createBlock354, createElementBlock as createElementBlock16, defineComponent as defineComponent374, nextTick as nextTick35, normalizeStyle as normalizeStyle18, openBlock as openBlock363, renderList as renderList4, resolveDynamicComponent as resolveDynamicComponent11, unref as unref365, useSlots as useSlots3 } from "vue";
var TreeVirtualizer_vue_vue_type_script_setup_true_lang_default = defineComponent374({
  __name: "TreeVirtualizer",
  props: {
    overscan: {
      type: Number,
      required: false
    },
    estimateSize: {
      type: Number,
      required: false
    },
    textContent: {
      type: Function,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const slots = useSlots3();
    const rootContext = injectTreeRootContext();
    const parentEl = useParentElement();
    const { getItems } = useCollection();
    const search = refAutoReset("", 1e3);
    const optionsWithMetadata = computed131(() => {
      const parseTextContent = (option) => {
        if (props2.textContent) return props2.textContent(option);
        else return option.toString().toLowerCase();
      };
      return rootContext.expandedItems.value.map((option, index) => ({
        index,
        textContent: parseTextContent(option.value)
      }));
    });
    rootContext.isVirtual.value = true;
    const padding = computed131(() => {
      const el = parentEl.value;
      if (!el) return {
        start: 0,
        end: 0
      };
      else {
        const styles = window.getComputedStyle(el);
        return {
          start: Number.parseFloat(styles.paddingBlockStart || styles.paddingTop),
          end: Number.parseFloat(styles.paddingBlockEnd || styles.paddingBottom)
        };
      }
    });
    const virtualizer = useVirtualizer({
      get scrollPaddingStart() {
        return padding.value.start;
      },
      get scrollPaddingEnd() {
        return padding.value.end;
      },
      get count() {
        return rootContext.expandedItems.value.length ?? 0;
      },
      get horizontal() {
        return false;
      },
      getItemKey(index) {
        return index + rootContext.getKey(rootContext.expandedItems.value[index].value);
      },
      estimateSize() {
        return props2.estimateSize ?? 28;
      },
      getScrollElement() {
        return parentEl.value;
      },
      overscan: props2.overscan ?? 12
    });
    const virtualizedItems = computed131(() => virtualizer.value.getVirtualItems().map((item) => {
      return {
        item,
        is: cloneVNode3(slots.default({
          item: rootContext.expandedItems.value[item.index],
          virtualizer: virtualizer.value,
          virtualItem: item
        })[0], {
          "data-index": item.index,
          "style": {
            position: "absolute",
            top: 0,
            left: 0,
            transform: `translateY(${item.start}px)`,
            overflowAnchor: "none"
          }
        })
      };
    }));
    function scrollToIndexAndFocus(index) {
      virtualizer.value.scrollToIndex(index, { align: "start" });
      requestAnimationFrame(() => {
        const item = parentEl.value.querySelector(`[data-index="${index}"]`);
        if (item instanceof HTMLElement) item.focus();
      });
    }
    rootContext.virtualKeydownHook.on((event) => {
      const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
      const isTabKey = event.key === "Tab" && !isMetaKey;
      if (isTabKey) return;
      const intent = MAP_KEY_TO_FOCUS_INTENT[event.key];
      if (["first", "last"].includes(intent)) {
        event.preventDefault();
        const index = intent === "first" ? 0 : rootContext.expandedItems.value.length - 1;
        virtualizer.value.scrollToIndex(index);
        requestAnimationFrame(() => {
          const items = getItems();
          const item = intent === "first" ? items[0] : items[items.length - 1];
          item.ref.focus();
        });
      } else if (intent === "prev" && event.key !== "ArrowUp") {
        const currentElement = getActiveElement();
        const currentIndex = Number(currentElement.getAttribute("data-index"));
        const currentLevel = Number(currentElement.getAttribute("data-indent"));
        const list = rootContext.expandedItems.value.slice(0, currentIndex).map((item, index) => ({
          ...item,
          index
        })).reverse();
        const parentItem = list.find((item) => item.level === currentLevel - 1);
        if (parentItem) scrollToIndexAndFocus(parentItem.index);
      } else if (!intent && !isMetaKey) {
        search.value += event.key;
        const currentIndex = Number(getActiveElement()?.getAttribute("data-index"));
        const currentMatch = optionsWithMetadata.value[currentIndex].textContent;
        const filteredOptions = optionsWithMetadata.value.map((i) => i.textContent);
        const next = getNextMatch(filteredOptions, search.value, currentMatch);
        const nextMatch = optionsWithMetadata.value.find((option) => option.textContent === next);
        if (nextMatch) scrollToIndexAndFocus(nextMatch.index);
      }
      nextTick35(() => {
        if (event.shiftKey && intent) rootContext.handleMultipleReplace(intent, getActiveElement(), getItems, rootContext.expandedItems.value.map((i) => i.value));
      });
    });
    return (_ctx, _cache) => {
      return openBlock363(), createElementBlock16("div", {
        "data-reka-virtualizer": "",
        style: normalizeStyle18({
          position: "relative",
          width: "100%",
          height: `${unref365(virtualizer).getTotalSize()}px`
        })
      }, [(openBlock363(true), createElementBlock16(Fragment12, null, renderList4(virtualizedItems.value, ({ is, item }) => {
        return openBlock363(), createBlock354(resolveDynamicComponent11(is), { key: item.key });
      }), 128))], 4);
    };
  }
});
var TreeVirtualizer_default = TreeVirtualizer_vue_vue_type_script_setup_true_lang_default;

// node_modules/reka-ui/dist/Viewport/Viewport.js
import { Fragment as Fragment13, createElementBlock as createElementBlock17, createTextVNode as createTextVNode33, createVNode as createVNode79, defineComponent as defineComponent375, mergeProps as mergeProps166, openBlock as openBlock364, renderSlot as renderSlot366, toRefs as toRefs61, unref as unref366, withCtx as withCtx359 } from "vue";
var Viewport_vue_vue_type_script_setup_true_lang_default = defineComponent375({
  __name: "Viewport",
  props: {
    nonce: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const { forwardRef } = useForwardExpose();
    const { nonce: propNonce } = toRefs61(props2);
    const nonce = useNonce(propNonce);
    return (_ctx, _cache) => {
      return openBlock364(), createElementBlock17(Fragment13, null, [createVNode79(unref366(Primitive), mergeProps166({
        ..._ctx.$attrs,
        ...props2
      }, {
        ref: unref366(forwardRef),
        "data-reka-viewport": "",
        role: "presentation",
        style: {
          position: "relative",
          flex: 1,
          overflow: "auto"
        }
      }), {
        default: withCtx359(() => [renderSlot366(_ctx.$slots, "default")]),
        _: 3
      }, 16), createVNode79(unref366(Primitive), {
        as: "style",
        nonce: unref366(nonce)
      }, {
        default: withCtx359(() => _cache[0] || (_cache[0] = [createTextVNode33(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-viewport]::-webkit-scrollbar { display: none; } ")])),
        _: 1,
        __: [0]
      }, 8, ["nonce"])], 64);
    };
  }
});
var Viewport_default = Viewport_vue_vue_type_script_setup_true_lang_default;
export {
  AccordionContent_default as AccordionContent,
  AccordionHeader_default as AccordionHeader,
  AccordionItem_default as AccordionItem,
  AccordionRoot_default as AccordionRoot,
  AccordionTrigger_default as AccordionTrigger,
  AlertDialogAction_default as AlertDialogAction,
  AlertDialogCancel_default as AlertDialogCancel,
  AlertDialogContent_default as AlertDialogContent,
  AlertDialogDescription_default as AlertDialogDescription,
  AlertDialogOverlay_default as AlertDialogOverlay,
  AlertDialogPortal_default as AlertDialogPortal,
  AlertDialogRoot_default as AlertDialogRoot,
  AlertDialogTitle_default as AlertDialogTitle,
  AlertDialogTrigger_default as AlertDialogTrigger,
  AspectRatio_default as AspectRatio,
  AvatarFallback_default as AvatarFallback,
  AvatarImage_default as AvatarImage,
  AvatarRoot_default as AvatarRoot,
  CalendarCell_default as CalendarCell,
  CalendarCellTrigger_default as CalendarCellTrigger,
  CalendarGrid_default as CalendarGrid,
  CalendarGridBody_default as CalendarGridBody,
  CalendarGridHead_default as CalendarGridHead,
  CalendarGridRow_default as CalendarGridRow,
  CalendarHeadCell_default as CalendarHeadCell,
  CalendarHeader_default as CalendarHeader,
  CalendarHeading_default as CalendarHeading,
  CalendarNext_default as CalendarNext,
  CalendarPrev_default as CalendarPrev,
  CalendarRoot_default as CalendarRoot,
  CheckboxGroupRoot_default as CheckboxGroupRoot,
  CheckboxIndicator_default as CheckboxIndicator,
  CheckboxRoot_default as CheckboxRoot,
  CollapsibleContent_default as CollapsibleContent,
  CollapsibleRoot_default as CollapsibleRoot,
  CollapsibleTrigger_default as CollapsibleTrigger,
  ComboboxAnchor_default as ComboboxAnchor,
  ComboboxArrow_default as ComboboxArrow,
  ComboboxCancel_default as ComboboxCancel,
  ComboboxContent_default as ComboboxContent,
  ComboboxEmpty_default as ComboboxEmpty,
  ComboboxGroup_default as ComboboxGroup,
  ComboboxInput_default as ComboboxInput,
  ComboboxItem_default as ComboboxItem,
  ComboboxItemIndicator_default as ComboboxItemIndicator,
  ComboboxLabel_default as ComboboxLabel,
  ComboboxPortal_default as ComboboxPortal,
  ComboboxRoot_default as ComboboxRoot,
  ComboboxSeparator_default as ComboboxSeparator,
  ComboboxTrigger_default as ComboboxTrigger,
  ComboboxViewport_default as ComboboxViewport,
  ComboboxVirtualizer_default as ComboboxVirtualizer,
  ConfigProvider_default as ConfigProvider,
  ContextMenuArrow_default as ContextMenuArrow,
  ContextMenuCheckboxItem_default as ContextMenuCheckboxItem,
  ContextMenuContent_default as ContextMenuContent,
  ContextMenuGroup_default as ContextMenuGroup,
  ContextMenuItem_default as ContextMenuItem,
  ContextMenuItemIndicator_default as ContextMenuItemIndicator,
  ContextMenuLabel_default as ContextMenuLabel,
  ContextMenuPortal_default as ContextMenuPortal,
  ContextMenuRadioGroup_default as ContextMenuRadioGroup,
  ContextMenuRadioItem_default as ContextMenuRadioItem,
  ContextMenuRoot_default as ContextMenuRoot,
  ContextMenuSeparator_default as ContextMenuSeparator,
  ContextMenuSub_default as ContextMenuSub,
  ContextMenuSubContent_default as ContextMenuSubContent,
  ContextMenuSubTrigger_default as ContextMenuSubTrigger,
  ContextMenuTrigger_default as ContextMenuTrigger,
  DateFieldInput_default as DateFieldInput,
  DateFieldRoot_default as DateFieldRoot,
  DatePickerAnchor_default as DatePickerAnchor,
  DatePickerArrow_default as DatePickerArrow,
  DatePickerCalendar_default as DatePickerCalendar,
  DatePickerCell_default as DatePickerCell,
  DatePickerCellTrigger_default as DatePickerCellTrigger,
  DatePickerClose_default as DatePickerClose,
  DatePickerContent_default as DatePickerContent,
  DatePickerField_default as DatePickerField,
  DatePickerGrid_default as DatePickerGrid,
  DatePickerGridBody_default as DatePickerGridBody,
  DatePickerGridHead_default as DatePickerGridHead,
  DatePickerGridRow_default as DatePickerGridRow,
  DatePickerHeadCell_default as DatePickerHeadCell,
  DatePickerHeader_default as DatePickerHeader,
  DatePickerHeading_default as DatePickerHeading,
  DatePickerInput_default as DatePickerInput,
  DatePickerNext_default as DatePickerNext,
  DatePickerPrev_default as DatePickerPrev,
  DatePickerRoot_default as DatePickerRoot,
  DatePickerTrigger_default as DatePickerTrigger,
  DateRangeFieldInput_default as DateRangeFieldInput,
  DateRangeFieldRoot_default as DateRangeFieldRoot,
  DateRangePickerAnchor_default as DateRangePickerAnchor,
  DateRangePickerArrow_default as DateRangePickerArrow,
  DateRangePickerCalendar_default as DateRangePickerCalendar,
  DateRangePickerCell_default as DateRangePickerCell,
  DateRangePickerCellTrigger_default as DateRangePickerCellTrigger,
  DateRangePickerClose_default as DateRangePickerClose,
  DateRangePickerContent_default as DateRangePickerContent,
  DateRangePickerField_default as DateRangePickerField,
  DateRangePickerGrid_default as DateRangePickerGrid,
  DateRangePickerGridBody_default as DateRangePickerGridBody,
  DateRangePickerGridHead_default as DateRangePickerGridHead,
  DateRangePickerGridRow_default as DateRangePickerGridRow,
  DateRangePickerHeadCell_default as DateRangePickerHeadCell,
  DateRangePickerHeader_default as DateRangePickerHeader,
  DateRangePickerHeading_default as DateRangePickerHeading,
  DateRangePickerInput_default as DateRangePickerInput,
  DateRangePickerNext_default as DateRangePickerNext,
  DateRangePickerPrev_default as DateRangePickerPrev,
  DateRangePickerRoot_default as DateRangePickerRoot,
  DateRangePickerTrigger_default as DateRangePickerTrigger,
  DialogClose_default as DialogClose,
  DialogContent_default as DialogContent,
  DialogDescription_default as DialogDescription,
  DialogOverlay_default as DialogOverlay,
  DialogPortal_default as DialogPortal,
  DialogRoot_default as DialogRoot,
  DialogTitle_default as DialogTitle,
  DialogTrigger_default as DialogTrigger,
  DropdownMenuArrow_default as DropdownMenuArrow,
  DropdownMenuCheckboxItem_default as DropdownMenuCheckboxItem,
  DropdownMenuContent_default as DropdownMenuContent,
  DropdownMenuGroup_default as DropdownMenuGroup,
  DropdownMenuItem_default as DropdownMenuItem,
  DropdownMenuItemIndicator_default as DropdownMenuItemIndicator,
  DropdownMenuLabel_default as DropdownMenuLabel,
  DropdownMenuPortal_default as DropdownMenuPortal,
  DropdownMenuRadioGroup_default as DropdownMenuRadioGroup,
  DropdownMenuRadioItem_default as DropdownMenuRadioItem,
  DropdownMenuRoot_default as DropdownMenuRoot,
  DropdownMenuSeparator_default as DropdownMenuSeparator,
  DropdownMenuSub_default as DropdownMenuSub,
  DropdownMenuSubContent_default as DropdownMenuSubContent,
  DropdownMenuSubTrigger_default as DropdownMenuSubTrigger,
  DropdownMenuTrigger_default as DropdownMenuTrigger,
  EditableArea_default as EditableArea,
  EditableCancelTrigger_default as EditableCancelTrigger,
  EditableEditTrigger_default as EditableEditTrigger,
  EditableInput_default as EditableInput,
  EditablePreview_default as EditablePreview,
  EditableRoot_default as EditableRoot,
  EditableSubmitTrigger_default as EditableSubmitTrigger,
  FocusScope_default as FocusScope,
  HoverCardArrow_default as HoverCardArrow,
  HoverCardContent_default as HoverCardContent,
  HoverCardPortal_default as HoverCardPortal,
  HoverCardRoot_default as HoverCardRoot,
  HoverCardTrigger_default as HoverCardTrigger,
  Label_default as Label,
  ListboxContent_default as ListboxContent,
  ListboxFilter_default as ListboxFilter,
  ListboxGroup_default as ListboxGroup,
  ListboxGroupLabel_default as ListboxGroupLabel,
  ListboxItem_default as ListboxItem,
  ListboxItemIndicator_default as ListboxItemIndicator,
  ListboxRoot_default as ListboxRoot,
  ListboxVirtualizer_default as ListboxVirtualizer,
  MenubarArrow_default as MenubarArrow,
  MenubarCheckboxItem_default as MenubarCheckboxItem,
  MenubarContent_default as MenubarContent,
  MenubarGroup_default as MenubarGroup,
  MenubarItem_default as MenubarItem,
  MenubarItemIndicator_default as MenubarItemIndicator,
  MenubarLabel_default as MenubarLabel,
  MenubarMenu_default as MenubarMenu,
  MenubarPortal_default as MenubarPortal,
  MenubarRadioGroup_default as MenubarRadioGroup,
  MenubarRadioItem_default as MenubarRadioItem,
  MenubarRoot_default as MenubarRoot,
  MenubarSeparator_default as MenubarSeparator,
  MenubarSub_default as MenubarSub,
  MenubarSubContent_default as MenubarSubContent,
  MenubarSubTrigger_default as MenubarSubTrigger,
  MenubarTrigger_default as MenubarTrigger,
  NavigationMenuContent_default as NavigationMenuContent,
  NavigationMenuIndicator_default as NavigationMenuIndicator,
  NavigationMenuItem_default as NavigationMenuItem,
  NavigationMenuLink_default as NavigationMenuLink,
  NavigationMenuList_default as NavigationMenuList,
  NavigationMenuRoot_default as NavigationMenuRoot,
  NavigationMenuSub_default as NavigationMenuSub,
  NavigationMenuTrigger_default as NavigationMenuTrigger,
  NavigationMenuViewport_default as NavigationMenuViewport,
  NumberFieldDecrement_default as NumberFieldDecrement,
  NumberFieldIncrement_default as NumberFieldIncrement,
  NumberFieldInput_default as NumberFieldInput,
  NumberFieldRoot_default as NumberFieldRoot,
  PaginationEllipsis_default as PaginationEllipsis,
  PaginationFirst_default as PaginationFirst,
  PaginationLast_default as PaginationLast,
  PaginationList_default as PaginationList,
  PaginationListItem_default as PaginationListItem,
  PaginationNext_default as PaginationNext,
  PaginationPrev_default as PaginationPrev,
  PaginationRoot_default as PaginationRoot,
  PinInputInput_default as PinInputInput,
  PinInputRoot_default as PinInputRoot,
  PopoverAnchor_default as PopoverAnchor,
  PopoverArrow_default as PopoverArrow,
  PopoverClose_default as PopoverClose,
  PopoverContent_default as PopoverContent,
  PopoverPortal_default as PopoverPortal,
  PopoverRoot_default as PopoverRoot,
  PopoverTrigger_default as PopoverTrigger,
  Presence_default as Presence,
  Primitive,
  ProgressIndicator_default as ProgressIndicator,
  ProgressRoot_default as ProgressRoot,
  RadioGroupIndicator_default as RadioGroupIndicator,
  RadioGroupItem_default as RadioGroupItem,
  RadioGroupRoot_default as RadioGroupRoot,
  RangeCalendarCell_default as RangeCalendarCell,
  RangeCalendarCellTrigger_default as RangeCalendarCellTrigger,
  RangeCalendarGrid_default as RangeCalendarGrid,
  RangeCalendarGridBody_default as RangeCalendarGridBody,
  RangeCalendarGridHead_default as RangeCalendarGridHead,
  RangeCalendarGridRow_default as RangeCalendarGridRow,
  RangeCalendarHeadCell_default as RangeCalendarHeadCell,
  RangeCalendarHeader_default as RangeCalendarHeader,
  RangeCalendarHeading_default as RangeCalendarHeading,
  RangeCalendarNext_default as RangeCalendarNext,
  RangeCalendarPrev_default as RangeCalendarPrev,
  RangeCalendarRoot_default as RangeCalendarRoot,
  RovingFocusGroup_default as RovingFocusGroup,
  RovingFocusItem_default as RovingFocusItem,
  ScrollAreaCorner_default as ScrollAreaCorner,
  ScrollAreaRoot_default as ScrollAreaRoot,
  ScrollAreaScrollbar_default as ScrollAreaScrollbar,
  ScrollAreaThumb_default as ScrollAreaThumb,
  ScrollAreaViewport_default as ScrollAreaViewport,
  SelectArrow_default as SelectArrow,
  SelectContent_default as SelectContent,
  SelectGroup_default as SelectGroup,
  SelectIcon_default as SelectIcon,
  SelectItem_default as SelectItem,
  SelectItemIndicator_default as SelectItemIndicator,
  SelectItemText_default as SelectItemText,
  SelectLabel_default as SelectLabel,
  SelectPortal_default as SelectPortal,
  SelectRoot_default as SelectRoot,
  SelectScrollDownButton_default as SelectScrollDownButton,
  SelectScrollUpButton_default as SelectScrollUpButton,
  SelectSeparator_default as SelectSeparator,
  SelectTrigger_default as SelectTrigger,
  SelectValue_default as SelectValue,
  SelectViewport_default as SelectViewport,
  Separator_default as Separator,
  SliderRange_default as SliderRange,
  SliderRoot_default as SliderRoot,
  SliderThumb_default as SliderThumb,
  SliderTrack_default as SliderTrack,
  Slot,
  SplitterGroup_default as SplitterGroup,
  SplitterPanel_default as SplitterPanel,
  SplitterResizeHandle_default as SplitterResizeHandle,
  StepperDescription_default as StepperDescription,
  StepperIndicator_default as StepperIndicator,
  StepperItem_default as StepperItem,
  StepperRoot_default as StepperRoot,
  StepperSeparator_default as StepperSeparator,
  StepperTitle_default as StepperTitle,
  StepperTrigger_default as StepperTrigger,
  SwitchRoot_default as SwitchRoot,
  SwitchThumb_default as SwitchThumb,
  TabsContent_default as TabsContent,
  TabsIndicator_default as TabsIndicator,
  TabsList_default as TabsList,
  TabsRoot_default as TabsRoot,
  TabsTrigger_default as TabsTrigger,
  TagsInputClear_default as TagsInputClear,
  TagsInputInput_default as TagsInputInput,
  TagsInputItem_default as TagsInputItem,
  TagsInputItemDelete_default as TagsInputItemDelete,
  TagsInputItemText_default as TagsInputItemText,
  TagsInputRoot_default as TagsInputRoot,
  TimeFieldInput_default as TimeFieldInput,
  TimeFieldRoot_default as TimeFieldRoot,
  ToastAction_default as ToastAction,
  ToastClose_default as ToastClose,
  ToastDescription_default as ToastDescription,
  ToastPortal_default as ToastPortal,
  ToastProvider_default as ToastProvider,
  ToastRoot_default as ToastRoot,
  ToastTitle_default as ToastTitle,
  ToastViewport_default as ToastViewport,
  Toggle_default as Toggle,
  ToggleGroupItem_default as ToggleGroupItem,
  ToggleGroupRoot_default as ToggleGroupRoot,
  ToolbarButton_default as ToolbarButton,
  ToolbarLink_default as ToolbarLink,
  ToolbarRoot_default as ToolbarRoot,
  ToolbarSeparator_default as ToolbarSeparator,
  ToolbarToggleGroup_default as ToolbarToggleGroup,
  ToolbarToggleItem_default as ToolbarToggleItem,
  TooltipArrow_default as TooltipArrow,
  TooltipContent_default as TooltipContent,
  TooltipPortal_default as TooltipPortal,
  TooltipProvider_default as TooltipProvider,
  TooltipRoot_default as TooltipRoot,
  TooltipTrigger_default as TooltipTrigger,
  TreeItem_default as TreeItem,
  TreeRoot_default as TreeRoot,
  TreeVirtualizer_default as TreeVirtualizer,
  Viewport_default as Viewport,
  VisuallyHidden_default as VisuallyHidden,
  createContext,
  injectAccordionItemContext,
  injectAccordionRootContext,
  injectAlertDialogContentContext,
  injectAvatarRootContext,
  injectCalendarRootContext,
  injectCheckboxGroupRootContext,
  injectCheckboxRootContext,
  injectCollapsibleRootContext,
  injectComboboxGroupContext,
  injectListboxItemContext as injectComboboxItemContext,
  injectComboboxRootContext,
  injectConfigProviderContext,
  injectContextMenuRootContext,
  injectDateFieldRootContext,
  injectDatePickerRootContext,
  injectDateRangeFieldRootContext,
  injectDateRangePickerRootContext,
  injectDialogRootContext,
  injectDropdownMenuRootContext,
  injectEditableRootContext,
  injectHoverCardRootContext,
  injectListboxGroupContext,
  injectListboxItemContext,
  injectListboxRootContext,
  injectMenubarMenuContext,
  injectMenubarRootContext,
  injectNavigationMenuContext,
  injectNavigationMenuItemContext,
  injectNumberFieldRootContext,
  injectPaginationRootContext,
  injectPinInputRootContext,
  injectPopoverRootContext,
  injectProgressRootContext,
  injectRadioGroupItemContext,
  injectRadioGroupRootContext,
  injectRangeCalendarRootContext,
  injectScrollAreaRootContext,
  injectScrollAreaScrollbarContext,
  injectSelectGroupContext,
  injectSelectItemContext,
  injectSelectRootContext,
  injectSliderRootContext,
  injectPanelGroupContext as injectSplitterGroupContext,
  injectStepperItemContext,
  injectStepperRootContext,
  injectSwitchRootContext,
  injectTabsRootContext,
  injectTagsInputItemContext,
  injectTagsInputRootContext,
  injectTimeFieldRootContext,
  injectToastProviderContext,
  injectToggleGroupRootContext,
  injectToolbarRootContext,
  injectTooltipProviderContext,
  injectTooltipRootContext,
  injectTreeRootContext,
  useBodyScrollLock,
  useDateFormatter,
  useEmitAsProps,
  useFilter,
  useForwardExpose,
  useForwardProps,
  useForwardPropsEmits,
  useId2 as useId,
  useStateMachine,
  withDefault
};
//# sourceMappingURL=reka-ui.js.map
