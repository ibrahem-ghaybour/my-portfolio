import { TresCamera, TresContextWithClock } from '../types/';
import { PointerEvent } from '@pmndrs/pointer-events';
import { RendererOptions, TresContext } from '../composables';
import * as THREE from 'three';
export interface TresCanvasProps extends RendererOptions {
    /**
     * Custom camera instance to use as main camera
     * If not provided, a default PerspectiveCamera will be created
     */
    camera?: TresCamera;
    /**
     * Whether the canvas should be sized to the window
     * When true, canvas will be fixed positioned and full viewport size
     * @default false
     */
    windowSize?: boolean;
    /**
     * Whether to enable the provide/inject bridge between Vue and TresJS
     * When true, Vue's provide/inject will work across the TresJS boundary
     * @default true
     */
    enableProvideBridge?: boolean;
}
declare const _default: __VLS_WithTemplateSlots<import('vue').DefineComponent<TresCanvasProps, {
    context: import('vue').ShallowRef<TresContext | null, TresContext | null>;
    dispose: () => void;
}, {}, {}, {}, import('vue').ComponentOptionsMixin, import('vue').ComponentOptionsMixin, {
    render: (context: TresContext) => any;
    pointermove: (event: PointerEvent<MouseEvent>) => any;
    pointercancel: (event: PointerEvent<MouseEvent>) => any;
    pointerdown: (event: PointerEvent<MouseEvent>) => any;
    pointerup: (event: PointerEvent<MouseEvent>) => any;
    pointerenter: (event: PointerEvent<MouseEvent>) => any;
    pointerleave: (event: PointerEvent<MouseEvent>) => any;
    pointerover: (event: PointerEvent<MouseEvent>) => any;
    pointerout: (event: PointerEvent<MouseEvent>) => any;
    click: (event: PointerEvent<MouseEvent>) => any;
    dblclick: (event: PointerEvent<MouseEvent>) => any;
    contextmenu: (event: PointerEvent<MouseEvent>) => any;
    wheel: (event: PointerEvent<MouseEvent>) => any;
    lostpointercapture: (event: PointerEvent<MouseEvent>) => any;
    loop: (context: TresContextWithClock) => any;
    ready: (context: TresContext) => any;
    pointermissed: (event: PointerEvent<MouseEvent>) => any;
    beforeLoop: (context: TresContextWithClock) => any;
}, string, import('vue').PublicProps, Readonly<TresCanvasProps> & Readonly<{
    onRender?: ((context: TresContext) => any) | undefined;
    onPointermove?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onPointercancel?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onPointerdown?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onPointerup?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onPointerenter?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onPointerleave?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onPointerover?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onPointerout?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onClick?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onDblclick?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onContextmenu?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onWheel?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onLostpointercapture?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onLoop?: ((context: TresContextWithClock) => any) | undefined;
    onReady?: ((context: TresContext) => any) | undefined;
    onPointermissed?: ((event: PointerEvent<MouseEvent>) => any) | undefined;
    onBeforeLoop?: ((context: TresContextWithClock) => any) | undefined;
}>, {
    antialias: boolean;
    stencil: boolean;
    depth: boolean;
    logarithmicDepthBuffer: boolean;
    preserveDrawingBuffer: boolean;
    alpha: boolean;
    failIfMajorPerformanceCaveat: boolean;
    clearColor: THREE.ColorRepresentation;
    clearAlpha: number;
    shadows: boolean;
    toneMapping: THREE.ToneMapping;
    shadowMapType: THREE.ShadowMapType;
    useLegacyLights: boolean;
    renderMode: "always" | "on-demand" | "manual";
    windowSize: boolean;
    enableProvideBridge: boolean;
}, {}, {}, {}, string, import('vue').ComponentProvideOptions, false, {
    canvasRef: HTMLCanvasElement;
}, HTMLCanvasElement>, Readonly<{
    default: () => any;
}> & {
    default: () => any;
}>;
export default _default;
type __VLS_WithTemplateSlots<T, S> = T & {
    new (): {
        $slots: S;
    };
};
