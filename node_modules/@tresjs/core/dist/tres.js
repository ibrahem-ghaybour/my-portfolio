/**
 * name: @tresjs/core
 * version: v5.1.0
 * (c) 2025
 * description: Declarative ThreeJS using Vue Components
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
import { reactive as Io, toValue as I, watch as At, onUnmounted as ie, defineComponent as ot, renderSlot as Do, unref as ke, ref as Ae, computed as J, watchEffect as $, readonly as zt, shallowRef as it, isRef as me, useSlots as ko, getCurrentInstance as $t, onMounted as Kt, createElementBlock as xo, openBlock as Ro, normalizeStyle as Lo, normalizeClass as Fo, createRenderer as Mo, h as Wt, provide as qe, Fragment as No } from "vue";
import * as vr from "three";
import { Layers as Vo, Scene as yr, MathUtils as Bo, Clock as Uo, WebGLRenderer as Cr, Mesh as He, Material as Ho, Vector3 as D, Vector2 as Y, Ray as st, SphereGeometry as jo, Object3D as je, Matrix4 as Te, BufferAttribute as br, Triangle as wr, Line3 as zo, Plane as ze, Raycaster as $o, Quaternion as at, Sphere as Ko, MeshBasicMaterial as Ar, DoubleSide as Wo, Color as xe, PCFSoftShadowMap as Go, ACESFilmicToneMapping as Yo, PerspectiveCamera as qo, ArrowHelper as Xo, Line as Qo, BufferGeometry as Gt, Float32BufferAttribute as Yt, LineBasicMaterial as Zo, BackSide as Jo, HemisphereLightHelper as ei, SpotLightHelper as ti, PointLightHelper as ni, DirectionalLightHelper as ri } from "three";
import { useAsyncState as oi, whenever as qt, tryOnScopeDispose as ii, createEventHook as Ee, useRafFn as Tr, useDevicePixelRatio as si, useTimeout as ai, unrefElement as ui, useWindowSize as li, useElementSize as ci, refDebounced as Xt, createInjectionState as fi, useFps as di, useMemory as pi, promiseTimeout as hi } from "@vueuse/core";
const _i = "@tresjs/core", mi = "module", gi = "5.1.0", Ei = "pnpm@10.17.0", vi = "Declarative ThreeJS using Vue Components", yi = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)", Ci = "MIT", bi = { type: "git", url: "git+https://github.com/Tresjs/tres.git", directory: "packages/core" }, wi = ["vue", "3d", "threejs", "three", "threejs-vue"], Ai = !1, Ti = { ".": { types: "./dist/index.d.ts", import: "./dist/tres.js", default: "./dist/tres.js" }, "./components": { types: "./dist/src/components/index.d.ts" }, "./composables": { types: "./dist/src/composables/index.d.ts" }, "./types": { types: "./dist/src/types/index.d.ts" }, "./utils": { types: "./dist/src/utils/index.d.ts" }, "./*": "./*" }, Oi = "./dist/tres.js", Si = "./dist/index.d.ts", Pi = ["*.d.ts", "dist"], Ii = { access: "public" }, Di = { build: "vite build", test: "vitest", "test:ci": "vitest run", "test:ui": "vitest --ui --coverage.enabled=true", coverage: "vitest run --coverage", lint: "eslint .", "lint:fix": "eslint . --fix", typecheck: "vue-tsc --noEmit" }, ki = { three: ">=0.133", vue: ">=3.4" }, xi = { "@pmndrs/pointer-events": "^6.6.17", "@vue/devtools-api": "^7.7.2", "@vueuse/core": "catalog:", radashi: "^12.6.2" }, Ri = { "@tresjs/eslint-config": "workspace:*", "@types/three": "catalog:", "@typescript-eslint/eslint-plugin": "catalog:", "@typescript-eslint/parser": "catalog:", "@vitejs/plugin-vue": "catalog:", "@vitest/coverage-v8": "3.2.4", "@vitest/ui": "catalog:", "@vue/test-utils": "catalog:", eslint: "catalog:", "eslint-plugin-vue": "catalog:", jsdom: "catalog:", kolorist: "catalog:", pathe: "catalog:", "rollup-plugin-analyzer": "catalog:", "rollup-plugin-copy": "^3.5.0", "rollup-plugin-visualizer": "catalog:", three: "catalog:", vite: "catalog:", "vite-plugin-banner": "catalog:", "vite-plugin-dts": "catalog:", "vite-plugin-inspect": "^11.3.3", vitest: "catalog:", vue: "catalog:", "vue-demi": "^0.14.10", "vue-tsc": "catalog:" }, Li = { implicitDependencies: ["!@tresjs/core-*"] }, Fi = {
  name: _i,
  type: mi,
  version: gi,
  packageManager: Ei,
  description: vi,
  author: yi,
  license: Ci,
  repository: bi,
  keywords: wi,
  sideEffects: Ai,
  exports: Ti,
  module: Oi,
  types: Si,
  files: Pi,
  publishConfig: Ii,
  scripts: Di,
  peerDependencies: ki,
  dependencies: xi,
  devDependencies: Ri,
  nx: Li
};
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Mi(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const n of e.split(","))
    t[n] = 1;
  return (n) => n in t;
}
const Ni = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Vi = /* @__PURE__ */ Mi(Ni);
function Qt(e) {
  var t;
  const n = ((t = e?.replace(/([A-Z])+/g, Bi)) == null ? void 0 : t.split(/(?=[A-Z])|[\.\-\s_]/).map((r) => r.toLowerCase())) ?? [];
  return n.length === 0 ? "" : n.length === 1 ? n[0] : n.reduce((r, o) => `${r}${o.charAt(0).toUpperCase()}${o.slice(1)}`);
}
function Bi(e) {
  if (!e || e.length === 0)
    return "";
  const t = e.toLowerCase();
  return t.substring(0, 1).toUpperCase() + t.substring(1, t.length);
}
function Or(e, t) {
  if (Object.is(e, t))
    return !0;
  if (e instanceof Date && t instanceof Date)
    return e.getTime() === t.getTime();
  if (e instanceof RegExp && t instanceof RegExp)
    return e.toString() === t.toString();
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  const n = Reflect.ownKeys(e), r = Reflect.ownKeys(t);
  if (n.length !== r.length)
    return !1;
  for (let o = 0; o < n.length; o++)
    if (!Reflect.has(t, n[o]) || !Or(e[n[o]], t[n[o]]))
      return !1;
  return !0;
}
function Q(e) {
  return typeof e == "function";
}
function Sr(e) {
  return typeof e == "number" && !Number.isNaN(e);
}
function Tt(e) {
  return Ui(e, "[object Object]");
}
function Ot(e) {
  return typeof e == "string";
}
function Ui(e, t) {
  return Object.prototype.toString.call(e) === t;
}
function ut(e) {
  return typeof e > "u";
}
const B = (e) => (t) => Tt(t) && e in t && !!t[e], lt = B("isObject3D"), $e = B("isMesh"), Pr = B("isCamera"), Hi = B("isOrthographicCamera"), Ir = B("isPerspectiveCamera"), Dr = B("isColor"), ji = (e) => Ot(e) || Sr(e) || Dr(e), Zt = (e) => e instanceof Vo, kr = B("isBufferGeometry"), xr = B("isMaterial"), Rr = B("isLight"), Lr = B("isFog"), Fr = B("isScene"), cl = B("isGroup"), ct = (e) => e !== null && typeof e == "object" && "set" in e && typeof e.set == "function", zi = (e) => ct(e) && "copy" in e && typeof e.copy == "function", $i = (e) => !!e?.constructor, re = (e) => Pr(e) || Hi(e) || Ir(e), Ki = (e) => (
  // NOTE: TresObject is currently defined as
  // TresObject3D | THREE.BufferGeometry | THREE.Material | THREE.Fog
  lt(e) || kr(e) || xr(e) || Lr(e)
), Wi = B("isPrimitive"), Gi = (e) => Ki(e) && "__tres" in e, Yi = (e, t) => {
  let n = 0;
  for (let r = 0; r < e.length; r++)
    t(e[r], r) && (e[n] = e[r], n++);
  return e.length = n, e;
}, fl = !0, Fe = "[TresJS ▲ ■ ●] ";
function Jt(...e) {
  typeof e[0] == "string" ? e[0] = Fe + e[0] : e.unshift(Fe), console.error(...e);
}
function Me(...e) {
  typeof e[0] == "string" ? e[0] = Fe + e[0] : e.unshift(Fe), console.warn(...e);
}
function dl(e, t) {
}
function en(e) {
  ((n) => "map" in n && !!n.map)(e) && e.map.dispose(), e.dispose();
}
function Ne(e) {
  if (e.parent && e.removeFromParent?.(), delete e.__tres, [...e.children].forEach((n) => Ne(n)), !(e instanceof yr)) {
    const n = e;
    e && e.dispose?.(), n.geometry && n.geometry.dispose(), Array.isArray(n.material) ? n.material.forEach((r) => en(r)) : n.material && en(n.material);
  }
}
function Ve(e, t) {
  let n = e;
  if (t.includes("-")) {
    const r = t.split("-");
    let o = r.shift();
    for (; n && r.length; )
      o in n ? (n = n[o], o = r.shift()) : o = tn(o, r.shift());
    return { target: n, key: tn(o, ...r) };
  } else
    return { target: n, key: t };
}
function tn(...e) {
  return e.map((t, n) => n === 0 ? t : t.charAt(0).toUpperCase() + t.slice(1)).join("");
}
function qi(e, t, n) {
  const r = /-\d+$/;
  if (Ot(n)) {
    if (r.test(n)) {
      const s = n.replace(r, ""), { target: a, key: u } = Ve(e, s);
      if (!Array.isArray(a[u])) {
        const l = a[u], c = [];
        c.__tresDetach = () => {
          c.every((f) => ut(f)) && (a[u] = l);
        }, a[u] = c;
      }
    }
    const { target: o, key: i } = Ve(e, n);
    t.__tres.previousAttach = o[i], o[i] = se(t);
  } else
    t.__tres.previousAttach = n(e, t);
}
function Xi(e, t, n) {
  if (Ot(n)) {
    const { target: r, key: o } = Ve(e, n), i = t.__tres.previousAttach;
    i === void 0 ? delete r[o] : r[o] = i, "__tresDetach" in r && r.__tresDetach();
  } else
    t.__tres?.previousAttach?.(e, t);
  delete t.__tres?.previousAttach;
}
function X(e, t, n) {
  const r = e;
  return r.__tres = {
    type: "unknown",
    root: n,
    memoizedProps: {},
    objects: [],
    parent: null,
    previousAttach: null,
    ...t
  }, r.__tres.attach || (xr(r) ? r.__tres.attach = "material" : kr(r) ? r.__tres.attach = "geometry" : Lr(r) && (r.__tres.attach = "fog")), r;
}
function ft(e) {
  const t = e?.__tres?.root;
  t?.renderer && t.renderer.canBeInvalidated.value && t.renderer.invalidate();
}
function Qi(e, t, n, r, o) {
  const i = [...t.__tres.objects], s = se(t);
  if (e = se(e), s === e)
    return !0;
  const a = X(e, t.__tres ?? {}, o), u = t.parent ?? t.__tres.parent ?? null, l = { ...t.__tres.memoizedProps };
  delete l.object;
  for (const c of i)
    Mr(c, o), Nr(c, o);
  s.__tres.objects = [], r.remove(t);
  for (const [c, f] of Object.entries(l))
    r.patchProp(a, c, a[c], f);
  n(e), r.insert(t, u);
  for (const c of i)
    r.insert(c, t);
  return !0;
}
function se(e) {
  if (Wi(e)) {
    const t = e;
    return t.object.__tres = t.__tres, t.object;
  } else
    return e;
}
function Mr(e, t) {
  const n = e.__tres?.parent || t.scene.value;
  e.__tres && (e.__tres.parent = null), n && n.__tres && "objects" in n.__tres && Yi(n.__tres.objects, (r) => r !== e), e.__tres?.attach ? Xi(n, e, e.__tres.attach) : (e.parent?.remove?.(se(e)), e.parent = null);
}
function Nr(e, t) {
  e.traverse?.((n) => {
    re(n) && t.camera.deregisterCamera(n);
  }), re(e) && t.camera.deregisterCamera(e), ft(e);
}
function Zi(e, t, n) {
  const r = new e(n?.manager), o = Io({
    loaded: 0,
    total: 0,
    percentage: 0
  });
  n?.extensions && n.extensions(r);
  const i = I(t), s = oi(
    (u) => new Promise((l, c) => {
      const f = u || i || "";
      r.load(f, (h) => {
        l(h);
      }, (h) => {
        o.loaded = h.loaded, o.total = h.total, o.percentage = o.loaded / o.total * 100;
      }, (h) => {
        c(h);
      });
    }),
    n?.initialValue ?? null,
    {
      ...n?.asyncOptions,
      immediate: n?.asyncOptions?.immediate ?? !0
    }
  ), a = At(() => I(t), (u) => {
    if (u) {
      const l = s.state.value;
      l && typeof l == "object" && "scene" in l && l.scene && Ne(l.scene), s.execute(0, u);
    }
  });
  return ie(() => {
    a();
    const u = s.state.value;
    u && typeof u == "object" && "scene" in u && u.scene && Ne(u.scene);
  }), {
    ...s,
    load: (u) => {
      s.execute(0, u);
    },
    progress: o
  };
}
const pl = /* @__PURE__ */ ot({
  __name: "component",
  props: {
    loader: {},
    path: {},
    manager: {}
  },
  emits: ["loaded", "error"],
  setup(e, { emit: t }) {
    const n = e, r = t, { state: o, isLoading: i, error: s } = Zi(n.loader, n.path, { manager: n.manager });
    return qt(s, (a) => {
      a && r("error", a);
    }), qt(o, (a) => {
      a && r("loaded", a);
    }), (a, u) => Do(a.$slots, "default", {
      state: ke(o),
      isLoading: ke(i),
      error: ke(s)
    });
  }
}), Ji = ({ sizes: e }) => {
  const t = Ae([]), n = J(() => t.value[0]), r = (s) => {
    const a = Pr(s) ? s : t.value.find((l) => l.uuid === s);
    if (!a)
      return;
    const u = t.value.filter(({ uuid: l }) => l !== a.uuid);
    t.value = [a, ...u];
  }, o = (s, a = !1) => {
    t.value.some(({ uuid: u }) => u === s.uuid) || (t.value.push(s), a && r(s.uuid));
  }, i = (s) => {
    t.value = t.value.filter(({ uuid: a }) => a !== s.uuid);
  };
  return $(() => {
    e.aspectRatio.value && t.value.forEach((s) => {
      Ir(s) && (s.aspect = e.aspectRatio.value, s.updateProjectionMatrix());
    });
  }), {
    activeCamera: n,
    cameras: t,
    registerCamera: o,
    deregisterCamera: i,
    setActiveCamera: r
  };
};
function es(e) {
  const t = { nodes: {}, materials: {}, meshes: {} };
  return e && e.traverse((n) => {
    n.name && (t.nodes[n.name] = n), $e(n) && (t.meshes[n.name] || (t.meshes[n.name] = n), (Array.isArray(n.material) ? n.material : [n.material]).forEach((r) => {
      r.name && !t.materials[r.name] && (t.materials[r.name] = r);
    }));
  }), t;
}
const hl = (e) => J(() => {
  const t = I(e);
  if (t)
    return es(t);
});
function nn() {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set();
  let n = 0, r = !1;
  const o = () => {
    const l = Array.from(e.entries()).sort((c, f) => {
      const h = c[1].priority - f[1].priority;
      return h === 0 ? c[1].addI - f[1].addI : h;
    });
    t.clear(), l.forEach((c) => t.add(c[0]));
  }, i = (l) => {
    e.delete(l), t.delete(l);
  };
  return { on: (l, c = 0) => {
    e.set(l, { priority: c, addI: n++ });
    const f = () => i(l);
    return ii(f), r = !0, {
      off: f
    };
  }, off: i, trigger: (...l) => (r && (o(), r = !1), Promise.all(
    Array.from(t).map((c) => c(...l))
  )), dispose: () => {
    e.clear(), t.clear();
  }, get count() {
    return e.size;
  } };
}
const dt = Ae({}), pt = (e) => Object.assign(dt.value, e), ts = (e, t, n) => {
  if (!Q(e.setPixelRatio))
    return;
  let r = 0;
  if (n && Array.isArray(n) && n.length >= 2) {
    const [o, i] = n;
    r = Bo.clamp(t, o, i);
  } else Sr(n) ? r = n : r = t;
  r !== e.getPixelRatio?.() && e.setPixelRatio(r);
}, ns = (e) => {
  const t = new Uo(), n = {
    before: Ee(),
    after: Ee()
  }, { pause: r, resume: o, isActive: i } = Tr(() => {
    const u = () => ({
      delta: t.getDelta(),
      elapsed: t.elapsedTime
    });
    n.before.trigger(u()), e(), n.after.trigger(u());
  }, {
    immediate: !1
  });
  return {
    start: () => {
      t.start(), o();
    },
    stop: () => {
      t.stop(), r();
    },
    isActive: i,
    onBeforeLoop: n.before.on,
    onLoop: n.after.on
  };
};
function rs({
  scene: e,
  canvas: t,
  options: n,
  contextParts: { sizes: r, camera: o }
}) {
  const s = Q(n.renderer) ? n.renderer({
    sizes: r,
    scene: e,
    camera: o,
    canvas: t
  }) : new Cr({
    ...n,
    canvas: ui(t)
  }), a = Ae(I(n.renderMode) === "manual" ? 0 : 1), u = 60, l = J(() => I(n.renderMode) === "on-demand" && a.value === 0), c = () => e.value.traverse((E) => {
    E instanceof He && E.material instanceof Ho && (E.material.needsUpdate = !0);
  }), f = (E = 1) => {
    l.value && (a.value = Math.min(u, a.value + E));
  }, h = () => {
    if (I(n.renderMode) !== "manual")
      throw new Error("advance can only be called in manual render mode.");
    a.value = 1;
  }, d = () => {
    I(n.renderMode) === "on-demand" && f();
  }, _ = J(() => I(n.renderMode) === "always"), v = (E) => Tt(E) && "isRenderer" in E && !!E.isRenderer, p = Ee();
  let g = !1;
  v(s) && (s.init(), p.trigger(s));
  const C = Ee(), b = () => {
    a.value = _.value ? 1 : Math.max(0, a.value - 1), C.trigger(s);
  };
  let P = (E) => {
    o.activeCamera.value && (s.render(e.value, o.activeCamera.value), E());
  };
  const M = (E) => {
    P = E;
  }, A = ns(() => {
    a.value && P(b);
  });
  p.on(A.start), At([r.width, r.height], () => {
    s.setSize(r.width.value, r.height.value), !g && s.domElement.width && s.domElement.height && (p.trigger(s), g = !0), d();
  }, {
    immediate: !0
  });
  const { pixelRatio: O } = si();
  $(() => {
    ts(s, O.value, I(n.dpr));
  }), I(n.renderMode) === "on-demand" && f(), I(n.renderMode) === "manual" && ai(100, {
    callback: h
  });
  const T = J(() => {
    const E = I(n.clearColor), x = I(n.clearAlpha), R = typeof E == "string" && E.length === 9 && E.startsWith("#");
    return R && x !== void 0 && Me(`clearColor with alpha (e.g. ${E}) and clearAlpha cannot both be set, using clearColor as source of truth`), R ? {
      alpha: Number.parseInt(E.slice(7, 9), 16) / 255,
      color: E.slice(0, 7)
    } : {
      alpha: x,
      color: E
    };
  });
  return $(() => {
    const E = T.value;
    E.color === void 0 || E.alpha === void 0 || s.setClearColor(E.color, E.alpha);
  }), $(() => {
    const E = n.toneMapping;
    E && (s.toneMapping = E);
  }), $(() => {
    const E = n.toneMappingExposure;
    E && (s.toneMappingExposure = E);
  }), $(() => {
    const E = n.outputColorSpace;
    E && (s.outputColorSpace = E);
  }), $(() => {
    const E = n.shadows;
    E !== void 0 && (s.shadowMap.enabled = E, c());
  }), $(() => {
    const E = n.shadowMapType;
    E !== void 0 && (s.shadowMap.type = E, c());
  }), ie(() => {
    s.dispose(), "forceContextLoss" in s && s.forceContextLoss();
  }), {
    loop: A,
    instance: s,
    advance: h,
    onReady: p.on,
    onRender: C.on,
    invalidate: f,
    canBeInvalidated: l,
    mode: I(n.renderMode),
    replaceRenderFunction: M
  };
}
function os(e, t, n = 10) {
  const r = I(e) ? li() : ci(J(() => I(t).parentElement)), o = zt(Xt(r.width, n)), i = zt(Xt(r.height, n)), s = J(() => o.value / i.value);
  return {
    height: i,
    width: o,
    aspectRatio: s
  };
}
class is {
  nativeEvent;
  NONE = 0;
  CAPTURING_PHASE = 1;
  AT_TARGET = 2;
  BUBBLING_PHASE = 3;
  relatedTarget = null;
  get altKey() {
    return this.getFromNative("altKey", !1);
  }
  get button() {
    return this.getFromNative("button", 0);
  }
  get buttons() {
    return this.getFromNative("buttons", 0);
  }
  get clientX() {
    return this.getFromNative("clientX", 0);
  }
  get clientY() {
    return this.getFromNative("clientY", 0);
  }
  get ctrlKey() {
    return this.getFromNative("ctrlKey", !1);
  }
  get layerX() {
    return this.getFromNative("layerX", 0);
  }
  get layerY() {
    return this.getFromNative("layerY", 0);
  }
  get metaKey() {
    return this.getFromNative("metaKey", !1);
  }
  get movementX() {
    return this.getFromNative("movementX", 0);
  }
  get movementY() {
    return this.getFromNative("movementY", 0);
  }
  get offsetX() {
    return this.getFromNative("offsetX", 0);
  }
  get offsetY() {
    return this.getFromNative("offsetY", 0);
  }
  get pageX() {
    return this.getFromNative("pageX", 0);
  }
  get pageY() {
    return this.getFromNative("pageY", 0);
  }
  get screenX() {
    return this.getFromNative("screenX", 0);
  }
  get screenY() {
    return this.getFromNative("screenY", 0);
  }
  get shiftKey() {
    return this.getFromNative("shiftKey", !1);
  }
  get x() {
    return this.getFromNative("x", 0);
  }
  get y() {
    return this.getFromNative("y", 0);
  }
  get detail() {
    return this.getFromNative("detail", 0);
  }
  get view() {
    return this.getFromNative("view", null);
  }
  get which() {
    return this.getFromNative("which", 0);
  }
  get cancelBubble() {
    return this.getFromNative("cancelBubble", !1);
  }
  get composed() {
    return this.getFromNative("composed", !1);
  }
  get eventPhase() {
    return this.getFromNative("eventPhase", 0);
  }
  get isTrusted() {
    return this.getFromNative("isTrusted", !1);
  }
  get returnValue() {
    return this.getFromNative("returnValue", !1);
  }
  get timeStamp() {
    return this.getFromNative("timeStamp", 0);
  }
  get cancelable() {
    return this.getFromNative("cancelable", !1);
  }
  get defaultPrevented() {
    return this.getFromNative("defaultPrevented", !1);
  }
  constructor(t) {
    this.nativeEvent = t;
  }
  getFromNative(t, n) {
    return t in this.nativeEvent ? this.nativeEvent[t] : n;
  }
}
const Xe = new D();
class L extends is {
  type;
  bubbles;
  internalPointer;
  intersection;
  camera;
  currentObject;
  object;
  propagationState;
  //--- pointer events data
  get pointerId() {
    return this.internalPointer.id;
  }
  get pointerType() {
    return this.internalPointer.type;
  }
  get pointerState() {
    return this.internalPointer.state;
  }
  //--- intersection data
  get distance() {
    return this.intersection.distance;
  }
  get distanceToRay() {
    return this.intersection.distanceToRay;
  }
  get point() {
    return this.intersection.point;
  }
  get index() {
    return this.intersection.index;
  }
  get face() {
    return this.intersection.face;
  }
  get faceIndex() {
    return this.intersection.faceIndex;
  }
  get uv() {
    return this.intersection.uv;
  }
  get uv1() {
    return this.intersection.uv1;
  }
  get normal() {
    return this.intersection.normal;
  }
  get instanceId() {
    return this.intersection.instanceId;
  }
  get pointOnLine() {
    return this.intersection.pointOnLine;
  }
  get batchId() {
    return this.intersection.batchId;
  }
  get pointerPosition() {
    return this.intersection.pointerPosition;
  }
  get pointerQuaternion() {
    return this.intersection.pointerQuaternion;
  }
  get pointOnFace() {
    return this.intersection.pointOnFace;
  }
  get localPoint() {
    return this.intersection.localPoint;
  }
  get details() {
    return this.intersection.details;
  }
  /** same as object */
  get target() {
    return this.object;
  }
  /** same as currentObject */
  get currentTarget() {
    return this.currentObject;
  }
  /** same as currentObject */
  get eventObject() {
    return this.currentObject;
  }
  /** same as object */
  get srcElement() {
    return this.currentObject;
  }
  _pointer;
  get pointer() {
    return this._pointer == null && (Xe.copy(this.intersection.point).project(this.camera), this._pointer = new Y(Xe.x, Xe.y)), this._pointer;
  }
  _ray;
  get ray() {
    if (this._ray != null)
      return this._ray;
    switch (this.intersection.details.type) {
      case "screen-ray":
      case "ray":
      case "sphere":
        return this._ray = new st(this.intersection.pointerPosition, new D(0, 0, -1).applyQuaternion(this.intersection.pointerQuaternion));
      case "lines":
        return this._ray = new st(this.intersection.details.line.start, this.intersection.details.line.end.clone().sub(this.intersection.details.line.start).normalize());
    }
  }
  _intersections = [];
  get intersections() {
    return this._intersections == null && (this._intersections = [{ ...this.intersection, eventObject: this.currentObject }]), this._intersections;
  }
  _unprojectedPoint;
  get unprojectedPoint() {
    if (this._unprojectedPoint == null) {
      const t = this.pointer;
      this._unprojectedPoint = new D(t.x, t.y, 0).unproject(this.camera);
    }
    return this._unprojectedPoint;
  }
  get stopped() {
    return this.propagationState.stoppedImmediate || this.propagationState.stopped;
  }
  get stoppedImmediate() {
    return this.propagationState.stoppedImmediate;
  }
  get delta() {
    throw new Error("not supported");
  }
  constructor(t, n, r, o, i, s, a = i.object, u = a, l = {
    stopped: !n,
    stoppedImmediate: !1
  }) {
    super(r), this.type = t, this.bubbles = n, this.internalPointer = o, this.intersection = i, this.camera = s, this.currentObject = a, this.object = u, this.propagationState = l;
  }
  stopPropagation() {
    this.propagationState.stopped = !0;
  }
  stopImmediatePropagation() {
    this.propagationState.stoppedImmediate = !0;
  }
  /**
   * for internal use
   */
  retarget(t) {
    return new L(this.type, this.bubbles, this.nativeEvent, this.internalPointer, this.intersection, this.camera, t, this.target, this.propagationState);
  }
}
class Be extends L {
  get deltaX() {
    return this.nativeEvent.deltaX;
  }
  get deltaY() {
    return this.nativeEvent.deltaY;
  }
  get deltaZ() {
    return this.nativeEvent.deltaZ;
  }
  constructor(t, n, r, o, i, s) {
    super("wheel", !0, t, n, r, o, i, s);
  }
  /**
   * for internal use
   */
  retarget(t) {
    return new Be(this.nativeEvent, this.internalPointer, this.intersection, this.camera, t, this.target);
  }
}
function N(e) {
  Vr(e, e.currentObject);
}
function Vr(e, t) {
  if (t == null)
    return;
  const n = as(t, e.type);
  if (n != null && n.length > 0) {
    const r = e.retarget(t), o = n.length;
    for (let i = 0; i < o && !r.stoppedImmediate; i++)
      n[i](r);
  }
  e.stopped || Vr(e, t.parent);
}
const Br = {
  click: "onClick",
  contextmenu: "onContextMenu",
  dblclick: "onDoubleClick",
  pointercancel: "onPointerCancel",
  pointerdown: "onPointerDown",
  pointerenter: "onPointerEnter",
  pointerleave: "onPointerLeave",
  pointermove: "onPointerMove",
  pointerout: "onPointerOut",
  pointerover: "onPointerOver",
  pointerup: "onPointerUp",
  wheel: "onWheel"
}, ss = Object.keys(Br);
function as(e, t) {
  if (e._listeners != null && t in e._listeners)
    return e._listeners[t];
  let n;
  if (e.isVoidObject && t === "click" && e.parent?.__r3f != null && (n = e.parent.__r3f.root.getState().onPointerMissed), e.__r3f != null && (n = e.__r3f.handlers[Br[t]]), n != null)
    return [n];
}
const us = 1e10, ls = new jo(us), rn = /* @__PURE__ */ new Map();
function Ur(e) {
  let t = rn.get(e);
  return t == null && (t = new He(ls), t.isVoidObject = !0, t.parent = e, t.pointerEventsOrder = -1 / 0, rn.set(e, t)), t;
}
function cs(e, t, n) {
  const r = t.normal ?? t.face?.normal;
  return r == null ? !1 : (e.setFromNormalAndCoplanarPoint(r, t.localPoint), e.applyMatrix4(n), !0);
}
function fs(e, t, n) {
  if (t === "none" || t === "listener" && !e)
    return !1;
  if (n === "all")
    return !0;
  if (typeof n == "function")
    return ({ id: i, type: s, state: a }) => n(i, s, a);
  let r, o;
  return "deny" in n ? (o = !0, r = n.deny) : (o = !1, r = n.allow), Array.isArray(r) ? (i) => on(r.includes(i.type), o) : (i) => on(r === i.type, o);
}
function on(e, t) {
  return t ? !e : e;
}
function Hr(e, t, n, r = !1, o, i, s) {
  const a = r || ds(e, t), u = t.pointerEvents ?? o, l = u ?? t.defaultPointerEvents ?? "listener", c = t.pointerEventsType ?? i ?? "all", f = t.pointerEventsOrder ?? s ?? 0, h = fs(a, l, c), d = n.length;
  if (d === 1)
    (h === !0 || typeof h == "function" && h(n[0])) && Qe(n[0], t, l, c, f);
  else if (h === !0)
    for (let p = 0; p < d; p++)
      Qe(n[p], t, l, c, f);
  else if (typeof h == "function")
    for (let p = 0; p < d; p++) {
      const g = n[p];
      h(g) && Qe(g, t, l, c, f);
    }
  if (t.children.length === 0 || t.intersectChildren === !1)
    return;
  const _ = t.interactableDescendants ?? t.children, v = _.length;
  for (let p = 0; p < v; p++)
    Hr(e, _[p], n, a, u, c, f);
}
function ds(e, t) {
  if (t.ancestorsHaveListeners || e === "pointer" && t.ancestorsHavePointerListeners || e === "wheel" && t.ancestorsHaveWheelListeners || t.__r3f != null && t.__r3f?.eventCount > 0 && (e === "wheel" && t.__r3f.handlers.onWheel != null || e === "pointer" && Object.keys(t.__r3f.handlers).some((o) => o != "onWheel")))
    return !0;
  if (t._listeners == null)
    return !1;
  if (e === "wheel") {
    const o = t._listeners.wheel;
    return o != null && o.length > 0;
  }
  const n = Object.entries(t._listeners), r = n.length;
  for (let o = 0; o < r; o++) {
    const i = n[o];
    if (i[0] !== "wheel" && ss.includes(i[0]) && i[1] != null && i[1].length > 0)
      return !0;
  }
  return !1;
}
function Qe({ intersector: e, options: t }, n, r, o, i) {
  t.filter?.(n, r, o, i) !== !1 && e.executeIntersection(n, i);
}
function ps(e, t, { customSort: n = hs } = {}, r) {
  let o, i, s;
  const a = e.length;
  for (let u = 0; u < a; u++) {
    const l = e[u], c = t?.[u];
    (o == null || n(l, c, o, i) < 0) && (s = u, o = l, i = c);
  }
  return s;
}
function hs(e, t = 0, n, r = 0) {
  return t != r ? r - t : e.distance - n.distance;
}
const sn = 1e7;
function _s(e, t, n, r, o, i = 0) {
  const s = t.direction.clone().multiplyScalar(sn), a = sn;
  return {
    distance: a + i,
    object: Ur(e),
    point: s,
    normal: t.origin.clone().sub(s).normalize(),
    details: n(s, a),
    pointerPosition: r,
    pointerQuaternion: o,
    pointOnFace: s,
    localPoint: s
  };
}
function ms(e, t, n) {
  for (; n > 0; )
    e.push(t), --n;
}
const Ze = Symbol("buttonsDownTime"), gs = Symbol("buttonsClickTime");
globalThis.pointerEventspointerMap ??= /* @__PURE__ */ new Map();
je.prototype.setPointerCapture = function(e) {
  St(e)?.setCapture(this);
};
je.prototype.releasePointerCapture = function(e) {
  const t = St(e);
  t == null || !t.hasCaptured(this) || t.setCapture(void 0);
};
je.prototype.hasPointerCapture = function(e) {
  return St(e)?.hasCaptured(this) ?? !1;
};
function St(e) {
  return globalThis.pointerEventspointerMap?.get(e);
}
class Es {
  id;
  type;
  state;
  intersector;
  getCamera;
  onMoveCommited;
  parentSetPointerCapture;
  parentReleasePointerCapture;
  options;
  //state
  prevIntersection;
  intersection;
  prevEnabled = !0;
  enabled = !0;
  wheelIntersection;
  //derived state
  /**
   * ordered leaf -> root (bottom -> top)
   */
  pointerEntered = [];
  pointerEnteredHelper = [];
  pointerCapture;
  buttonsDownTime = /* @__PURE__ */ new Map();
  buttonsDown = /* @__PURE__ */ new Set();
  //to handle interaction before first move (after exit)
  wasMoved = !1;
  onFirstMove = [];
  constructor(t, n, r, o, i, s, a, u, l = {}) {
    this.id = t, this.type = n, this.state = r, this.intersector = o, this.getCamera = i, this.onMoveCommited = s, this.parentSetPointerCapture = a, this.parentReleasePointerCapture = u, this.options = l, globalThis.pointerEventspointerMap?.set(t, this);
  }
  getPointerCapture() {
    return this.pointerCapture;
  }
  hasCaptured(t) {
    return this.pointerCapture?.object === t;
  }
  setCapture(t) {
    this.pointerCapture?.object !== t && (this.pointerCapture != null && (this.parentReleasePointerCapture?.(), this.pointerCapture = void 0), t != null && this.intersection != null && (this.pointerCapture = { object: t, intersection: this.intersection }, this.parentSetPointerCapture?.()));
  }
  getButtonsDown() {
    return this.buttonsDown;
  }
  /**
   * @returns undefined if no intersection was executed yet
   */
  getIntersection() {
    return this.intersection;
  }
  getEnabled() {
    return this.enabled;
  }
  setEnabled(t, n, r = !0) {
    this.enabled !== t && (!t && this.pointerCapture != null && (this.parentReleasePointerCapture?.(), this.pointerCapture = void 0), this.enabled = t, r && this.commit(n, !1));
  }
  computeIntersection(t, n, r) {
    return this.pointerCapture != null ? this.intersector.intersectPointerCapture(this.pointerCapture, r) : (this.intersector.startIntersection(r), Hr(t, n, [this]), this.intersector.finalizeIntersection(n));
  }
  setIntersection(t) {
    this.intersection = t;
  }
  commit(t, n) {
    const r = this.getCamera(), o = this.prevEnabled ? this.prevIntersection : void 0, i = this.enabled ? this.intersection : void 0;
    o != null && o.object != i?.object && N(new L("pointerout", !0, t, this, o, r));
    const s = this.pointerEntered;
    this.pointerEntered = [], this.pointerEnteredHelper.length = 0, jr(i?.object, this.pointerEntered, s, this.pointerEnteredHelper);
    const a = s.length;
    for (let u = 0; u < a; u++) {
      const l = s[u];
      N(new L("pointerleave", !1, t, this, o, r, l));
    }
    i != null && o?.object != i.object && N(new L("pointerover", !0, t, this, i, r));
    for (let u = this.pointerEnteredHelper.length - 1; u >= 0; u--) {
      const l = this.pointerEnteredHelper[u];
      N(new L("pointerenter", !1, t, this, i, r, l));
    }
    if (n && i != null && N(new L("pointermove", !0, t, this, i, r)), this.prevIntersection = this.intersection, this.prevEnabled = this.enabled, !this.wasMoved && this.intersector.isReady()) {
      this.wasMoved = !0;
      const u = this.onFirstMove.length;
      for (let l = 0; l < u; l++)
        this.onFirstMove[l](r);
      this.onFirstMove.length = 0;
    }
    this.onMoveCommited?.(this);
  }
  /**
   * computes and commits a move
   */
  move(t, n) {
    this.intersection = this.computeIntersection("pointer", t, n), this.commit(n, !0);
  }
  /**
   * emits a move without (re-)computing the intersection
   * just emitting a move event to the current intersection
   */
  emitMove(t) {
    this.intersection != null && N(new L("pointermove", !0, t, this, this.intersection, this.getCamera()));
  }
  down(t) {
    if (this.buttonsDown.add(t.button), !this.enabled)
      return;
    if (!this.wasMoved) {
      this.onFirstMove.push(this.down.bind(this, t));
      return;
    }
    if (this.intersection == null)
      return;
    N(new L("pointerdown", !0, t, this, this.intersection, this.getCamera()));
    const { object: n } = this.intersection;
    n[Ze] ??= /* @__PURE__ */ new Map(), n[Ze].set(t.button, t.timeStamp), this.buttonsDownTime.set(t.button, t.timeStamp);
  }
  up(t) {
    if (this.buttonsDown.delete(t.button), !this.enabled)
      return;
    if (!this.wasMoved) {
      this.onFirstMove.push(this.up.bind(this, t));
      return;
    }
    if (this.intersection == null)
      return;
    const { clickThesholdMs: n, contextMenuButton: r = 2, dblClickThresholdMs: o = 500, clickThresholdMs: i = n ?? 300 } = this.options;
    this.pointerCapture = void 0;
    const s = vs(this.buttonsDownTime, this.intersection.object[Ze], t.button, t.timeStamp, i), a = this.getCamera();
    if (s && t.button === r && N(new L("contextmenu", !0, t, this, this.intersection, a)), N(new L("pointerup", !0, t, this, this.intersection, a)), !s || t.button === r)
      return;
    N(new L("click", !0, t, this, this.intersection, a));
    const { object: u } = this.intersection, l = u[gs] ??= /* @__PURE__ */ new Map(), c = l.get(t.button);
    if (c == null || t.timeStamp - c > o) {
      l.set(t.button, t.timeStamp);
      return;
    }
    N(new L("dblclick", !0, t, this, this.intersection, a)), l.delete(t.button);
  }
  cancel(t) {
    if (this.enabled) {
      if (!this.wasMoved) {
        this.onFirstMove.push(this.cancel.bind(this, t));
        return;
      }
      this.intersection != null && N(new L("pointercancel", !0, t, this, this.intersection, this.getCamera()));
    }
  }
  wheel(t, n, r = !1) {
    if (!this.enabled)
      return;
    if (!this.wasMoved && r) {
      this.onFirstMove.push(this.wheel.bind(this, t, n, r));
      return;
    }
    r || (this.wheelIntersection = this.computeIntersection("wheel", t, n));
    const o = r ? this.intersection : this.wheelIntersection;
    o != null && N(new Be(n, this, o, this.getCamera()));
  }
  emitWheel(t, n = !1) {
    if (!this.enabled)
      return;
    if (!this.wasMoved && n) {
      this.onFirstMove.push(this.emitWheel.bind(this, t, n));
      return;
    }
    const r = n ? this.intersection : this.wheelIntersection;
    r != null && N(new Be(t, this, r, this.getCamera()));
  }
  exit(t) {
    this.wasMoved && (this.pointerCapture != null && (this.parentReleasePointerCapture?.(), this.pointerCapture = void 0), this.intersection = void 0, this.commit(t, !1)), this.onFirstMove.length = 0, this.wasMoved = !1;
  }
}
function jr(e, t, n, r) {
  if (e == null)
    return;
  const o = n.indexOf(e);
  o != -1 ? n.splice(o, 1) : r.push(e), t.push(e), jr(e.parent, t, n, r);
}
function vs(e, t, n, r, o) {
  if (t == null)
    return !1;
  const i = t.get(n);
  return !(i == null || r - i > o || i != e.get(n));
}
const he = new wr(), Je = new wr(), an = new Y(), un = new Y(), ln = new Y(), et = new D(), ys = new Te(), Pe = new D();
function Cs(e, t, n) {
  Pe.copy(t).applyMatrix4(ys.copy(n.matrixWorld).invert());
  const r = n.geometry.attributes.uv;
  if (r == null || !(r instanceof br))
    return !1;
  let o;
  return bs(n, (i, s, a) => {
    n.getVertexPosition(i, he.a), n.getVertexPosition(s, he.b), n.getVertexPosition(a, he.c);
    const u = he.closestPointToPoint(Pe, et).distanceTo(Pe);
    o != null && u >= o || (o = u, Je.copy(he), an.fromBufferAttribute(r, i), un.fromBufferAttribute(r, s), ln.fromBufferAttribute(r, a));
  }), o == null ? !1 : (Je.closestPointToPoint(Pe, et), Je.getInterpolation(et, an, un, ln, e), !0);
}
function bs(e, t) {
  const n = e.geometry.drawRange;
  if (e.geometry.index != null) {
    const s = e.geometry.index, a = Math.max(0, n.start), u = Math.min(s.count, n.start + n.count);
    for (let l = a; l < u; l += 3)
      t(s.getX(l), s.getX(l + 1), s.getX(l + 2));
    return;
  }
  const r = e.geometry.attributes.position;
  if (r == null)
    return;
  const o = Math.max(0, n.start), i = Math.min(r.count, n.start + n.count);
  for (let s = o; s < i; s += 3)
    t(s, s + 1, s + 2);
}
new Te();
new zo();
new D();
new ze();
new st();
new Y();
new D(0, 0, 0), new D(0, 0, 1);
const cn = new Te(), ws = new D();
new D(0, 0, -1);
new ze();
const fn = new Y(), As = new D();
class Ts {
  prepareTransformation;
  options;
  raycaster = new $o();
  cameraQuaternion = new at();
  fromPosition = new D();
  fromQuaternion = new at();
  coords = new Y();
  viewPlane = new ze();
  intersects = [];
  pointerEventsOrders = [];
  constructor(t, n) {
    this.prepareTransformation = t, this.options = n;
  }
  isReady() {
    return !0;
  }
  intersectPointerCapture({ intersection: t, object: n }, r) {
    const o = t.details;
    if (o.type != "screen-ray")
      throw new Error(`unable to process a pointer capture of type "${t.details.type}" with a camera ray intersector`);
    if (!this.startIntersection(r))
      return t;
    this.viewPlane.constant -= o.distanceViewPlane;
    const i = this.raycaster.ray.intersectPlane(this.viewPlane, new D());
    if (i == null)
      return t;
    t.object.updateWorldMatrix(!0, !1), cs(this.viewPlane, t, t.object.matrixWorld);
    let s = t.uv;
    return t.object instanceof He && Cs(fn, i, t.object) && (s = fn.clone()), {
      ...t,
      details: {
        ...o,
        direction: this.raycaster.ray.direction.clone(),
        screenPoint: this.coords.clone()
      },
      uv: s,
      object: n,
      point: i,
      pointOnFace: i,
      pointerPosition: this.raycaster.ray.origin.clone(),
      pointerQuaternion: this.cameraQuaternion.clone()
    };
  }
  startIntersection(t) {
    const n = this.prepareTransformation(t, this.coords);
    return n == null ? !1 : (n.updateWorldMatrix(!0, !1), n.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, ws), this.raycaster.setFromCamera(this.coords, n), this.viewPlane.setFromNormalAndCoplanarPoint(n.getWorldDirection(As), this.raycaster.ray.origin), !0);
  }
  executeIntersection(t, n) {
    const r = this.intersects.length;
    t.raycast(this.raycaster, this.intersects), ms(this.pointerEventsOrders, n, this.intersects.length - r);
  }
  finalizeIntersection(t) {
    const n = this.fromPosition.clone(), r = this.cameraQuaternion.clone(), o = this.raycaster.ray.direction.clone(), i = ps(this.intersects, this.pointerEventsOrders, this.options), s = i == null ? void 0 : this.intersects[i];
    return this.intersects.length = 0, this.pointerEventsOrders.length = 0, s == null ? _s(t, this.raycaster.ray, (a, u) => ({
      type: "screen-ray",
      distanceViewPlane: u,
      screenPoint: this.coords.clone(),
      direction: o
    }), n, r) : (s.object.updateWorldMatrix(!0, !1), cn.copy(s.object.matrixWorld).invert(), Object.assign(s, {
      details: {
        type: "screen-ray",
        distanceViewPlane: this.viewPlane.distanceToPoint(s.point),
        screenPoint: this.coords.clone(),
        direction: o
      },
      pointOnFace: s.point,
      pointerPosition: n,
      pointerQuaternion: r,
      localPoint: s.point.clone().applyMatrix4(cn)
    }));
  }
}
new D();
new Y();
new Te();
new D();
new at();
new ze();
new Ko();
new D();
new D();
new D();
new D(1e-4, 1e-4, 1e-4);
new Te();
let Os = 23412;
function Ss() {
  return Os++;
}
function Ps(e, t, n) {
  if (!(t instanceof globalThis.MouseEvent))
    return n.set(0, 0);
  const { width: r, height: o, top: i, left: s } = e.getBoundingClientRect(), a = t.clientX - s, u = t.clientY - i;
  return n.set(a / r * 2 - 1, -(u / o) * 2 + 1);
}
function Is(e, t, n, r) {
  return Ds(
    e,
    //backwards compatibility
    typeof t == "function" ? t : () => t,
    n,
    Ps.bind(null, e),
    e.setPointerCapture.bind(e),
    (o) => {
      e.hasPointerCapture(o) && e.releasePointerCapture(o);
    },
    {
      pointerTypePrefix: "screen-",
      ...r
    }
  );
}
function Ds(e, t, n, r, o, i, s = {}) {
  const a = s?.forwardPointerCapture ?? !0, u = /* @__PURE__ */ new Map(), l = s.pointerTypePrefix ?? "forward-", c = (O, T) => {
    let E = u.get(O.pointerId);
    return E != null || (E = new Es(Ss(), `${l}${O.pointerType}`, O.pointerState, new Ts((x, R) => (r(x, R), t()), s), t, void 0, a ? o.bind(null, O.pointerId) : void 0, a ? i.bind(null, O.pointerId) : void 0, s), T != "move" && T != "wheel" && (E.setIntersection(E.computeIntersection("pointer", n, O)), E.commit(O, !1)), u.set(O.pointerId, E)), E;
  }, f = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), d = [], _ = [], v = (O, T, E) => {
    switch (O) {
      case "move":
        E.move(n, T);
        return;
      case "wheel":
        E.wheel(n, T);
        return;
      case "cancel":
        E.cancel(T);
        return;
      case "down":
        if (!dn(T))
          return;
        E.down(T);
        return;
      case "up":
        if (!dn(T))
          return;
        E.up(T);
        return;
      case "exit":
        h.delete(E), f.delete(E), E.exit(T);
        return;
    }
  }, p = (O, T) => {
    const E = c(T, O);
    O === "move" && h.set(E, T), O === "wheel" && f.set(E, T), s.batchEvents ?? !0 ? _.push({ type: O, event: T }) : v(O, T, E);
  }, g = p.bind(null, "move"), C = p.bind(null, "cancel"), b = p.bind(null, "down"), P = p.bind(null, "up"), M = p.bind(null, "wheel"), A = p.bind(null, "exit");
  return e.addEventListener("pointermove", g), e.addEventListener("pointercancel", C), e.addEventListener("pointerdown", b), e.addEventListener("pointerup", P), e.addEventListener("wheel", M), e.addEventListener("pointerleave", A), {
    destroy() {
      e.removeEventListener("pointermove", g), e.removeEventListener("pointercancel", C), e.removeEventListener("pointerdown", b), e.removeEventListener("pointerup", P), e.removeEventListener("wheel", M), e.removeEventListener("pointerleave", A), h.clear(), f.clear();
    },
    update() {
      const O = _.length;
      for (let T = 0; T < O; T++) {
        const { type: E, event: x } = _[T], R = c(x, E);
        if (E === "move" && (d.push(R), h.get(R) != x)) {
          R.emitMove(x);
          continue;
        }
        if (E === "wheel" && f.get(R) != x) {
          R.emitWheel(x);
          continue;
        }
        v(E, x, R);
      }
      if (_.length = 0, s.intersectEveryFrame ?? !1)
        for (const [T, E] of h.entries())
          d.includes(T) || T.move(n, E);
      d.length = 0;
    }
  };
}
function dn(e) {
  return e.button != null;
}
function ks({
  canvas: e,
  contextParts: { scene: t, camera: n, renderer: r }
}) {
  const { update: o, destroy: i } = Is(I(e), () => I(n.activeCamera), t.value), { off: s } = r.loop.onLoop(o);
  ie(i), ie(s);
  const a = Ur(t.value), u = Ee();
  return a.addEventListener("click", u.trigger), {
    onPointerMissed: u.on
  };
}
const xs = "useTres", [Rs, Ls] = fi(({
  scene: e,
  canvas: t,
  windowSize: n,
  rendererOptions: r
}) => {
  const o = it(e), i = os(n, t), s = Ji({ sizes: i }), a = rs(
    {
      scene: o,
      canvas: t,
      options: r,
      contextParts: { sizes: i, camera: s }
    }
  ), u = ks({
    canvas: t,
    contextParts: { scene: o, camera: s, renderer: a }
  }), l = {
    sizes: i,
    scene: o,
    camera: s,
    renderer: a,
    controls: Ae(null),
    extend: pt,
    events: u
  };
  return l.scene.value.__tres = {
    root: l
  }, l;
}, {
  injectionKey: "useTres"
}), zr = () => {
  const e = Ls();
  if (!e)
    throw new Error(`useTresContext must be used together with useTresContextProvider.
 You probably tried to use it above or on the same level as a TresCanvas component.
 It should be used in child components of a TresCanvas instance.`);
  return e;
};
function Fs() {
  const { scene: e, renderer: t, camera: n, sizes: r, controls: o, extend: i, events: s } = zr();
  return {
    scene: e,
    renderer: t.instance,
    camera: n.activeCamera,
    sizes: r,
    controls: o,
    extend: i,
    events: s,
    invalidate: t.invalidate,
    advance: t.advance
  };
}
const _l = () => {
  const e = Fs(), { renderer: t } = zr(), n = nn(), r = nn();
  t.loop.onBeforeLoop((i) => {
    n.trigger({ ...e, ...i });
  }), t.loop.onLoop((i) => {
    r.trigger({ ...e, ...i });
  });
  const o = t.replaceRenderFunction;
  return {
    stop: t.loop.stop,
    start: t.loop.start,
    isActive: t.loop.isActive,
    onBeforeRender: n.on,
    onRender: r.on,
    render: o
  };
};
function Ms(e, t = {}, n = {}) {
  let r = e;
  const o = (a) => {
    r = a;
  };
  let i = new Proxy({}, {});
  const s = {
    has(a, u) {
      return u in t || u in r;
    },
    get(a, u, l) {
      return u in t ? t[u](r) : r[u];
    },
    set(a, u, l) {
      return n[u] ? n[u](l, r, i, o) : r[u] = l, !0;
    }
  };
  return i = new Proxy({}, s), i;
}
const Ns = [
  "onClick",
  "onContextmenu",
  "onPointermove",
  "onPointerenter",
  "onPointerleave",
  "onPointerover",
  "onPointerout",
  "onDblclick",
  "onPointerdown",
  "onPointerup",
  "onPointercancel",
  "onLostpointercapture",
  "onWheel"
], Vs = {
  onClick: "click",
  onContextmenu: "contextmenu",
  onPointermove: "pointermove",
  onPointerenter: "pointerenter",
  onPointerleave: "pointerleave",
  onPointerover: "pointerover",
  onPointerout: "pointerout",
  onDblclick: "dblclick",
  onPointerdown: "pointerdown",
  onPointerup: "pointerup",
  onPointercancel: "pointercancel",
  onLostpointercapture: "lostpointercapture",
  onWheel: "wheel"
}, pn = (e) => Ns.includes(e), Bs = (e) => {
  const t = e.scene.value;
  function n(c, f, h, d) {
    if (d || (d = {}), d.args || (d.args = []), Vi(c))
      return null;
    c.includes("-") && (c = c.replace(/-([a-z])/g, (p, g) => g.toUpperCase()).replace(/^[a-z]/, (p) => p.toUpperCase()));
    let _ = c.replace("Tres", ""), v;
    if (c === "primitive") {
      (!Tt(d.object) || me(d.object)) && Jt(
        "Tres primitives need an 'object' prop, whose value is an object or shallowRef<object>"
      ), _ = d.object.type;
      const p = {};
      v = Ms(
        d.object,
        {
          object: (C) => C,
          isPrimitive: () => !0,
          __tres: () => p
        },
        {
          object: (C, b, P, M) => {
            Qi(C, P, M, { patchProp: i, remove: o, insert: r }, e);
          },
          __tres: (C) => {
            Object.assign(p, C);
          }
        }
      );
    } else {
      const p = dt.value[_];
      p || Jt(
        `${_} is not defined on the THREE namespace. Use extend to add it to the catalog.`
      ), v = new p(...d.args);
    }
    return v ? (re(v) && (d?.position || v.position.set(3, 3, 3), d?.lookAt || v.lookAt(0, 0, 0)), v = X(v, {
      ...Gi(v) ? v.__tres : {},
      type: _,
      memoizedProps: d,
      primitive: c === "primitive",
      attach: d.attach
    }, e), v) : null;
  }
  function r(c, f) {
    if (!c)
      return;
    f = f || t;
    const h = c.__tres ? c : X(c, {}, e), d = f.__tres ? f : X(f, {}, e);
    c = se(h), f = se(d), re(c) && e.camera?.registerCamera(c), h.__tres.attach ? qi(d, h, h.__tres.attach) : lt(c) && lt(d) && (d.add(c), c.dispatchEvent({ type: "added" })), h.__tres.parent = d, d.__tres.objects && !d.__tres.objects.includes(h) && d.__tres.objects.push(h);
  }
  function o(c, f) {
    if (!c)
      return;
    f = ut(f) ? "default" : f;
    const h = c.__tres?.dispose;
    ut(h) || (h === null ? f = !1 : f = h);
    const d = c.__tres?.primitive, _ = f === "default" ? !d : !!f;
    if (c.__tres && "objects" in c.__tres && [...c.__tres.objects].forEach((v) => o(v, f)), _ && c.children && [...c.children].forEach((v) => o(v, f)), Mr(c, e), Nr(c, e), _ && !Fr(c)) {
      if (Q(f))
        f(c);
      else if (Q(c.dispose))
        try {
          c.dispose();
        } catch {
        }
    }
    "__tres" in c && delete c.__tres;
  }
  function i(c, f, h, d) {
    if (!c)
      return;
    let _ = c;
    const v = f;
    if (c.__tres && (c.__tres.memoizedProps[f] = d), f === "attach") {
      const b = c.__tres?.parent || c.parent;
      o(c), X(c, { attach: d }, e), b && r(c, b);
      return;
    }
    if (f === "dispose") {
      c.__tres || (c = X(c, {}, e)), c.__tres.dispose = d;
      return;
    }
    pn(f) && Q(d) && c.addEventListener(Vs[f], d);
    let p = Qt(v), g = _?.[p];
    if (v === "args") {
      const b = c, P = h ?? [], M = d ?? [], A = c.__tres?.type || c.type;
      if (A && P.length && !Or(P, M)) {
        const O = new dt.value[A](...d), T = Object.getOwnPropertyDescriptors(O);
        Object.entries(T).forEach(([E, x]) => {
          if (!(!x.writable && !x.set) && E in b)
            try {
              b[E] = O[E];
            } catch (R) {
              console.warn(`Could not set property ${E} on ${A}:`, R);
            }
        }), _ = b;
      }
      return;
    }
    if (_.type === "BufferGeometry") {
      if (v === "args")
        return;
      _.setAttribute(
        Qt(v),
        new br(...d)
      );
      return;
    }
    if (v.includes("-") && g === void 0) {
      const b = Ve(_, v);
      if (g = b.target, _ = b.target, p = b.key, g && p) {
        g[p] = d, re(c) && c.updateProjectionMatrix(), ft(c);
        return;
      }
    }
    let C = d;
    if (C === "" && (C = !0), Q(g)) {
      pn(f) || (Array.isArray(C) ? c[p](...C) : c[p](C)), p.startsWith("on") && Q(C) && (_[p] = C);
      return;
    }
    Zt(g) && Zt(C) ? g.mask = C.mask : Dr(g) && ji(C) ? g.set(C) : zi(g) && $i(C) && g.constructor === C.constructor ? g.copy(C) : ct(g) && Array.isArray(C) ? "fromArray" in g && typeof g.fromArray == "function" ? g.fromArray(C) : g.set(...C) : ct(g) && typeof C == "number" ? "setScalar" in g && typeof g.setScalar == "function" ? g.setScalar(C) : g.set(C) : _[p] = C, re(c) && c.updateProjectionMatrix(), ft(c);
  }
  function s(c) {
    return c?.__tres?.parent || null;
  }
  function a(c) {
    const f = X(new je(), { type: "Comment" }, e);
    return f.name = c, f;
  }
  function u(c) {
    const h = s(c)?.__tres?.objects || [], d = h.indexOf(c);
    return d < 0 || d >= h.length - 1 ? null : h[d + 1];
  }
  const l = () => {
  };
  return {
    insert: r,
    remove: o,
    createElement: n,
    patchProp: i,
    parentNode: s,
    createText: l,
    createComment: a,
    setText: l,
    setElementText: l,
    nextSibling: u,
    querySelector: l,
    setScopeId: l,
    cloneNode: l,
    insertStaticContent: l
  };
}, Us = ["asset-load"];
class Hs {
  subscribers = /* @__PURE__ */ new Set();
  messageQueue = [];
  maxQueueSize = 100;
  // Prevent memory leaks by limiting queue size
  /**
   * Send a message to devtools subscribers
   * If no subscribers are available, only queueable message types are queued
   */
  send(t, n) {
    const r = {
      type: t,
      data: n,
      timestamp: Date.now()
    };
    this.subscribers.size > 0 ? this.subscribers.forEach((o) => o(r)) : Us.includes(t) && this.queueMessage(r);
  }
  /**
   * Queue a message for later delivery
   */
  queueMessage(t) {
    this.messageQueue.push(t), this.messageQueue.length > this.maxQueueSize && this.messageQueue.shift();
  }
  /**
   * Flush all queued messages to current subscribers
   */
  flushQueue() {
    this.messageQueue.length === 0 || this.subscribers.size === 0 || (this.messageQueue.forEach((t) => {
      this.subscribers.forEach((n) => n(t));
    }), this.messageQueue = []);
  }
  /**
   * Subscribe to devtools messages
   * When a new subscriber is added, all queued messages (asset-load events) are immediately delivered
   */
  subscribe(t) {
    return this.subscribers.add(t), this.flushQueue(), () => {
      this.subscribers.delete(t);
    };
  }
  /**
   * Check if there are any subscribers
   */
  get hasSubscribers() {
    return this.subscribers.size > 0;
  }
  /**
   * Get the current queue size
   */
  get queueSize() {
    return this.messageQueue.length;
  }
  /**
   * Clear all queued messages
   */
  clearQueue() {
    this.messageQueue = [];
  }
}
var js = Object.create, $r = Object.defineProperty, zs = Object.getOwnPropertyDescriptor, Pt = Object.getOwnPropertyNames, $s = Object.getPrototypeOf, Ks = Object.prototype.hasOwnProperty, Ws = (e, t) => function() {
  return e && (t = (0, e[Pt(e)[0]])(e = 0)), t;
}, Gs = (e, t) => function() {
  return t || (0, e[Pt(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Ys = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of Pt(t))
      !Ks.call(e, o) && o !== n && $r(e, o, { get: () => t[o], enumerable: !(r = zs(t, o)) || r.enumerable });
  return e;
}, qs = (e, t, n) => (n = e != null ? js($s(e)) : {}, Ys(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  $r(n, "default", { value: e, enumerable: !0 }),
  e
)), Oe = Ws({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
  }
}), Xs = Gs({
  "../../node_modules/.pnpm/rfdc@1.4.1/node_modules/rfdc/index.js"(e, t) {
    Oe(), t.exports = r;
    function n(i) {
      return i instanceof Buffer ? Buffer.from(i) : new i.constructor(i.buffer.slice(), i.byteOffset, i.length);
    }
    function r(i) {
      if (i = i || {}, i.circles) return o(i);
      const s = /* @__PURE__ */ new Map();
      if (s.set(Date, (f) => new Date(f)), s.set(Map, (f, h) => new Map(u(Array.from(f), h))), s.set(Set, (f, h) => new Set(u(Array.from(f), h))), i.constructorHandlers)
        for (const f of i.constructorHandlers)
          s.set(f[0], f[1]);
      let a = null;
      return i.proto ? c : l;
      function u(f, h) {
        const d = Object.keys(f), _ = new Array(d.length);
        for (let v = 0; v < d.length; v++) {
          const p = d[v], g = f[p];
          typeof g != "object" || g === null ? _[p] = g : g.constructor !== Object && (a = s.get(g.constructor)) ? _[p] = a(g, h) : ArrayBuffer.isView(g) ? _[p] = n(g) : _[p] = h(g);
        }
        return _;
      }
      function l(f) {
        if (typeof f != "object" || f === null) return f;
        if (Array.isArray(f)) return u(f, l);
        if (f.constructor !== Object && (a = s.get(f.constructor)))
          return a(f, l);
        const h = {};
        for (const d in f) {
          if (Object.hasOwnProperty.call(f, d) === !1) continue;
          const _ = f[d];
          typeof _ != "object" || _ === null ? h[d] = _ : _.constructor !== Object && (a = s.get(_.constructor)) ? h[d] = a(_, l) : ArrayBuffer.isView(_) ? h[d] = n(_) : h[d] = l(_);
        }
        return h;
      }
      function c(f) {
        if (typeof f != "object" || f === null) return f;
        if (Array.isArray(f)) return u(f, c);
        if (f.constructor !== Object && (a = s.get(f.constructor)))
          return a(f, c);
        const h = {};
        for (const d in f) {
          const _ = f[d];
          typeof _ != "object" || _ === null ? h[d] = _ : _.constructor !== Object && (a = s.get(_.constructor)) ? h[d] = a(_, c) : ArrayBuffer.isView(_) ? h[d] = n(_) : h[d] = c(_);
        }
        return h;
      }
    }
    function o(i) {
      const s = [], a = [], u = /* @__PURE__ */ new Map();
      if (u.set(Date, (d) => new Date(d)), u.set(Map, (d, _) => new Map(c(Array.from(d), _))), u.set(Set, (d, _) => new Set(c(Array.from(d), _))), i.constructorHandlers)
        for (const d of i.constructorHandlers)
          u.set(d[0], d[1]);
      let l = null;
      return i.proto ? h : f;
      function c(d, _) {
        const v = Object.keys(d), p = new Array(v.length);
        for (let g = 0; g < v.length; g++) {
          const C = v[g], b = d[C];
          if (typeof b != "object" || b === null)
            p[C] = b;
          else if (b.constructor !== Object && (l = u.get(b.constructor)))
            p[C] = l(b, _);
          else if (ArrayBuffer.isView(b))
            p[C] = n(b);
          else {
            const P = s.indexOf(b);
            P !== -1 ? p[C] = a[P] : p[C] = _(b);
          }
        }
        return p;
      }
      function f(d) {
        if (typeof d != "object" || d === null) return d;
        if (Array.isArray(d)) return c(d, f);
        if (d.constructor !== Object && (l = u.get(d.constructor)))
          return l(d, f);
        const _ = {};
        s.push(d), a.push(_);
        for (const v in d) {
          if (Object.hasOwnProperty.call(d, v) === !1) continue;
          const p = d[v];
          if (typeof p != "object" || p === null)
            _[v] = p;
          else if (p.constructor !== Object && (l = u.get(p.constructor)))
            _[v] = l(p, f);
          else if (ArrayBuffer.isView(p))
            _[v] = n(p);
          else {
            const g = s.indexOf(p);
            g !== -1 ? _[v] = a[g] : _[v] = f(p);
          }
        }
        return s.pop(), a.pop(), _;
      }
      function h(d) {
        if (typeof d != "object" || d === null) return d;
        if (Array.isArray(d)) return c(d, h);
        if (d.constructor !== Object && (l = u.get(d.constructor)))
          return l(d, h);
        const _ = {};
        s.push(d), a.push(_);
        for (const v in d) {
          const p = d[v];
          if (typeof p != "object" || p === null)
            _[v] = p;
          else if (p.constructor !== Object && (l = u.get(p.constructor)))
            _[v] = l(p, h);
          else if (ArrayBuffer.isView(p))
            _[v] = n(p);
          else {
            const g = s.indexOf(p);
            g !== -1 ? _[v] = a[g] : _[v] = h(p);
          }
        }
        return s.pop(), a.pop(), _;
      }
    }
  }
});
Oe();
Oe();
Oe();
var Kr = typeof navigator < "u", y = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : {};
typeof y.chrome < "u" && y.chrome.devtools;
Kr && (y.self, y.top);
var hn;
typeof navigator < "u" && ((hn = navigator.userAgent) == null || hn.toLowerCase().includes("electron"));
Oe();
var Qs = qs(Xs()), Zs = /(?:^|[-_/])(\w)/g;
function Js(e, t) {
  return t ? t.toUpperCase() : "";
}
function ea(e) {
  return e && `${e}`.replace(Zs, Js);
}
function ta(e, t) {
  let n = e.replace(/^[a-z]:/i, "").replace(/\\/g, "/");
  n.endsWith(`index${t}`) && (n = n.replace(`/index${t}`, t));
  const r = n.lastIndexOf("/"), o = n.substring(r + 1);
  {
    const i = o.lastIndexOf(t);
    return o.substring(0, i);
  }
}
var _n = (0, Qs.default)({ circles: !0 });
const na = {
  trailing: !0
};
function ae(e, t = 25, n = {}) {
  if (n = { ...na, ...n }, !Number.isFinite(t))
    throw new TypeError("Expected `wait` to be a finite number");
  let r, o, i = [], s, a;
  const u = (l, c) => (s = ra(e, l, c), s.finally(() => {
    if (s = null, n.trailing && a && !o) {
      const f = u(l, a);
      return a = null, f;
    }
  }), s);
  return function(...l) {
    return s ? (n.trailing && (a = l), s) : new Promise((c) => {
      const f = !o && n.leading;
      clearTimeout(o), o = setTimeout(() => {
        o = null;
        const h = n.leading ? r : u(this, l);
        for (const d of i)
          d(h);
        i = [];
      }, t), f ? (r = u(this, l), c(r)) : i.push(c);
    });
  };
}
async function ra(e, t, n) {
  return await e.apply(t, n);
}
function ht(e, t = {}, n) {
  for (const r in e) {
    const o = e[r], i = n ? `${n}:${r}` : r;
    typeof o == "object" && o !== null ? ht(o, t, i) : typeof o == "function" && (t[i] = o);
  }
  return t;
}
const oa = { run: (e) => e() }, ia = () => oa, Wr = typeof console.createTask < "u" ? console.createTask : ia;
function sa(e, t) {
  const n = t.shift(), r = Wr(n);
  return e.reduce(
    (o, i) => o.then(() => r.run(() => i(...t))),
    Promise.resolve()
  );
}
function aa(e, t) {
  const n = t.shift(), r = Wr(n);
  return Promise.all(e.map((o) => r.run(() => o(...t))));
}
function tt(e, t) {
  for (const n of [...e])
    n(t);
}
class ua {
  constructor() {
    this._hooks = {}, this._before = void 0, this._after = void 0, this._deprecatedMessages = void 0, this._deprecatedHooks = {}, this.hook = this.hook.bind(this), this.callHook = this.callHook.bind(this), this.callHookWith = this.callHookWith.bind(this);
  }
  hook(t, n, r = {}) {
    if (!t || typeof n != "function")
      return () => {
      };
    const o = t;
    let i;
    for (; this._deprecatedHooks[t]; )
      i = this._deprecatedHooks[t], t = i.to;
    if (i && !r.allowDeprecated) {
      let s = i.message;
      s || (s = `${o} hook has been deprecated` + (i.to ? `, please use ${i.to}` : "")), this._deprecatedMessages || (this._deprecatedMessages = /* @__PURE__ */ new Set()), this._deprecatedMessages.has(s) || (console.warn(s), this._deprecatedMessages.add(s));
    }
    if (!n.name)
      try {
        Object.defineProperty(n, "name", {
          get: () => "_" + t.replace(/\W+/g, "_") + "_hook_cb",
          configurable: !0
        });
      } catch {
      }
    return this._hooks[t] = this._hooks[t] || [], this._hooks[t].push(n), () => {
      n && (this.removeHook(t, n), n = void 0);
    };
  }
  hookOnce(t, n) {
    let r, o = (...i) => (typeof r == "function" && r(), r = void 0, o = void 0, n(...i));
    return r = this.hook(t, o), r;
  }
  removeHook(t, n) {
    if (this._hooks[t]) {
      const r = this._hooks[t].indexOf(n);
      r !== -1 && this._hooks[t].splice(r, 1), this._hooks[t].length === 0 && delete this._hooks[t];
    }
  }
  deprecateHook(t, n) {
    this._deprecatedHooks[t] = typeof n == "string" ? { to: n } : n;
    const r = this._hooks[t] || [];
    delete this._hooks[t];
    for (const o of r)
      this.hook(t, o);
  }
  deprecateHooks(t) {
    Object.assign(this._deprecatedHooks, t);
    for (const n in t)
      this.deprecateHook(n, t[n]);
  }
  addHooks(t) {
    const n = ht(t), r = Object.keys(n).map(
      (o) => this.hook(o, n[o])
    );
    return () => {
      for (const o of r.splice(0, r.length))
        o();
    };
  }
  removeHooks(t) {
    const n = ht(t);
    for (const r in n)
      this.removeHook(r, n[r]);
  }
  removeAllHooks() {
    for (const t in this._hooks)
      delete this._hooks[t];
  }
  callHook(t, ...n) {
    return n.unshift(t), this.callHookWith(sa, t, ...n);
  }
  callHookParallel(t, ...n) {
    return n.unshift(t), this.callHookWith(aa, t, ...n);
  }
  callHookWith(t, n, ...r) {
    const o = this._before || this._after ? { name: n, args: r, context: {} } : void 0;
    this._before && tt(this._before, o);
    const i = t(
      n in this._hooks ? [...this._hooks[n]] : [],
      r
    );
    return i instanceof Promise ? i.finally(() => {
      this._after && o && tt(this._after, o);
    }) : (this._after && o && tt(this._after, o), i);
  }
  beforeEach(t) {
    return this._before = this._before || [], this._before.push(t), () => {
      if (this._before !== void 0) {
        const n = this._before.indexOf(t);
        n !== -1 && this._before.splice(n, 1);
      }
    };
  }
  afterEach(t) {
    return this._after = this._after || [], this._after.push(t), () => {
      if (this._after !== void 0) {
        const n = this._after.indexOf(t);
        n !== -1 && this._after.splice(n, 1);
      }
    };
  }
}
function Gr() {
  return new ua();
}
var la = Object.create, Yr = Object.defineProperty, ca = Object.getOwnPropertyDescriptor, It = Object.getOwnPropertyNames, fa = Object.getPrototypeOf, da = Object.prototype.hasOwnProperty, pa = (e, t) => function() {
  return e && (t = (0, e[It(e)[0]])(e = 0)), t;
}, qr = (e, t) => function() {
  return t || (0, e[It(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, ha = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let o of It(t))
      !da.call(e, o) && o !== n && Yr(e, o, { get: () => t[o], enumerable: !(r = ca(t, o)) || r.enumerable });
  return e;
}, _a = (e, t, n) => (n = e != null ? la(fa(e)) : {}, ha(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  Yr(n, "default", { value: e, enumerable: !0 }),
  e
)), m = pa({
  "../../node_modules/.pnpm/tsup@8.4.0_@microsoft+api-extractor@7.51.1_@types+node@22.13.14__jiti@2.4.2_postcss@8.5_96eb05a9d65343021e53791dd83f3773/node_modules/tsup/assets/esm_shims.js"() {
  }
}), ma = qr({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/lib/speakingurl.js"(e, t) {
    m(), (function(n) {
      var r = {
        // latin
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "Ae",
        Å: "A",
        Æ: "AE",
        Ç: "C",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        Ð: "D",
        Ñ: "N",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "Oe",
        Ő: "O",
        Ø: "O",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "Ue",
        Ű: "U",
        Ý: "Y",
        Þ: "TH",
        ß: "ss",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "ae",
        å: "a",
        æ: "ae",
        ç: "c",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        ð: "d",
        ñ: "n",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "oe",
        ő: "o",
        ø: "o",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "ue",
        ű: "u",
        ý: "y",
        þ: "th",
        ÿ: "y",
        "ẞ": "SS",
        // language specific
        // Arabic
        ا: "a",
        أ: "a",
        إ: "i",
        آ: "aa",
        ؤ: "u",
        ئ: "e",
        ء: "a",
        ب: "b",
        ت: "t",
        ث: "th",
        ج: "j",
        ح: "h",
        خ: "kh",
        د: "d",
        ذ: "th",
        ر: "r",
        ز: "z",
        س: "s",
        ش: "sh",
        ص: "s",
        ض: "dh",
        ط: "t",
        ظ: "z",
        ع: "a",
        غ: "gh",
        ف: "f",
        ق: "q",
        ك: "k",
        ل: "l",
        م: "m",
        ن: "n",
        ه: "h",
        و: "w",
        ي: "y",
        ى: "a",
        ة: "h",
        ﻻ: "la",
        ﻷ: "laa",
        ﻹ: "lai",
        ﻵ: "laa",
        // Persian additional characters than Arabic
        گ: "g",
        چ: "ch",
        پ: "p",
        ژ: "zh",
        ک: "k",
        ی: "y",
        // Arabic diactrics
        "َ": "a",
        "ً": "an",
        "ِ": "e",
        "ٍ": "en",
        "ُ": "u",
        "ٌ": "on",
        "ْ": "",
        // Arabic numbers
        "٠": "0",
        "١": "1",
        "٢": "2",
        "٣": "3",
        "٤": "4",
        "٥": "5",
        "٦": "6",
        "٧": "7",
        "٨": "8",
        "٩": "9",
        // Persian numbers
        "۰": "0",
        "۱": "1",
        "۲": "2",
        "۳": "3",
        "۴": "4",
        "۵": "5",
        "۶": "6",
        "۷": "7",
        "۸": "8",
        "۹": "9",
        // Burmese consonants
        က: "k",
        ခ: "kh",
        ဂ: "g",
        ဃ: "ga",
        င: "ng",
        စ: "s",
        ဆ: "sa",
        ဇ: "z",
        "စျ": "za",
        ည: "ny",
        ဋ: "t",
        ဌ: "ta",
        ဍ: "d",
        ဎ: "da",
        ဏ: "na",
        တ: "t",
        ထ: "ta",
        ဒ: "d",
        ဓ: "da",
        န: "n",
        ပ: "p",
        ဖ: "pa",
        ဗ: "b",
        ဘ: "ba",
        မ: "m",
        ယ: "y",
        ရ: "ya",
        လ: "l",
        ဝ: "w",
        သ: "th",
        ဟ: "h",
        ဠ: "la",
        အ: "a",
        // consonant character combos
        "ြ": "y",
        "ျ": "ya",
        "ွ": "w",
        "ြွ": "yw",
        "ျွ": "ywa",
        "ှ": "h",
        // independent vowels
        ဧ: "e",
        "၏": "-e",
        ဣ: "i",
        ဤ: "-i",
        ဉ: "u",
        ဦ: "-u",
        ဩ: "aw",
        "သြော": "aw",
        ဪ: "aw",
        // numbers
        "၀": "0",
        "၁": "1",
        "၂": "2",
        "၃": "3",
        "၄": "4",
        "၅": "5",
        "၆": "6",
        "၇": "7",
        "၈": "8",
        "၉": "9",
        // virama and tone marks which are silent in transliteration
        "္": "",
        "့": "",
        "း": "",
        // Czech
        č: "c",
        ď: "d",
        ě: "e",
        ň: "n",
        ř: "r",
        š: "s",
        ť: "t",
        ů: "u",
        ž: "z",
        Č: "C",
        Ď: "D",
        Ě: "E",
        Ň: "N",
        Ř: "R",
        Š: "S",
        Ť: "T",
        Ů: "U",
        Ž: "Z",
        // Dhivehi
        ހ: "h",
        ށ: "sh",
        ނ: "n",
        ރ: "r",
        ބ: "b",
        ޅ: "lh",
        ކ: "k",
        އ: "a",
        ވ: "v",
        މ: "m",
        ފ: "f",
        ދ: "dh",
        ތ: "th",
        ލ: "l",
        ގ: "g",
        ޏ: "gn",
        ސ: "s",
        ޑ: "d",
        ޒ: "z",
        ޓ: "t",
        ޔ: "y",
        ޕ: "p",
        ޖ: "j",
        ޗ: "ch",
        ޘ: "tt",
        ޙ: "hh",
        ޚ: "kh",
        ޛ: "th",
        ޜ: "z",
        ޝ: "sh",
        ޞ: "s",
        ޟ: "d",
        ޠ: "t",
        ޡ: "z",
        ޢ: "a",
        ޣ: "gh",
        ޤ: "q",
        ޥ: "w",
        "ަ": "a",
        "ާ": "aa",
        "ި": "i",
        "ީ": "ee",
        "ު": "u",
        "ޫ": "oo",
        "ެ": "e",
        "ޭ": "ey",
        "ޮ": "o",
        "ޯ": "oa",
        "ް": "",
        // Georgian https://en.wikipedia.org/wiki/Romanization_of_Georgian
        // National system (2002)
        ა: "a",
        ბ: "b",
        გ: "g",
        დ: "d",
        ე: "e",
        ვ: "v",
        ზ: "z",
        თ: "t",
        ი: "i",
        კ: "k",
        ლ: "l",
        მ: "m",
        ნ: "n",
        ო: "o",
        პ: "p",
        ჟ: "zh",
        რ: "r",
        ს: "s",
        ტ: "t",
        უ: "u",
        ფ: "p",
        ქ: "k",
        ღ: "gh",
        ყ: "q",
        შ: "sh",
        ჩ: "ch",
        ც: "ts",
        ძ: "dz",
        წ: "ts",
        ჭ: "ch",
        ხ: "kh",
        ჯ: "j",
        ჰ: "h",
        // Greek
        α: "a",
        β: "v",
        γ: "g",
        δ: "d",
        ε: "e",
        ζ: "z",
        η: "i",
        θ: "th",
        ι: "i",
        κ: "k",
        λ: "l",
        μ: "m",
        ν: "n",
        ξ: "ks",
        ο: "o",
        π: "p",
        ρ: "r",
        σ: "s",
        τ: "t",
        υ: "y",
        φ: "f",
        χ: "x",
        ψ: "ps",
        ω: "o",
        ά: "a",
        έ: "e",
        ί: "i",
        ό: "o",
        ύ: "y",
        ή: "i",
        ώ: "o",
        ς: "s",
        ϊ: "i",
        ΰ: "y",
        ϋ: "y",
        ΐ: "i",
        Α: "A",
        Β: "B",
        Γ: "G",
        Δ: "D",
        Ε: "E",
        Ζ: "Z",
        Η: "I",
        Θ: "TH",
        Ι: "I",
        Κ: "K",
        Λ: "L",
        Μ: "M",
        Ν: "N",
        Ξ: "KS",
        Ο: "O",
        Π: "P",
        Ρ: "R",
        Σ: "S",
        Τ: "T",
        Υ: "Y",
        Φ: "F",
        Χ: "X",
        Ψ: "PS",
        Ω: "O",
        Ά: "A",
        Έ: "E",
        Ί: "I",
        Ό: "O",
        Ύ: "Y",
        Ή: "I",
        Ώ: "O",
        Ϊ: "I",
        Ϋ: "Y",
        // Latvian
        ā: "a",
        // 'č': 'c', // duplicate
        ē: "e",
        ģ: "g",
        ī: "i",
        ķ: "k",
        ļ: "l",
        ņ: "n",
        // 'š': 's', // duplicate
        ū: "u",
        // 'ž': 'z', // duplicate
        Ā: "A",
        // 'Č': 'C', // duplicate
        Ē: "E",
        Ģ: "G",
        Ī: "I",
        Ķ: "k",
        Ļ: "L",
        Ņ: "N",
        // 'Š': 'S', // duplicate
        Ū: "U",
        // 'Ž': 'Z', // duplicate
        // Macedonian
        Ќ: "Kj",
        ќ: "kj",
        Љ: "Lj",
        љ: "lj",
        Њ: "Nj",
        њ: "nj",
        Тс: "Ts",
        тс: "ts",
        // Polish
        ą: "a",
        ć: "c",
        ę: "e",
        ł: "l",
        ń: "n",
        // 'ó': 'o', // duplicate
        ś: "s",
        ź: "z",
        ż: "z",
        Ą: "A",
        Ć: "C",
        Ę: "E",
        Ł: "L",
        Ń: "N",
        Ś: "S",
        Ź: "Z",
        Ż: "Z",
        // Ukranian
        Є: "Ye",
        І: "I",
        Ї: "Yi",
        Ґ: "G",
        є: "ye",
        і: "i",
        ї: "yi",
        ґ: "g",
        // Romanian
        ă: "a",
        Ă: "A",
        ș: "s",
        Ș: "S",
        // 'ş': 's', // duplicate
        // 'Ş': 'S', // duplicate
        ț: "t",
        Ț: "T",
        ţ: "t",
        Ţ: "T",
        // Russian https://en.wikipedia.org/wiki/Romanization_of_Russian
        // ICAO
        а: "a",
        б: "b",
        в: "v",
        г: "g",
        д: "d",
        е: "e",
        ё: "yo",
        ж: "zh",
        з: "z",
        и: "i",
        й: "i",
        к: "k",
        л: "l",
        м: "m",
        н: "n",
        о: "o",
        п: "p",
        р: "r",
        с: "s",
        т: "t",
        у: "u",
        ф: "f",
        х: "kh",
        ц: "c",
        ч: "ch",
        ш: "sh",
        щ: "sh",
        ъ: "",
        ы: "y",
        ь: "",
        э: "e",
        ю: "yu",
        я: "ya",
        А: "A",
        Б: "B",
        В: "V",
        Г: "G",
        Д: "D",
        Е: "E",
        Ё: "Yo",
        Ж: "Zh",
        З: "Z",
        И: "I",
        Й: "I",
        К: "K",
        Л: "L",
        М: "M",
        Н: "N",
        О: "O",
        П: "P",
        Р: "R",
        С: "S",
        Т: "T",
        У: "U",
        Ф: "F",
        Х: "Kh",
        Ц: "C",
        Ч: "Ch",
        Ш: "Sh",
        Щ: "Sh",
        Ъ: "",
        Ы: "Y",
        Ь: "",
        Э: "E",
        Ю: "Yu",
        Я: "Ya",
        // Serbian
        ђ: "dj",
        ј: "j",
        // 'љ': 'lj',  // duplicate
        // 'њ': 'nj', // duplicate
        ћ: "c",
        џ: "dz",
        Ђ: "Dj",
        Ј: "j",
        // 'Љ': 'Lj', // duplicate
        // 'Њ': 'Nj', // duplicate
        Ћ: "C",
        Џ: "Dz",
        // Slovak
        ľ: "l",
        ĺ: "l",
        ŕ: "r",
        Ľ: "L",
        Ĺ: "L",
        Ŕ: "R",
        // Turkish
        ş: "s",
        Ş: "S",
        ı: "i",
        İ: "I",
        // 'ç': 'c', // duplicate
        // 'Ç': 'C', // duplicate
        // 'ü': 'u', // duplicate, see langCharMap
        // 'Ü': 'U', // duplicate, see langCharMap
        // 'ö': 'o', // duplicate, see langCharMap
        // 'Ö': 'O', // duplicate, see langCharMap
        ğ: "g",
        Ğ: "G",
        // Vietnamese
        ả: "a",
        Ả: "A",
        ẳ: "a",
        Ẳ: "A",
        ẩ: "a",
        Ẩ: "A",
        đ: "d",
        Đ: "D",
        ẹ: "e",
        Ẹ: "E",
        ẽ: "e",
        Ẽ: "E",
        ẻ: "e",
        Ẻ: "E",
        ế: "e",
        Ế: "E",
        ề: "e",
        Ề: "E",
        ệ: "e",
        Ệ: "E",
        ễ: "e",
        Ễ: "E",
        ể: "e",
        Ể: "E",
        ỏ: "o",
        ọ: "o",
        Ọ: "o",
        ố: "o",
        Ố: "O",
        ồ: "o",
        Ồ: "O",
        ổ: "o",
        Ổ: "O",
        ộ: "o",
        Ộ: "O",
        ỗ: "o",
        Ỗ: "O",
        ơ: "o",
        Ơ: "O",
        ớ: "o",
        Ớ: "O",
        ờ: "o",
        Ờ: "O",
        ợ: "o",
        Ợ: "O",
        ỡ: "o",
        Ỡ: "O",
        Ở: "o",
        ở: "o",
        ị: "i",
        Ị: "I",
        ĩ: "i",
        Ĩ: "I",
        ỉ: "i",
        Ỉ: "i",
        ủ: "u",
        Ủ: "U",
        ụ: "u",
        Ụ: "U",
        ũ: "u",
        Ũ: "U",
        ư: "u",
        Ư: "U",
        ứ: "u",
        Ứ: "U",
        ừ: "u",
        Ừ: "U",
        ự: "u",
        Ự: "U",
        ữ: "u",
        Ữ: "U",
        ử: "u",
        Ử: "ư",
        ỷ: "y",
        Ỷ: "y",
        ỳ: "y",
        Ỳ: "Y",
        ỵ: "y",
        Ỵ: "Y",
        ỹ: "y",
        Ỹ: "Y",
        ạ: "a",
        Ạ: "A",
        ấ: "a",
        Ấ: "A",
        ầ: "a",
        Ầ: "A",
        ậ: "a",
        Ậ: "A",
        ẫ: "a",
        Ẫ: "A",
        // 'ă': 'a', // duplicate
        // 'Ă': 'A', // duplicate
        ắ: "a",
        Ắ: "A",
        ằ: "a",
        Ằ: "A",
        ặ: "a",
        Ặ: "A",
        ẵ: "a",
        Ẵ: "A",
        "⓪": "0",
        "①": "1",
        "②": "2",
        "③": "3",
        "④": "4",
        "⑤": "5",
        "⑥": "6",
        "⑦": "7",
        "⑧": "8",
        "⑨": "9",
        "⑩": "10",
        "⑪": "11",
        "⑫": "12",
        "⑬": "13",
        "⑭": "14",
        "⑮": "15",
        "⑯": "16",
        "⑰": "17",
        "⑱": "18",
        "⑲": "18",
        "⑳": "18",
        "⓵": "1",
        "⓶": "2",
        "⓷": "3",
        "⓸": "4",
        "⓹": "5",
        "⓺": "6",
        "⓻": "7",
        "⓼": "8",
        "⓽": "9",
        "⓾": "10",
        "⓿": "0",
        "⓫": "11",
        "⓬": "12",
        "⓭": "13",
        "⓮": "14",
        "⓯": "15",
        "⓰": "16",
        "⓱": "17",
        "⓲": "18",
        "⓳": "19",
        "⓴": "20",
        "Ⓐ": "A",
        "Ⓑ": "B",
        "Ⓒ": "C",
        "Ⓓ": "D",
        "Ⓔ": "E",
        "Ⓕ": "F",
        "Ⓖ": "G",
        "Ⓗ": "H",
        "Ⓘ": "I",
        "Ⓙ": "J",
        "Ⓚ": "K",
        "Ⓛ": "L",
        "Ⓜ": "M",
        "Ⓝ": "N",
        "Ⓞ": "O",
        "Ⓟ": "P",
        "Ⓠ": "Q",
        "Ⓡ": "R",
        "Ⓢ": "S",
        "Ⓣ": "T",
        "Ⓤ": "U",
        "Ⓥ": "V",
        "Ⓦ": "W",
        "Ⓧ": "X",
        "Ⓨ": "Y",
        "Ⓩ": "Z",
        "ⓐ": "a",
        "ⓑ": "b",
        "ⓒ": "c",
        "ⓓ": "d",
        "ⓔ": "e",
        "ⓕ": "f",
        "ⓖ": "g",
        "ⓗ": "h",
        "ⓘ": "i",
        "ⓙ": "j",
        "ⓚ": "k",
        "ⓛ": "l",
        "ⓜ": "m",
        "ⓝ": "n",
        "ⓞ": "o",
        "ⓟ": "p",
        "ⓠ": "q",
        "ⓡ": "r",
        "ⓢ": "s",
        "ⓣ": "t",
        "ⓤ": "u",
        "ⓦ": "v",
        "ⓥ": "w",
        "ⓧ": "x",
        "ⓨ": "y",
        "ⓩ": "z",
        // symbols
        "“": '"',
        "”": '"',
        "‘": "'",
        "’": "'",
        "∂": "d",
        ƒ: "f",
        "™": "(TM)",
        "©": "(C)",
        œ: "oe",
        Œ: "OE",
        "®": "(R)",
        "†": "+",
        "℠": "(SM)",
        "…": "...",
        "˚": "o",
        º: "o",
        ª: "a",
        "•": "*",
        "၊": ",",
        "။": ".",
        // currency
        $: "USD",
        "€": "EUR",
        "₢": "BRN",
        "₣": "FRF",
        "£": "GBP",
        "₤": "ITL",
        "₦": "NGN",
        "₧": "ESP",
        "₩": "KRW",
        "₪": "ILS",
        "₫": "VND",
        "₭": "LAK",
        "₮": "MNT",
        "₯": "GRD",
        "₱": "ARS",
        "₲": "PYG",
        "₳": "ARA",
        "₴": "UAH",
        "₵": "GHS",
        "¢": "cent",
        "¥": "CNY",
        元: "CNY",
        円: "YEN",
        "﷼": "IRR",
        "₠": "EWE",
        "฿": "THB",
        "₨": "INR",
        "₹": "INR",
        "₰": "PF",
        "₺": "TRY",
        "؋": "AFN",
        "₼": "AZN",
        лв: "BGN",
        "៛": "KHR",
        "₡": "CRC",
        "₸": "KZT",
        ден: "MKD",
        zł: "PLN",
        "₽": "RUB",
        "₾": "GEL"
      }, o = [
        // burmese
        "်",
        // Dhivehi
        "ް"
      ], i = {
        // Burmese
        // dependent vowels
        "ာ": "a",
        "ါ": "a",
        "ေ": "e",
        "ဲ": "e",
        "ိ": "i",
        "ီ": "i",
        "ို": "o",
        "ု": "u",
        "ူ": "u",
        "ေါင်": "aung",
        "ော": "aw",
        "ော်": "aw",
        "ေါ": "aw",
        "ေါ်": "aw",
        "်": "်",
        // this is special case but the character will be converted to latin in the code
        "က်": "et",
        "ိုက်": "aik",
        "ောက်": "auk",
        "င်": "in",
        "ိုင်": "aing",
        "ောင်": "aung",
        "စ်": "it",
        "ည်": "i",
        "တ်": "at",
        "ိတ်": "eik",
        "ုတ်": "ok",
        "ွတ်": "ut",
        "ေတ်": "it",
        "ဒ်": "d",
        "ိုဒ်": "ok",
        "ုဒ်": "ait",
        "န်": "an",
        "ာန်": "an",
        "ိန်": "ein",
        "ုန်": "on",
        "ွန်": "un",
        "ပ်": "at",
        "ိပ်": "eik",
        "ုပ်": "ok",
        "ွပ်": "ut",
        "န်ုပ်": "nub",
        "မ်": "an",
        "ိမ်": "ein",
        "ုမ်": "on",
        "ွမ်": "un",
        "ယ်": "e",
        "ိုလ်": "ol",
        "ဉ်": "in",
        "ံ": "an",
        "ိံ": "ein",
        "ုံ": "on",
        // Dhivehi
        "ައް": "ah",
        "ަށް": "ah"
      }, s = {
        en: {},
        // default language
        az: {
          // Azerbaijani
          ç: "c",
          ə: "e",
          ğ: "g",
          ı: "i",
          ö: "o",
          ş: "s",
          ü: "u",
          Ç: "C",
          Ə: "E",
          Ğ: "G",
          İ: "I",
          Ö: "O",
          Ş: "S",
          Ü: "U"
        },
        cs: {
          // Czech
          č: "c",
          ď: "d",
          ě: "e",
          ň: "n",
          ř: "r",
          š: "s",
          ť: "t",
          ů: "u",
          ž: "z",
          Č: "C",
          Ď: "D",
          Ě: "E",
          Ň: "N",
          Ř: "R",
          Š: "S",
          Ť: "T",
          Ů: "U",
          Ž: "Z"
        },
        fi: {
          // Finnish
          // 'å': 'a', duplicate see charMap/latin
          // 'Å': 'A', duplicate see charMap/latin
          ä: "a",
          // ok
          Ä: "A",
          // ok
          ö: "o",
          // ok
          Ö: "O"
          // ok
        },
        hu: {
          // Hungarian
          ä: "a",
          // ok
          Ä: "A",
          // ok
          // 'á': 'a', duplicate see charMap/latin
          // 'Á': 'A', duplicate see charMap/latin
          ö: "o",
          // ok
          Ö: "O",
          // ok
          // 'ő': 'o', duplicate see charMap/latin
          // 'Ő': 'O', duplicate see charMap/latin
          ü: "u",
          Ü: "U",
          ű: "u",
          Ű: "U"
        },
        lt: {
          // Lithuanian
          ą: "a",
          č: "c",
          ę: "e",
          ė: "e",
          į: "i",
          š: "s",
          ų: "u",
          ū: "u",
          ž: "z",
          Ą: "A",
          Č: "C",
          Ę: "E",
          Ė: "E",
          Į: "I",
          Š: "S",
          Ų: "U",
          Ū: "U"
        },
        lv: {
          // Latvian
          ā: "a",
          č: "c",
          ē: "e",
          ģ: "g",
          ī: "i",
          ķ: "k",
          ļ: "l",
          ņ: "n",
          š: "s",
          ū: "u",
          ž: "z",
          Ā: "A",
          Č: "C",
          Ē: "E",
          Ģ: "G",
          Ī: "i",
          Ķ: "k",
          Ļ: "L",
          Ņ: "N",
          Š: "S",
          Ū: "u",
          Ž: "Z"
        },
        pl: {
          // Polish
          ą: "a",
          ć: "c",
          ę: "e",
          ł: "l",
          ń: "n",
          ó: "o",
          ś: "s",
          ź: "z",
          ż: "z",
          Ą: "A",
          Ć: "C",
          Ę: "e",
          Ł: "L",
          Ń: "N",
          Ó: "O",
          Ś: "S",
          Ź: "Z",
          Ż: "Z"
        },
        sv: {
          // Swedish
          // 'å': 'a', duplicate see charMap/latin
          // 'Å': 'A', duplicate see charMap/latin
          ä: "a",
          // ok
          Ä: "A",
          // ok
          ö: "o",
          // ok
          Ö: "O"
          // ok
        },
        sk: {
          // Slovak
          ä: "a",
          Ä: "A"
        },
        sr: {
          // Serbian
          љ: "lj",
          њ: "nj",
          Љ: "Lj",
          Њ: "Nj",
          đ: "dj",
          Đ: "Dj"
        },
        tr: {
          // Turkish
          Ü: "U",
          Ö: "O",
          ü: "u",
          ö: "o"
        }
      }, a = {
        ar: {
          "∆": "delta",
          "∞": "la-nihaya",
          "♥": "hob",
          "&": "wa",
          "|": "aw",
          "<": "aqal-men",
          ">": "akbar-men",
          "∑": "majmou",
          "¤": "omla"
        },
        az: {},
        ca: {
          "∆": "delta",
          "∞": "infinit",
          "♥": "amor",
          "&": "i",
          "|": "o",
          "<": "menys que",
          ">": "mes que",
          "∑": "suma dels",
          "¤": "moneda"
        },
        cs: {
          "∆": "delta",
          "∞": "nekonecno",
          "♥": "laska",
          "&": "a",
          "|": "nebo",
          "<": "mensi nez",
          ">": "vetsi nez",
          "∑": "soucet",
          "¤": "mena"
        },
        de: {
          "∆": "delta",
          "∞": "unendlich",
          "♥": "Liebe",
          "&": "und",
          "|": "oder",
          "<": "kleiner als",
          ">": "groesser als",
          "∑": "Summe von",
          "¤": "Waehrung"
        },
        dv: {
          "∆": "delta",
          "∞": "kolunulaa",
          "♥": "loabi",
          "&": "aai",
          "|": "noonee",
          "<": "ah vure kuda",
          ">": "ah vure bodu",
          "∑": "jumula",
          "¤": "faisaa"
        },
        en: {
          "∆": "delta",
          "∞": "infinity",
          "♥": "love",
          "&": "and",
          "|": "or",
          "<": "less than",
          ">": "greater than",
          "∑": "sum",
          "¤": "currency"
        },
        es: {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amor",
          "&": "y",
          "|": "u",
          "<": "menos que",
          ">": "mas que",
          "∑": "suma de los",
          "¤": "moneda"
        },
        fa: {
          "∆": "delta",
          "∞": "bi-nahayat",
          "♥": "eshgh",
          "&": "va",
          "|": "ya",
          "<": "kamtar-az",
          ">": "bishtar-az",
          "∑": "majmooe",
          "¤": "vahed"
        },
        fi: {
          "∆": "delta",
          "∞": "aarettomyys",
          "♥": "rakkaus",
          "&": "ja",
          "|": "tai",
          "<": "pienempi kuin",
          ">": "suurempi kuin",
          "∑": "summa",
          "¤": "valuutta"
        },
        fr: {
          "∆": "delta",
          "∞": "infiniment",
          "♥": "Amour",
          "&": "et",
          "|": "ou",
          "<": "moins que",
          ">": "superieure a",
          "∑": "somme des",
          "¤": "monnaie"
        },
        ge: {
          "∆": "delta",
          "∞": "usasruloba",
          "♥": "siqvaruli",
          "&": "da",
          "|": "an",
          "<": "naklebi",
          ">": "meti",
          "∑": "jami",
          "¤": "valuta"
        },
        gr: {},
        hu: {
          "∆": "delta",
          "∞": "vegtelen",
          "♥": "szerelem",
          "&": "es",
          "|": "vagy",
          "<": "kisebb mint",
          ">": "nagyobb mint",
          "∑": "szumma",
          "¤": "penznem"
        },
        it: {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amore",
          "&": "e",
          "|": "o",
          "<": "minore di",
          ">": "maggiore di",
          "∑": "somma",
          "¤": "moneta"
        },
        lt: {
          "∆": "delta",
          "∞": "begalybe",
          "♥": "meile",
          "&": "ir",
          "|": "ar",
          "<": "maziau nei",
          ">": "daugiau nei",
          "∑": "suma",
          "¤": "valiuta"
        },
        lv: {
          "∆": "delta",
          "∞": "bezgaliba",
          "♥": "milestiba",
          "&": "un",
          "|": "vai",
          "<": "mazak neka",
          ">": "lielaks neka",
          "∑": "summa",
          "¤": "valuta"
        },
        my: {
          "∆": "kwahkhyaet",
          "∞": "asaonasme",
          "♥": "akhyait",
          "&": "nhin",
          "|": "tho",
          "<": "ngethaw",
          ">": "kyithaw",
          "∑": "paungld",
          "¤": "ngwekye"
        },
        mk: {},
        nl: {
          "∆": "delta",
          "∞": "oneindig",
          "♥": "liefde",
          "&": "en",
          "|": "of",
          "<": "kleiner dan",
          ">": "groter dan",
          "∑": "som",
          "¤": "valuta"
        },
        pl: {
          "∆": "delta",
          "∞": "nieskonczonosc",
          "♥": "milosc",
          "&": "i",
          "|": "lub",
          "<": "mniejsze niz",
          ">": "wieksze niz",
          "∑": "suma",
          "¤": "waluta"
        },
        pt: {
          "∆": "delta",
          "∞": "infinito",
          "♥": "amor",
          "&": "e",
          "|": "ou",
          "<": "menor que",
          ">": "maior que",
          "∑": "soma",
          "¤": "moeda"
        },
        ro: {
          "∆": "delta",
          "∞": "infinit",
          "♥": "dragoste",
          "&": "si",
          "|": "sau",
          "<": "mai mic ca",
          ">": "mai mare ca",
          "∑": "suma",
          "¤": "valuta"
        },
        ru: {
          "∆": "delta",
          "∞": "beskonechno",
          "♥": "lubov",
          "&": "i",
          "|": "ili",
          "<": "menshe",
          ">": "bolshe",
          "∑": "summa",
          "¤": "valjuta"
        },
        sk: {
          "∆": "delta",
          "∞": "nekonecno",
          "♥": "laska",
          "&": "a",
          "|": "alebo",
          "<": "menej ako",
          ">": "viac ako",
          "∑": "sucet",
          "¤": "mena"
        },
        sr: {},
        tr: {
          "∆": "delta",
          "∞": "sonsuzluk",
          "♥": "ask",
          "&": "ve",
          "|": "veya",
          "<": "kucuktur",
          ">": "buyuktur",
          "∑": "toplam",
          "¤": "para birimi"
        },
        uk: {
          "∆": "delta",
          "∞": "bezkinechnist",
          "♥": "lubov",
          "&": "i",
          "|": "abo",
          "<": "menshe",
          ">": "bilshe",
          "∑": "suma",
          "¤": "valjuta"
        },
        vn: {
          "∆": "delta",
          "∞": "vo cuc",
          "♥": "yeu",
          "&": "va",
          "|": "hoac",
          "<": "nho hon",
          ">": "lon hon",
          "∑": "tong",
          "¤": "tien te"
        }
      }, u = [";", "?", ":", "@", "&", "=", "+", "$", ",", "/"].join(""), l = [";", "?", ":", "@", "&", "=", "+", "$", ","].join(""), c = [".", "!", "~", "*", "'", "(", ")"].join(""), f = function(p, g) {
        var C = "-", b = "", P = "", M = !0, A = {}, O, T, E, x, R, Ut, de, te, Ht, z, w, Se, H, ne, K = "";
        if (typeof p != "string")
          return "";
        if (typeof g == "string" && (C = g), de = a.en, te = s.en, typeof g == "object") {
          O = g.maintainCase || !1, A = g.custom && typeof g.custom == "object" ? g.custom : A, E = +g.truncate > 1 && g.truncate || !1, x = g.uric || !1, R = g.uricNoSlash || !1, Ut = g.mark || !1, M = !(g.symbols === !1 || g.lang === !1), C = g.separator || C, x && (K += u), R && (K += l), Ut && (K += c), de = g.lang && a[g.lang] && M ? a[g.lang] : M ? a.en : {}, te = g.lang && s[g.lang] ? s[g.lang] : g.lang === !1 || g.lang === !0 ? {} : s.en, g.titleCase && typeof g.titleCase.length == "number" && Array.prototype.toString.call(g.titleCase) ? (g.titleCase.forEach(function(U) {
            A[U + ""] = U + "";
          }), T = !0) : T = !!g.titleCase, g.custom && typeof g.custom.length == "number" && Array.prototype.toString.call(g.custom) && g.custom.forEach(function(U) {
            A[U + ""] = U + "";
          }), Object.keys(A).forEach(function(U) {
            var pe;
            U.length > 1 ? pe = new RegExp("\\b" + d(U) + "\\b", "gi") : pe = new RegExp(d(U), "gi"), p = p.replace(pe, A[U]);
          });
          for (w in A)
            K += w;
        }
        for (K += C, K = d(K), p = p.replace(/(^\s+|\s+$)/g, ""), H = !1, ne = !1, z = 0, Se = p.length; z < Se; z++)
          w = p[z], _(w, A) ? H = !1 : te[w] ? (w = H && te[w].match(/[A-Za-z0-9]/) ? " " + te[w] : te[w], H = !1) : w in r ? (z + 1 < Se && o.indexOf(p[z + 1]) >= 0 ? (P += w, w = "") : ne === !0 ? (w = i[P] + r[w], P = "") : w = H && r[w].match(/[A-Za-z0-9]/) ? " " + r[w] : r[w], H = !1, ne = !1) : w in i ? (P += w, w = "", z === Se - 1 && (w = i[P]), ne = !0) : /* process symbol chars */ de[w] && !(x && u.indexOf(w) !== -1) && !(R && l.indexOf(w) !== -1) ? (w = H || b.substr(-1).match(/[A-Za-z0-9]/) ? C + de[w] : de[w], w += p[z + 1] !== void 0 && p[z + 1].match(/[A-Za-z0-9]/) ? C : "", H = !0) : (ne === !0 ? (w = i[P] + w, P = "", ne = !1) : H && (/[A-Za-z0-9]/.test(w) || b.substr(-1).match(/A-Za-z0-9]/)) && (w = " " + w), H = !1), b += w.replace(new RegExp("[^\\w\\s" + K + "_-]", "g"), C);
        return T && (b = b.replace(/(\w)(\S*)/g, function(U, pe, jt) {
          var Ye = pe.toUpperCase() + (jt !== null ? jt : "");
          return Object.keys(A).indexOf(Ye.toLowerCase()) < 0 ? Ye : Ye.toLowerCase();
        })), b = b.replace(/\s+/g, C).replace(new RegExp("\\" + C + "+", "g"), C).replace(new RegExp("(^\\" + C + "+|\\" + C + "+$)", "g"), ""), E && b.length > E && (Ht = b.charAt(E) === C, b = b.slice(0, E), Ht || (b = b.slice(0, b.lastIndexOf(C)))), !O && !T && (b = b.toLowerCase()), b;
      }, h = function(p) {
        return function(C) {
          return f(C, p);
        };
      }, d = function(p) {
        return p.replace(/[-\\^$*+?.()|[\]{}\/]/g, "\\$&");
      }, _ = function(v, p) {
        for (var g in p)
          if (p[g] === v)
            return !0;
      };
      if (typeof t < "u" && t.exports)
        t.exports = f, t.exports.createSlug = h;
      else if (typeof define < "u" && define.amd)
        define([], function() {
          return f;
        });
      else
        try {
          if (n.getSlug || n.createSlug)
            throw "speakingurl: globals exists /(getSlug|createSlug)/";
          n.getSlug = f, n.createSlug = h;
        } catch {
        }
    })(e);
  }
}), ga = qr({
  "../../node_modules/.pnpm/speakingurl@14.0.1/node_modules/speakingurl/index.js"(e, t) {
    m(), t.exports = ma();
  }
});
m();
m();
m();
m();
m();
m();
m();
m();
function Ea(e) {
  var t;
  const n = e.name || e._componentTag || e.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ || e.__name;
  return n === "index" && ((t = e.__file) != null && t.endsWith("index.vue")) ? "" : n;
}
function va(e) {
  const t = e.__file;
  if (t)
    return ea(ta(t, ".vue"));
}
function mn(e, t) {
  return e.type.__VUE_DEVTOOLS_COMPONENT_GUSSED_NAME__ = t, t;
}
function Dt(e) {
  if (e.__VUE_DEVTOOLS_NEXT_APP_RECORD__)
    return e.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
  if (e.root)
    return e.appContext.app.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
}
function Xr(e) {
  var t, n;
  const r = (t = e.subTree) == null ? void 0 : t.type, o = Dt(e);
  return o ? ((n = o?.types) == null ? void 0 : n.Fragment) === r : !1;
}
function Ke(e) {
  var t, n, r;
  const o = Ea(e?.type || {});
  if (o)
    return o;
  if (e?.root === e)
    return "Root";
  for (const s in (n = (t = e.parent) == null ? void 0 : t.type) == null ? void 0 : n.components)
    if (e.parent.type.components[s] === e?.type)
      return mn(e, s);
  for (const s in (r = e.appContext) == null ? void 0 : r.components)
    if (e.appContext.components[s] === e?.type)
      return mn(e, s);
  const i = va(e?.type || {});
  return i || "Anonymous Component";
}
function ya(e) {
  var t, n, r;
  const o = (r = (n = (t = e?.appContext) == null ? void 0 : t.app) == null ? void 0 : n.__VUE_DEVTOOLS_NEXT_APP_RECORD_ID__) != null ? r : 0, i = e === e?.root ? "root" : e.uid;
  return `${o}:${i}`;
}
function _t(e, t) {
  return t = t || `${e.id}:root`, e.instanceMap.get(t) || e.instanceMap.get(":root");
}
function Ca() {
  const e = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    get width() {
      return e.right - e.left;
    },
    get height() {
      return e.bottom - e.top;
    }
  };
  return e;
}
var Ie;
function ba(e) {
  return Ie || (Ie = document.createRange()), Ie.selectNode(e), Ie.getBoundingClientRect();
}
function wa(e) {
  const t = Ca();
  if (!e.children)
    return t;
  for (let n = 0, r = e.children.length; n < r; n++) {
    const o = e.children[n];
    let i;
    if (o.component)
      i = ee(o.component);
    else if (o.el) {
      const s = o.el;
      s.nodeType === 1 || s.getBoundingClientRect ? i = s.getBoundingClientRect() : s.nodeType === 3 && s.data.trim() && (i = ba(s));
    }
    i && Aa(t, i);
  }
  return t;
}
function Aa(e, t) {
  return (!e.top || t.top < e.top) && (e.top = t.top), (!e.bottom || t.bottom > e.bottom) && (e.bottom = t.bottom), (!e.left || t.left < e.left) && (e.left = t.left), (!e.right || t.right > e.right) && (e.right = t.right), e;
}
var gn = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  width: 0,
  height: 0
};
function ee(e) {
  const t = e.subTree.el;
  return typeof window > "u" ? gn : Xr(e) ? wa(e.subTree) : t?.nodeType === 1 ? t?.getBoundingClientRect() : e.subTree.component ? ee(e.subTree.component) : gn;
}
m();
function kt(e) {
  return Xr(e) ? Ta(e.subTree) : e.subTree ? [e.subTree.el] : [];
}
function Ta(e) {
  if (!e.children)
    return [];
  const t = [];
  return e.children.forEach((n) => {
    n.component ? t.push(...kt(n.component)) : n?.el && t.push(n.el);
  }), t;
}
var Qr = "__vue-devtools-component-inspector__", Zr = "__vue-devtools-component-inspector__card__", Jr = "__vue-devtools-component-inspector__name__", eo = "__vue-devtools-component-inspector__indicator__", to = {
  display: "block",
  zIndex: 2147483640,
  position: "fixed",
  backgroundColor: "#42b88325",
  border: "1px solid #42b88350",
  borderRadius: "5px",
  transition: "all 0.1s ease-in",
  pointerEvents: "none"
}, Oa = {
  fontFamily: "Arial, Helvetica, sans-serif",
  padding: "5px 8px",
  borderRadius: "4px",
  textAlign: "left",
  position: "absolute",
  left: 0,
  color: "#e9e9e9",
  fontSize: "14px",
  fontWeight: 600,
  lineHeight: "24px",
  backgroundColor: "#42b883",
  boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1)"
}, Sa = {
  display: "inline-block",
  fontWeight: 400,
  fontStyle: "normal",
  fontSize: "12px",
  opacity: 0.7
};
function ce() {
  return document.getElementById(Qr);
}
function Pa() {
  return document.getElementById(Zr);
}
function Ia() {
  return document.getElementById(eo);
}
function Da() {
  return document.getElementById(Jr);
}
function xt(e) {
  return {
    left: `${Math.round(e.left * 100) / 100}px`,
    top: `${Math.round(e.top * 100) / 100}px`,
    width: `${Math.round(e.width * 100) / 100}px`,
    height: `${Math.round(e.height * 100) / 100}px`
  };
}
function Rt(e) {
  var t;
  const n = document.createElement("div");
  n.id = (t = e.elementId) != null ? t : Qr, Object.assign(n.style, {
    ...to,
    ...xt(e.bounds),
    ...e.style
  });
  const r = document.createElement("span");
  r.id = Zr, Object.assign(r.style, {
    ...Oa,
    top: e.bounds.top < 35 ? 0 : "-35px"
  });
  const o = document.createElement("span");
  o.id = Jr, o.innerHTML = `&lt;${e.name}&gt;&nbsp;&nbsp;`;
  const i = document.createElement("i");
  return i.id = eo, i.innerHTML = `${Math.round(e.bounds.width * 100) / 100} x ${Math.round(e.bounds.height * 100) / 100}`, Object.assign(i.style, Sa), r.appendChild(o), r.appendChild(i), n.appendChild(r), document.body.appendChild(n), n;
}
function Lt(e) {
  const t = ce(), n = Pa(), r = Da(), o = Ia();
  t && (Object.assign(t.style, {
    ...to,
    ...xt(e.bounds)
  }), Object.assign(n.style, {
    top: e.bounds.top < 35 ? 0 : "-35px"
  }), r.innerHTML = `&lt;${e.name}&gt;&nbsp;&nbsp;`, o.innerHTML = `${Math.round(e.bounds.width * 100) / 100} x ${Math.round(e.bounds.height * 100) / 100}`);
}
function ka(e) {
  const t = ee(e);
  if (!t.width && !t.height)
    return;
  const n = Ke(e);
  ce() ? Lt({ bounds: t, name: n }) : Rt({ bounds: t, name: n });
}
function no() {
  const e = ce();
  e && (e.style.display = "none");
}
var mt = null;
function gt(e) {
  const t = e.target;
  if (t) {
    const n = t.__vueParentComponent;
    if (n && (mt = n, n.vnode.el)) {
      const o = ee(n), i = Ke(n);
      ce() ? Lt({ bounds: o, name: i }) : Rt({ bounds: o, name: i });
    }
  }
}
function xa(e, t) {
  if (e.preventDefault(), e.stopPropagation(), mt) {
    const n = ya(mt);
    t(n);
  }
}
var Ue = null;
function Ra() {
  no(), window.removeEventListener("mouseover", gt), window.removeEventListener("click", Ue, !0), Ue = null;
}
function La() {
  return window.addEventListener("mouseover", gt), new Promise((e) => {
    function t(n) {
      n.preventDefault(), n.stopPropagation(), xa(n, (r) => {
        window.removeEventListener("click", t, !0), Ue = null, window.removeEventListener("mouseover", gt);
        const o = ce();
        o && (o.style.display = "none"), e(JSON.stringify({ id: r }));
      });
    }
    Ue = t, window.addEventListener("click", t, !0);
  });
}
function Fa(e) {
  const t = _t(F.value, e.id);
  if (t) {
    const [n] = kt(t);
    if (typeof n.scrollIntoView == "function")
      n.scrollIntoView({
        behavior: "smooth"
      });
    else {
      const r = ee(t), o = document.createElement("div"), i = {
        ...xt(r),
        position: "absolute"
      };
      Object.assign(o.style, i), document.body.appendChild(o), o.scrollIntoView({
        behavior: "smooth"
      }), setTimeout(() => {
        document.body.removeChild(o);
      }, 2e3);
    }
    setTimeout(() => {
      const r = ee(t);
      if (r.width || r.height) {
        const o = Ke(t), i = ce();
        i ? Lt({ ...e, name: o, bounds: r }) : Rt({ ...e, name: o, bounds: r }), setTimeout(() => {
          i && (i.style.display = "none");
        }, 1500);
      }
    }, 1200);
  }
}
m();
var En, vn;
(vn = (En = y).__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__) != null || (En.__VUE_DEVTOOLS_COMPONENT_INSPECTOR_ENABLED__ = !0);
function Ma(e) {
  let t = 0;
  const n = setInterval(() => {
    y.__VUE_INSPECTOR__ && (clearInterval(n), t += 30, e()), t >= /* 5s */
    5e3 && clearInterval(n);
  }, 30);
}
function Na() {
  const e = y.__VUE_INSPECTOR__, t = e.openInEditor;
  e.openInEditor = async (...n) => {
    e.disable(), t(...n);
  };
}
function Va() {
  return new Promise((e) => {
    function t() {
      Na(), e(y.__VUE_INSPECTOR__);
    }
    y.__VUE_INSPECTOR__ ? t() : Ma(() => {
      t();
    });
  });
}
m();
m();
function Ba(e) {
  return !!(e && e.__v_isReadonly);
}
function ro(e) {
  return Ba(e) ? ro(e.__v_raw) : !!(e && e.__v_isReactive);
}
function nt(e) {
  return !!(e && e.__v_isRef === !0);
}
function _e(e) {
  const t = e && e.__v_raw;
  return t ? _e(t) : e;
}
var Ua = class {
  constructor() {
    this.refEditor = new Ha();
  }
  set(e, t, n, r) {
    const o = Array.isArray(t) ? t : t.split(".");
    for (; o.length > 1; ) {
      const a = o.shift();
      e instanceof Map ? e = e.get(a) : e instanceof Set ? e = Array.from(e.values())[a] : e = e[a], this.refEditor.isRef(e) && (e = this.refEditor.get(e));
    }
    const i = o[0], s = this.refEditor.get(e)[i];
    r ? r(e, i, n) : this.refEditor.isRef(s) ? this.refEditor.set(s, n) : e[i] = n;
  }
  get(e, t) {
    const n = Array.isArray(t) ? t : t.split(".");
    for (let r = 0; r < n.length; r++)
      if (e instanceof Map ? e = e.get(n[r]) : e = e[n[r]], this.refEditor.isRef(e) && (e = this.refEditor.get(e)), !e)
        return;
    return e;
  }
  has(e, t, n = !1) {
    if (typeof e > "u")
      return !1;
    const r = Array.isArray(t) ? t.slice() : t.split("."), o = n ? 2 : 1;
    for (; e && r.length > o; ) {
      const i = r.shift();
      e = e[i], this.refEditor.isRef(e) && (e = this.refEditor.get(e));
    }
    return e != null && Object.prototype.hasOwnProperty.call(e, r[0]);
  }
  createDefaultSetCallback(e) {
    return (t, n, r) => {
      if ((e.remove || e.newKey) && (Array.isArray(t) ? t.splice(n, 1) : _e(t) instanceof Map ? t.delete(n) : _e(t) instanceof Set ? t.delete(Array.from(t.values())[n]) : Reflect.deleteProperty(t, n)), !e.remove) {
        const o = t[e.newKey || n];
        this.refEditor.isRef(o) ? this.refEditor.set(o, r) : _e(t) instanceof Map ? t.set(e.newKey || n, r) : _e(t) instanceof Set ? t.add(r) : t[e.newKey || n] = r;
      }
    };
  }
}, Ha = class {
  set(e, t) {
    if (nt(e))
      e.value = t;
    else {
      if (e instanceof Set && Array.isArray(t)) {
        e.clear(), t.forEach((o) => e.add(o));
        return;
      }
      const n = Object.keys(t);
      if (e instanceof Map) {
        const o = new Set(e.keys());
        n.forEach((i) => {
          e.set(i, Reflect.get(t, i)), o.delete(i);
        }), o.forEach((i) => e.delete(i));
        return;
      }
      const r = new Set(Object.keys(e));
      n.forEach((o) => {
        Reflect.set(e, o, Reflect.get(t, o)), r.delete(o);
      }), r.forEach((o) => Reflect.deleteProperty(e, o));
    }
  }
  get(e) {
    return nt(e) ? e.value : e;
  }
  isRef(e) {
    return nt(e) || ro(e);
  }
};
m();
m();
m();
var ja = "__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS_STATE__";
function za() {
  if (!Kr || typeof localStorage > "u" || localStorage === null)
    return {
      recordingState: !1,
      mouseEventEnabled: !1,
      keyboardEventEnabled: !1,
      componentEventEnabled: !1,
      performanceEventEnabled: !1,
      selected: ""
    };
  const e = localStorage.getItem(ja);
  return e ? JSON.parse(e) : {
    recordingState: !1,
    mouseEventEnabled: !1,
    keyboardEventEnabled: !1,
    componentEventEnabled: !1,
    performanceEventEnabled: !1,
    selected: ""
  };
}
m();
m();
m();
var yn, Cn;
(Cn = (yn = y).__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS) != null || (yn.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS = []);
var $a = new Proxy(y.__VUE_DEVTOOLS_KIT_TIMELINE_LAYERS, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
});
function Ka(e, t) {
  k.timelineLayersState[t.id] = !1, $a.push({
    ...e,
    descriptorId: t.id,
    appRecord: Dt(t.app)
  });
}
var bn, wn;
(wn = (bn = y).__VUE_DEVTOOLS_KIT_INSPECTOR__) != null || (bn.__VUE_DEVTOOLS_KIT_INSPECTOR__ = []);
var Ft = new Proxy(y.__VUE_DEVTOOLS_KIT_INSPECTOR__, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
}), oo = ae(() => {
  fe.hooks.callHook("sendInspectorToClient", io());
});
function Wa(e, t) {
  var n, r;
  Ft.push({
    options: e,
    descriptor: t,
    treeFilterPlaceholder: (n = e.treeFilterPlaceholder) != null ? n : "Search tree...",
    stateFilterPlaceholder: (r = e.stateFilterPlaceholder) != null ? r : "Search state...",
    treeFilter: "",
    selectedNodeId: "",
    appRecord: Dt(t.app)
  }), oo();
}
function io() {
  return Ft.filter((e) => e.descriptor.app === F.value.app).filter((e) => e.descriptor.id !== "components").map((e) => {
    var t;
    const n = e.descriptor, r = e.options;
    return {
      id: r.id,
      label: r.label,
      logo: n.logo,
      icon: `custom-ic-baseline-${(t = r?.icon) == null ? void 0 : t.replace(/_/g, "-")}`,
      packageName: n.packageName,
      homepage: n.homepage,
      pluginId: n.id
    };
  });
}
function Re(e, t) {
  return Ft.find((n) => n.options.id === e && (t ? n.descriptor.app === t : !0));
}
function Ga() {
  const e = Gr();
  e.hook("addInspector", ({ inspector: r, plugin: o }) => {
    Wa(r, o.descriptor);
  });
  const t = ae(async ({ inspectorId: r, plugin: o }) => {
    var i;
    if (!r || !((i = o?.descriptor) != null && i.app) || k.highPerfModeEnabled)
      return;
    const s = Re(r, o.descriptor.app), a = {
      app: o.descriptor.app,
      inspectorId: r,
      filter: s?.treeFilter || "",
      rootNodes: []
    };
    await new Promise((u) => {
      e.callHookWith(
        async (l) => {
          await Promise.all(l.map((c) => c(a))), u();
        },
        "getInspectorTree"
        /* GET_INSPECTOR_TREE */
      );
    }), e.callHookWith(
      async (u) => {
        await Promise.all(u.map((l) => l({
          inspectorId: r,
          rootNodes: a.rootNodes
        })));
      },
      "sendInspectorTreeToClient"
      /* SEND_INSPECTOR_TREE_TO_CLIENT */
    );
  }, 120);
  e.hook("sendInspectorTree", t);
  const n = ae(async ({ inspectorId: r, plugin: o }) => {
    var i;
    if (!r || !((i = o?.descriptor) != null && i.app) || k.highPerfModeEnabled)
      return;
    const s = Re(r, o.descriptor.app), a = {
      app: o.descriptor.app,
      inspectorId: r,
      nodeId: s?.selectedNodeId || "",
      state: null
    }, u = {
      currentTab: `custom-inspector:${r}`
    };
    a.nodeId && await new Promise((l) => {
      e.callHookWith(
        async (c) => {
          await Promise.all(c.map((f) => f(a, u))), l();
        },
        "getInspectorState"
        /* GET_INSPECTOR_STATE */
      );
    }), e.callHookWith(
      async (l) => {
        await Promise.all(l.map((c) => c({
          inspectorId: r,
          nodeId: a.nodeId,
          state: a.state
        })));
      },
      "sendInspectorStateToClient"
      /* SEND_INSPECTOR_STATE_TO_CLIENT */
    );
  }, 120);
  return e.hook("sendInspectorState", n), e.hook("customInspectorSelectNode", ({ inspectorId: r, nodeId: o, plugin: i }) => {
    const s = Re(r, i.descriptor.app);
    s && (s.selectedNodeId = o);
  }), e.hook("timelineLayerAdded", ({ options: r, plugin: o }) => {
    Ka(r, o.descriptor);
  }), e.hook("timelineEventAdded", ({ options: r, plugin: o }) => {
    var i;
    const s = ["performance", "component-event", "keyboard", "mouse"];
    k.highPerfModeEnabled || !((i = k.timelineLayersState) != null && i[o.descriptor.id]) && !s.includes(r.layerId) || e.callHookWith(
      async (a) => {
        await Promise.all(a.map((u) => u(r)));
      },
      "sendTimelineEventToClient"
      /* SEND_TIMELINE_EVENT_TO_CLIENT */
    );
  }), e.hook("getComponentInstances", async ({ app: r }) => {
    const o = r.__VUE_DEVTOOLS_NEXT_APP_RECORD__;
    if (!o)
      return null;
    const i = o.id.toString();
    return [...o.instanceMap].filter(([a]) => a.split(":")[0] === i).map(([, a]) => a);
  }), e.hook("getComponentBounds", async ({ instance: r }) => ee(r)), e.hook("getComponentName", ({ instance: r }) => Ke(r)), e.hook("componentHighlight", ({ uid: r }) => {
    const o = F.value.instanceMap.get(r);
    o && ka(o);
  }), e.hook("componentUnhighlight", () => {
    no();
  }), e;
}
var An, Tn;
(Tn = (An = y).__VUE_DEVTOOLS_KIT_APP_RECORDS__) != null || (An.__VUE_DEVTOOLS_KIT_APP_RECORDS__ = []);
var On, Sn;
(Sn = (On = y).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__) != null || (On.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = {});
var Pn, In;
(In = (Pn = y).__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__) != null || (Pn.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = "");
var Dn, kn;
(kn = (Dn = y).__VUE_DEVTOOLS_KIT_CUSTOM_TABS__) != null || (Dn.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ = []);
var xn, Rn;
(Rn = (xn = y).__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__) != null || (xn.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ = []);
var Z = "__VUE_DEVTOOLS_KIT_GLOBAL_STATE__";
function Ya() {
  return {
    connected: !1,
    clientConnected: !1,
    vitePluginDetected: !0,
    appRecords: [],
    activeAppRecordId: "",
    tabs: [],
    commands: [],
    highPerfModeEnabled: !0,
    devtoolsClientDetected: {},
    perfUniqueGroupId: 0,
    timelineLayersState: za()
  };
}
var Ln, Fn;
(Fn = (Ln = y)[Z]) != null || (Ln[Z] = Ya());
var qa = ae((e) => {
  fe.hooks.callHook("devtoolsStateUpdated", { state: e });
});
ae((e, t) => {
  fe.hooks.callHook("devtoolsConnectedUpdated", { state: e, oldState: t });
});
var We = new Proxy(y.__VUE_DEVTOOLS_KIT_APP_RECORDS__, {
  get(e, t, n) {
    return t === "value" ? y.__VUE_DEVTOOLS_KIT_APP_RECORDS__ : y.__VUE_DEVTOOLS_KIT_APP_RECORDS__[t];
  }
}), F = new Proxy(y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__, {
  get(e, t, n) {
    return t === "value" ? y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ : t === "id" ? y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ : y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__[t];
  }
});
function so() {
  qa({
    ...y[Z],
    appRecords: We.value,
    activeAppRecordId: F.id,
    tabs: y.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__,
    commands: y.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__
  });
}
function Xa(e) {
  y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD__ = e, so();
}
function Qa(e) {
  y.__VUE_DEVTOOLS_KIT_ACTIVE_APP_RECORD_ID__ = e, so();
}
var k = new Proxy(y[Z], {
  get(e, t) {
    return t === "appRecords" ? We : t === "activeAppRecordId" ? F.id : t === "tabs" ? y.__VUE_DEVTOOLS_KIT_CUSTOM_TABS__ : t === "commands" ? y.__VUE_DEVTOOLS_KIT_CUSTOM_COMMANDS__ : y[Z][t];
  },
  deleteProperty(e, t) {
    return delete e[t], !0;
  },
  set(e, t, n) {
    return { ...y[Z] }, e[t] = n, y[Z][t] = n, !0;
  }
});
function Za(e = {}) {
  var t, n, r;
  const { file: o, host: i, baseUrl: s = window.location.origin, line: a = 0, column: u = 0 } = e;
  if (o) {
    if (i === "chrome-extension") {
      const l = o.replace(/\\/g, "\\\\"), c = (n = (t = window.VUE_DEVTOOLS_CONFIG) == null ? void 0 : t.openInEditorHost) != null ? n : "/";
      fetch(`${c}__open-in-editor?file=${encodeURI(o)}`).then((f) => {
        if (!f.ok) {
          const h = `Opening component ${l} failed`;
          console.log(`%c${h}`, "color:red");
        }
      });
    } else if (k.vitePluginDetected) {
      const l = (r = y.__VUE_DEVTOOLS_OPEN_IN_EDITOR_BASE_URL__) != null ? r : s;
      y.__VUE_INSPECTOR__.openInEditor(l, o, a, u);
    }
  }
}
m();
m();
m();
m();
m();
var Mn, Nn;
(Nn = (Mn = y).__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__) != null || (Mn.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__ = []);
var Mt = new Proxy(y.__VUE_DEVTOOLS_KIT_PLUGIN_BUFFER__, {
  get(e, t, n) {
    return Reflect.get(e, t, n);
  }
});
function Et(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = e[n].defaultValue;
  }), t;
}
function Nt(e) {
  return `__VUE_DEVTOOLS_NEXT_PLUGIN_SETTINGS__${e}__`;
}
function Ja(e) {
  var t, n, r;
  const o = (n = (t = Mt.find((i) => {
    var s;
    return i[0].id === e && !!((s = i[0]) != null && s.settings);
  })) == null ? void 0 : t[0]) != null ? n : null;
  return (r = o?.settings) != null ? r : null;
}
function ao(e, t) {
  var n, r, o;
  const i = Nt(e);
  if (i) {
    const s = localStorage.getItem(i);
    if (s)
      return JSON.parse(s);
  }
  if (e) {
    const s = (r = (n = Mt.find((a) => a[0].id === e)) == null ? void 0 : n[0]) != null ? r : null;
    return Et((o = s?.settings) != null ? o : {});
  }
  return Et(t);
}
function eu(e, t) {
  const n = Nt(e);
  localStorage.getItem(n) || localStorage.setItem(n, JSON.stringify(Et(t)));
}
function tu(e, t, n) {
  const r = Nt(e), o = localStorage.getItem(r), i = JSON.parse(o || "{}"), s = {
    ...i,
    [t]: n
  };
  localStorage.setItem(r, JSON.stringify(s)), fe.hooks.callHookWith(
    (a) => {
      a.forEach((u) => u({
        pluginId: e,
        key: t,
        oldValue: i[t],
        newValue: n,
        settings: s
      }));
    },
    "setPluginSettings"
    /* SET_PLUGIN_SETTINGS */
  );
}
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
var Vn, Bn, V = (Bn = (Vn = y).__VUE_DEVTOOLS_HOOK) != null ? Bn : Vn.__VUE_DEVTOOLS_HOOK = Gr(), nu = {
  vueAppInit(e) {
    V.hook("app:init", e);
  },
  vueAppUnmount(e) {
    V.hook("app:unmount", e);
  },
  vueAppConnected(e) {
    V.hook("app:connected", e);
  },
  componentAdded(e) {
    return V.hook("component:added", e);
  },
  componentEmit(e) {
    return V.hook("component:emit", e);
  },
  componentUpdated(e) {
    return V.hook("component:updated", e);
  },
  componentRemoved(e) {
    return V.hook("component:removed", e);
  },
  setupDevtoolsPlugin(e) {
    V.hook("devtools-plugin:setup", e);
  },
  perfStart(e) {
    return V.hook("perf:start", e);
  },
  perfEnd(e) {
    return V.hook("perf:end", e);
  }
}, uo = {
  on: nu,
  setupDevToolsPlugin(e, t) {
    return V.callHook("devtools-plugin:setup", e, t);
  }
}, ru = class {
  constructor({ plugin: e, ctx: t }) {
    this.hooks = t.hooks, this.plugin = e;
  }
  get on() {
    return {
      // component inspector
      visitComponentTree: (e) => {
        this.hooks.hook("visitComponentTree", e);
      },
      inspectComponent: (e) => {
        this.hooks.hook("inspectComponent", e);
      },
      editComponentState: (e) => {
        this.hooks.hook("editComponentState", e);
      },
      // custom inspector
      getInspectorTree: (e) => {
        this.hooks.hook("getInspectorTree", e);
      },
      getInspectorState: (e) => {
        this.hooks.hook("getInspectorState", e);
      },
      editInspectorState: (e) => {
        this.hooks.hook("editInspectorState", e);
      },
      // timeline
      inspectTimelineEvent: (e) => {
        this.hooks.hook("inspectTimelineEvent", e);
      },
      timelineCleared: (e) => {
        this.hooks.hook("timelineCleared", e);
      },
      // settings
      setPluginSettings: (e) => {
        this.hooks.hook("setPluginSettings", e);
      }
    };
  }
  // component inspector
  notifyComponentUpdate(e) {
    var t;
    if (k.highPerfModeEnabled)
      return;
    const n = io().find((r) => r.packageName === this.plugin.descriptor.packageName);
    if (n?.id) {
      if (e) {
        const r = [
          e.appContext.app,
          e.uid,
          (t = e.parent) == null ? void 0 : t.uid,
          e
        ];
        V.callHook("component:updated", ...r);
      } else
        V.callHook(
          "component:updated"
          /* COMPONENT_UPDATED */
        );
      this.hooks.callHook("sendInspectorState", { inspectorId: n.id, plugin: this.plugin });
    }
  }
  // custom inspector
  addInspector(e) {
    this.hooks.callHook("addInspector", { inspector: e, plugin: this.plugin }), this.plugin.descriptor.settings && eu(e.id, this.plugin.descriptor.settings);
  }
  sendInspectorTree(e) {
    k.highPerfModeEnabled || this.hooks.callHook("sendInspectorTree", { inspectorId: e, plugin: this.plugin });
  }
  sendInspectorState(e) {
    k.highPerfModeEnabled || this.hooks.callHook("sendInspectorState", { inspectorId: e, plugin: this.plugin });
  }
  selectInspectorNode(e, t) {
    this.hooks.callHook("customInspectorSelectNode", { inspectorId: e, nodeId: t, plugin: this.plugin });
  }
  visitComponentTree(e) {
    return this.hooks.callHook("visitComponentTree", e);
  }
  // timeline
  now() {
    return k.highPerfModeEnabled ? 0 : Date.now();
  }
  addTimelineLayer(e) {
    this.hooks.callHook("timelineLayerAdded", { options: e, plugin: this.plugin });
  }
  addTimelineEvent(e) {
    k.highPerfModeEnabled || this.hooks.callHook("timelineEventAdded", { options: e, plugin: this.plugin });
  }
  // settings
  getSettings(e) {
    return ao(e ?? this.plugin.descriptor.id, this.plugin.descriptor.settings);
  }
  // utilities
  getComponentInstances(e) {
    return this.hooks.callHook("getComponentInstances", { app: e });
  }
  getComponentBounds(e) {
    return this.hooks.callHook("getComponentBounds", { instance: e });
  }
  getComponentName(e) {
    return this.hooks.callHook("getComponentName", { instance: e });
  }
  highlightElement(e) {
    const t = e.__VUE_DEVTOOLS_NEXT_UID__;
    return this.hooks.callHook("componentHighlight", { uid: t });
  }
  unhighlightElement() {
    return this.hooks.callHook(
      "componentUnhighlight"
      /* COMPONENT_UNHIGHLIGHT */
    );
  }
}, ou = ru;
m();
m();
m();
m();
var iu = "__vue_devtool_undefined__", su = "__vue_devtool_infinity__", au = "__vue_devtool_negative_infinity__", uu = "__vue_devtool_nan__";
m();
m();
var lu = {
  [iu]: "undefined",
  [uu]: "NaN",
  [su]: "Infinity",
  [au]: "-Infinity"
};
Object.entries(lu).reduce((e, [t, n]) => (e[n] = t, e), {});
m();
m();
m();
m();
m();
var Un, Hn;
(Hn = (Un = y).__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__) != null || (Un.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__ = /* @__PURE__ */ new Set());
function cu(e, t) {
  return uo.setupDevToolsPlugin(e, t);
}
function fu(e, t) {
  const [n, r] = e;
  if (n.app !== t)
    return;
  const o = new ou({
    plugin: {
      setupFn: r,
      descriptor: n
    },
    ctx: fe
  });
  n.packageName === "vuex" && o.on.editInspectorState((i) => {
    o.sendInspectorState(i.inspectorId);
  }), r(o);
}
function lo(e, t) {
  y.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.has(e) || k.highPerfModeEnabled && !t?.inspectingComponent || (y.__VUE_DEVTOOLS_KIT__REGISTERED_PLUGIN_APPS__.add(e), Mt.forEach((n) => {
    fu(n, e);
  }));
}
m();
m();
var ve = "__VUE_DEVTOOLS_ROUTER__", ue = "__VUE_DEVTOOLS_ROUTER_INFO__", jn, zn;
(zn = (jn = y)[ue]) != null || (jn[ue] = {
  currentRoute: null,
  routes: []
});
var $n, Kn;
(Kn = ($n = y)[ve]) != null || ($n[ve] = {});
new Proxy(y[ue], {
  get(e, t) {
    return y[ue][t];
  }
});
new Proxy(y[ve], {
  get(e, t) {
    if (t === "value")
      return y[ve];
  }
});
function du(e) {
  const t = /* @__PURE__ */ new Map();
  return (e?.getRoutes() || []).filter((n) => !t.has(n.path) && t.set(n.path, 1));
}
function Vt(e) {
  return e.map((t) => {
    let { path: n, name: r, children: o, meta: i } = t;
    return o?.length && (o = Vt(o)), {
      path: n,
      name: r,
      children: o,
      meta: i
    };
  });
}
function pu(e) {
  if (e) {
    const { fullPath: t, hash: n, href: r, path: o, name: i, matched: s, params: a, query: u } = e;
    return {
      fullPath: t,
      hash: n,
      href: r,
      path: o,
      name: i,
      params: a,
      query: u,
      matched: Vt(s)
    };
  }
  return e;
}
function hu(e, t) {
  function n() {
    var r;
    const o = (r = e.app) == null ? void 0 : r.config.globalProperties.$router, i = pu(o?.currentRoute.value), s = Vt(du(o)), a = console.warn;
    console.warn = () => {
    }, y[ue] = {
      currentRoute: i ? _n(i) : {},
      routes: _n(s)
    }, y[ve] = o, console.warn = a;
  }
  n(), uo.on.componentUpdated(ae(() => {
    var r;
    ((r = t.value) == null ? void 0 : r.app) === e.app && (n(), !k.highPerfModeEnabled && fe.hooks.callHook("routerInfoUpdated", { state: y[ue] }));
  }, 200));
}
function _u(e) {
  return {
    // get inspector tree
    async getInspectorTree(t) {
      const n = {
        ...t,
        app: F.value.app,
        rootNodes: []
      };
      return await new Promise((r) => {
        e.callHookWith(
          async (o) => {
            await Promise.all(o.map((i) => i(n))), r();
          },
          "getInspectorTree"
          /* GET_INSPECTOR_TREE */
        );
      }), n.rootNodes;
    },
    // get inspector state
    async getInspectorState(t) {
      const n = {
        ...t,
        app: F.value.app,
        state: null
      }, r = {
        currentTab: `custom-inspector:${t.inspectorId}`
      };
      return await new Promise((o) => {
        e.callHookWith(
          async (i) => {
            await Promise.all(i.map((s) => s(n, r))), o();
          },
          "getInspectorState"
          /* GET_INSPECTOR_STATE */
        );
      }), n.state;
    },
    // edit inspector state
    editInspectorState(t) {
      const n = new Ua(), r = {
        ...t,
        app: F.value.app,
        set: (o, i = t.path, s = t.state.value, a) => {
          n.set(o, i, s, a || n.createDefaultSetCallback(t.state));
        }
      };
      e.callHookWith(
        (o) => {
          o.forEach((i) => i(r));
        },
        "editInspectorState"
        /* EDIT_INSPECTOR_STATE */
      );
    },
    // send inspector state
    sendInspectorState(t) {
      const n = Re(t);
      e.callHook("sendInspectorState", { inspectorId: t, plugin: {
        descriptor: n.descriptor,
        setupFn: () => ({})
      } });
    },
    // inspect component inspector
    inspectComponentInspector() {
      return La();
    },
    // cancel inspect component inspector
    cancelInspectComponentInspector() {
      return Ra();
    },
    // get component render code
    getComponentRenderCode(t) {
      const n = _t(F.value, t);
      if (n)
        return typeof n?.type != "function" ? n.render.toString() : n.type.toString();
    },
    // scroll to component
    scrollToComponent(t) {
      return Fa({ id: t });
    },
    // open in editor
    openInEditor: Za,
    // get vue inspector
    getVueInspector: Va,
    // toggle app
    toggleApp(t, n) {
      const r = We.value.find((o) => o.id === t);
      r && (Qa(t), Xa(r), hu(r, F), oo(), lo(r.app, n));
    },
    // inspect dom
    inspectDOM(t) {
      const n = _t(F.value, t);
      if (n) {
        const [r] = kt(n);
        r && (y.__VUE_DEVTOOLS_INSPECT_DOM_TARGET__ = r);
      }
    },
    updatePluginSettings(t, n, r) {
      tu(t, n, r);
    },
    getPluginSettings(t) {
      return {
        options: Ja(t),
        values: ao(t)
      };
    }
  };
}
m();
var Wn, Gn;
(Gn = (Wn = y).__VUE_DEVTOOLS_ENV__) != null || (Wn.__VUE_DEVTOOLS_ENV__ = {
  vitePluginDetected: !1
});
var Yn = Ga(), qn, Xn;
(Xn = (qn = y).__VUE_DEVTOOLS_KIT_CONTEXT__) != null || (qn.__VUE_DEVTOOLS_KIT_CONTEXT__ = {
  hooks: Yn,
  get state() {
    return {
      ...k,
      activeAppRecordId: F.id,
      activeAppRecord: F.value,
      appRecords: We.value
    };
  },
  api: _u(Yn)
});
var fe = y.__VUE_DEVTOOLS_KIT_CONTEXT__;
m();
_a(ga());
var Qn, Zn;
(Zn = (Qn = y).__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__) != null || (Qn.__VUE_DEVTOOLS_NEXT_APP_RECORD_INFO__ = {
  id: 0,
  appIds: /* @__PURE__ */ new Set()
});
m();
m();
function mu(e) {
  k.highPerfModeEnabled = e ?? !k.highPerfModeEnabled, !e && F.value && lo(F.value.app);
}
m();
m();
m();
function gu(e) {
  k.devtoolsClientDetected = {
    ...k.devtoolsClientDetected,
    ...e
  };
  const t = Object.values(k.devtoolsClientDetected).some(Boolean);
  mu(!t);
}
var Jn, er;
(er = (Jn = y).__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__) != null || (Jn.__VUE_DEVTOOLS_UPDATE_CLIENT_DETECTED__ = gu);
m();
m();
m();
m();
m();
m();
m();
var Eu = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(e, t) {
    this.keyToValue.set(e, t), this.valueToKey.set(t, e);
  }
  getByKey(e) {
    return this.keyToValue.get(e);
  }
  getByValue(e) {
    return this.valueToKey.get(e);
  }
  clear() {
    this.keyToValue.clear(), this.valueToKey.clear();
  }
}, co = class {
  constructor(e) {
    this.generateIdentifier = e, this.kv = new Eu();
  }
  register(e, t) {
    this.kv.getByValue(e) || (t || (t = this.generateIdentifier(e)), this.kv.set(t, e));
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(e) {
    return this.kv.getByValue(e);
  }
  getValue(e) {
    return this.kv.getByKey(e);
  }
}, vu = class extends co {
  constructor() {
    super((e) => e.name), this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(e, t) {
    typeof t == "object" ? (t.allowProps && this.classToAllowedProps.set(e, t.allowProps), super.register(e, t.identifier)) : super.register(e, t);
  }
  getAllowedProps(e) {
    return this.classToAllowedProps.get(e);
  }
};
m();
m();
function yu(e) {
  if ("values" in Object)
    return Object.values(e);
  const t = [];
  for (const n in e)
    e.hasOwnProperty(n) && t.push(e[n]);
  return t;
}
function Cu(e, t) {
  const n = yu(e);
  if ("find" in n)
    return n.find(t);
  const r = n;
  for (let o = 0; o < r.length; o++) {
    const i = r[o];
    if (t(i))
      return i;
  }
}
function le(e, t) {
  Object.entries(e).forEach(([n, r]) => t(r, n));
}
function Le(e, t) {
  return e.indexOf(t) !== -1;
}
function tr(e, t) {
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (t(r))
      return r;
  }
}
var bu = class {
  constructor() {
    this.transfomers = {};
  }
  register(e) {
    this.transfomers[e.name] = e;
  }
  findApplicable(e) {
    return Cu(this.transfomers, (t) => t.isApplicable(e));
  }
  findByName(e) {
    return this.transfomers[e];
  }
};
m();
m();
var wu = (e) => Object.prototype.toString.call(e).slice(8, -1), fo = (e) => typeof e > "u", Au = (e) => e === null, ye = (e) => typeof e != "object" || e === null || e === Object.prototype ? !1 : Object.getPrototypeOf(e) === null ? !0 : Object.getPrototypeOf(e) === Object.prototype, vt = (e) => ye(e) && Object.keys(e).length === 0, G = (e) => Array.isArray(e), Tu = (e) => typeof e == "string", Ou = (e) => typeof e == "number" && !isNaN(e), Su = (e) => typeof e == "boolean", Pu = (e) => e instanceof RegExp, Ce = (e) => e instanceof Map, be = (e) => e instanceof Set, po = (e) => wu(e) === "Symbol", Iu = (e) => e instanceof Date && !isNaN(e.valueOf()), Du = (e) => e instanceof Error, nr = (e) => typeof e == "number" && isNaN(e), ku = (e) => Su(e) || Au(e) || fo(e) || Ou(e) || Tu(e) || po(e), xu = (e) => typeof e == "bigint", Ru = (e) => e === 1 / 0 || e === -1 / 0, Lu = (e) => ArrayBuffer.isView(e) && !(e instanceof DataView), Fu = (e) => e instanceof URL;
m();
var ho = (e) => e.replace(/\./g, "\\."), rt = (e) => e.map(String).map(ho).join("."), ge = (e) => {
  const t = [];
  let n = "";
  for (let o = 0; o < e.length; o++) {
    let i = e.charAt(o);
    if (i === "\\" && e.charAt(o + 1) === ".") {
      n += ".", o++;
      continue;
    }
    if (i === ".") {
      t.push(n), n = "";
      continue;
    }
    n += i;
  }
  const r = n;
  return t.push(r), t;
};
m();
function j(e, t, n, r) {
  return {
    isApplicable: e,
    annotation: t,
    transform: n,
    untransform: r
  };
}
var _o = [
  j(fo, "undefined", () => null, () => {
  }),
  j(xu, "bigint", (e) => e.toString(), (e) => typeof BigInt < "u" ? BigInt(e) : (console.error("Please add a BigInt polyfill."), e)),
  j(Iu, "Date", (e) => e.toISOString(), (e) => new Date(e)),
  j(Du, "Error", (e, t) => {
    const n = {
      name: e.name,
      message: e.message
    };
    return t.allowedErrorProps.forEach((r) => {
      n[r] = e[r];
    }), n;
  }, (e, t) => {
    const n = new Error(e.message);
    return n.name = e.name, n.stack = e.stack, t.allowedErrorProps.forEach((r) => {
      n[r] = e[r];
    }), n;
  }),
  j(Pu, "regexp", (e) => "" + e, (e) => {
    const t = e.slice(1, e.lastIndexOf("/")), n = e.slice(e.lastIndexOf("/") + 1);
    return new RegExp(t, n);
  }),
  j(
    be,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (e) => [...e.values()],
    (e) => new Set(e)
  ),
  j(Ce, "map", (e) => [...e.entries()], (e) => new Map(e)),
  j((e) => nr(e) || Ru(e), "number", (e) => nr(e) ? "NaN" : e > 0 ? "Infinity" : "-Infinity", Number),
  j((e) => e === 0 && 1 / e === -1 / 0, "number", () => "-0", Number),
  j(Fu, "URL", (e) => e.toString(), (e) => new URL(e))
];
function Ge(e, t, n, r) {
  return {
    isApplicable: e,
    annotation: t,
    transform: n,
    untransform: r
  };
}
var mo = Ge((e, t) => po(e) ? !!t.symbolRegistry.getIdentifier(e) : !1, (e, t) => ["symbol", t.symbolRegistry.getIdentifier(e)], (e) => e.description, (e, t, n) => {
  const r = n.symbolRegistry.getValue(t[1]);
  if (!r)
    throw new Error("Trying to deserialize unknown symbol");
  return r;
}), Mu = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((e, t) => (e[t.name] = t, e), {}), go = Ge(Lu, (e) => ["typed-array", e.constructor.name], (e) => [...e], (e, t) => {
  const n = Mu[t[1]];
  if (!n)
    throw new Error("Trying to deserialize unknown typed array");
  return new n(e);
});
function Eo(e, t) {
  return e?.constructor ? !!t.classRegistry.getIdentifier(e.constructor) : !1;
}
var vo = Ge(Eo, (e, t) => ["class", t.classRegistry.getIdentifier(e.constructor)], (e, t) => {
  const n = t.classRegistry.getAllowedProps(e.constructor);
  if (!n)
    return { ...e };
  const r = {};
  return n.forEach((o) => {
    r[o] = e[o];
  }), r;
}, (e, t, n) => {
  const r = n.classRegistry.getValue(t[1]);
  if (!r)
    throw new Error(`Trying to deserialize unknown class '${t[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);
  return Object.assign(Object.create(r.prototype), e);
}), yo = Ge((e, t) => !!t.customTransformerRegistry.findApplicable(e), (e, t) => ["custom", t.customTransformerRegistry.findApplicable(e).name], (e, t) => t.customTransformerRegistry.findApplicable(e).serialize(e), (e, t, n) => {
  const r = n.customTransformerRegistry.findByName(t[1]);
  if (!r)
    throw new Error("Trying to deserialize unknown custom value");
  return r.deserialize(e);
}), Nu = [vo, mo, yo, go], rr = (e, t) => {
  const n = tr(Nu, (o) => o.isApplicable(e, t));
  if (n)
    return {
      value: n.transform(e, t),
      type: n.annotation(e, t)
    };
  const r = tr(_o, (o) => o.isApplicable(e, t));
  if (r)
    return {
      value: r.transform(e, t),
      type: r.annotation
    };
}, Co = {};
_o.forEach((e) => {
  Co[e.annotation] = e;
});
var Vu = (e, t, n) => {
  if (G(t))
    switch (t[0]) {
      case "symbol":
        return mo.untransform(e, t, n);
      case "class":
        return vo.untransform(e, t, n);
      case "custom":
        return yo.untransform(e, t, n);
      case "typed-array":
        return go.untransform(e, t, n);
      default:
        throw new Error("Unknown transformation: " + t);
    }
  else {
    const r = Co[t];
    if (!r)
      throw new Error("Unknown transformation: " + t);
    return r.untransform(e, n);
  }
};
m();
var oe = (e, t) => {
  if (t > e.size)
    throw new Error("index out of bounds");
  const n = e.keys();
  for (; t > 0; )
    n.next(), t--;
  return n.next().value;
};
function bo(e) {
  if (Le(e, "__proto__"))
    throw new Error("__proto__ is not allowed as a property");
  if (Le(e, "prototype"))
    throw new Error("prototype is not allowed as a property");
  if (Le(e, "constructor"))
    throw new Error("constructor is not allowed as a property");
}
var Bu = (e, t) => {
  bo(t);
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (be(e))
      e = oe(e, +r);
    else if (Ce(e)) {
      const o = +r, i = +t[++n] == 0 ? "key" : "value", s = oe(e, o);
      switch (i) {
        case "key":
          e = s;
          break;
        case "value":
          e = e.get(s);
          break;
      }
    } else
      e = e[r];
  }
  return e;
}, yt = (e, t, n) => {
  if (bo(t), t.length === 0)
    return n(e);
  let r = e;
  for (let i = 0; i < t.length - 1; i++) {
    const s = t[i];
    if (G(r)) {
      const a = +s;
      r = r[a];
    } else if (ye(r))
      r = r[s];
    else if (be(r)) {
      const a = +s;
      r = oe(r, a);
    } else if (Ce(r)) {
      if (i === t.length - 2)
        break;
      const u = +s, l = +t[++i] == 0 ? "key" : "value", c = oe(r, u);
      switch (l) {
        case "key":
          r = c;
          break;
        case "value":
          r = r.get(c);
          break;
      }
    }
  }
  const o = t[t.length - 1];
  if (G(r) ? r[+o] = n(r[+o]) : ye(r) && (r[o] = n(r[o])), be(r)) {
    const i = oe(r, +o), s = n(i);
    i !== s && (r.delete(i), r.add(s));
  }
  if (Ce(r)) {
    const i = +t[t.length - 2], s = oe(r, i);
    switch (+o == 0 ? "key" : "value") {
      case "key": {
        const u = n(s);
        r.set(u, r.get(s)), u !== s && r.delete(s);
        break;
      }
      case "value": {
        r.set(s, n(r.get(s)));
        break;
      }
    }
  }
  return e;
};
function Ct(e, t, n = []) {
  if (!e)
    return;
  if (!G(e)) {
    le(e, (i, s) => Ct(i, t, [...n, ...ge(s)]));
    return;
  }
  const [r, o] = e;
  o && le(o, (i, s) => {
    Ct(i, t, [...n, ...ge(s)]);
  }), t(r, n);
}
function Uu(e, t, n) {
  return Ct(t, (r, o) => {
    e = yt(e, o, (i) => Vu(i, r, n));
  }), e;
}
function Hu(e, t) {
  function n(r, o) {
    const i = Bu(e, ge(o));
    r.map(ge).forEach((s) => {
      e = yt(e, s, () => i);
    });
  }
  if (G(t)) {
    const [r, o] = t;
    r.forEach((i) => {
      e = yt(e, ge(i), () => e);
    }), o && le(o, n);
  } else
    le(t, n);
  return e;
}
var ju = (e, t) => ye(e) || G(e) || Ce(e) || be(e) || Eo(e, t);
function zu(e, t, n) {
  const r = n.get(e);
  r ? r.push(t) : n.set(e, [t]);
}
function $u(e, t) {
  const n = {};
  let r;
  return e.forEach((o) => {
    if (o.length <= 1)
      return;
    t || (o = o.map((a) => a.map(String)).sort((a, u) => a.length - u.length));
    const [i, ...s] = o;
    i.length === 0 ? r = s.map(rt) : n[rt(i)] = s.map(rt);
  }), r ? vt(n) ? [r] : [r, n] : vt(n) ? void 0 : n;
}
var wo = (e, t, n, r, o = [], i = [], s = /* @__PURE__ */ new Map()) => {
  var a;
  const u = ku(e);
  if (!u) {
    zu(e, o, t);
    const _ = s.get(e);
    if (_)
      return r ? {
        transformedValue: null
      } : _;
  }
  if (!ju(e, n)) {
    const _ = rr(e, n), v = _ ? {
      transformedValue: _.value,
      annotations: [_.type]
    } : {
      transformedValue: e
    };
    return u || s.set(e, v), v;
  }
  if (Le(i, e))
    return {
      transformedValue: null
    };
  const l = rr(e, n), c = (a = l?.value) != null ? a : e, f = G(c) ? [] : {}, h = {};
  le(c, (_, v) => {
    if (v === "__proto__" || v === "constructor" || v === "prototype")
      throw new Error(`Detected property ${v}. This is a prototype pollution risk, please remove it from your object.`);
    const p = wo(_, t, n, r, [...o, v], [...i, e], s);
    f[v] = p.transformedValue, G(p.annotations) ? h[v] = p.annotations : ye(p.annotations) && le(p.annotations, (g, C) => {
      h[ho(v) + "." + C] = g;
    });
  });
  const d = vt(h) ? {
    transformedValue: f,
    annotations: l ? [l.type] : void 0
  } : {
    transformedValue: f,
    annotations: l ? [l.type, h] : h
  };
  return u || s.set(e, d), d;
};
m();
m();
function Ao(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function or(e) {
  return Ao(e) === "Array";
}
function Ku(e) {
  if (Ao(e) !== "Object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return !!t && t.constructor === Object && t === Object.prototype;
}
function Wu(e, t, n, r, o) {
  const i = {}.propertyIsEnumerable.call(r, t) ? "enumerable" : "nonenumerable";
  i === "enumerable" && (e[t] = n), o && i === "nonenumerable" && Object.defineProperty(e, t, {
    value: n,
    enumerable: !1,
    writable: !0,
    configurable: !0
  });
}
function bt(e, t = {}) {
  if (or(e))
    return e.map((o) => bt(o, t));
  if (!Ku(e))
    return e;
  const n = Object.getOwnPropertyNames(e), r = Object.getOwnPropertySymbols(e);
  return [...n, ...r].reduce((o, i) => {
    if (or(t.props) && !t.props.includes(i))
      return o;
    const s = e[i], a = bt(s, t);
    return Wu(o, i, a, e, t.nonenumerable), o;
  }, {});
}
var S = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe: e = !1 } = {}) {
    this.classRegistry = new vu(), this.symbolRegistry = new co((t) => {
      var n;
      return (n = t.description) != null ? n : "";
    }), this.customTransformerRegistry = new bu(), this.allowedErrorProps = [], this.dedupe = e;
  }
  serialize(e) {
    const t = /* @__PURE__ */ new Map(), n = wo(e, t, this, this.dedupe), r = {
      json: n.transformedValue
    };
    n.annotations && (r.meta = {
      ...r.meta,
      values: n.annotations
    });
    const o = $u(t, this.dedupe);
    return o && (r.meta = {
      ...r.meta,
      referentialEqualities: o
    }), r;
  }
  deserialize(e) {
    const { json: t, meta: n } = e;
    let r = bt(t);
    return n?.values && (r = Uu(r, n.values, this)), n?.referentialEqualities && (r = Hu(r, n.referentialEqualities)), r;
  }
  stringify(e) {
    return JSON.stringify(this.serialize(e));
  }
  parse(e) {
    return this.deserialize(JSON.parse(e));
  }
  registerClass(e, t) {
    this.classRegistry.register(e, t);
  }
  registerSymbol(e, t) {
    this.symbolRegistry.register(e, t);
  }
  registerCustom(e, t) {
    this.customTransformerRegistry.register({
      name: t,
      ...e
    });
  }
  allowErrorProps(...e) {
    this.allowedErrorProps.push(...e);
  }
};
S.defaultInstance = new S();
S.serialize = S.defaultInstance.serialize.bind(S.defaultInstance);
S.deserialize = S.defaultInstance.deserialize.bind(S.defaultInstance);
S.stringify = S.defaultInstance.stringify.bind(S.defaultInstance);
S.parse = S.defaultInstance.parse.bind(S.defaultInstance);
S.registerClass = S.defaultInstance.registerClass.bind(S.defaultInstance);
S.registerSymbol = S.defaultInstance.registerSymbol.bind(S.defaultInstance);
S.registerCustom = S.defaultInstance.registerCustom.bind(S.defaultInstance);
S.allowErrorProps = S.defaultInstance.allowErrorProps.bind(S.defaultInstance);
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
m();
var ir, sr;
(sr = (ir = y).__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__) != null || (ir.__VUE_DEVTOOLS_KIT_MESSAGE_CHANNELS__ = []);
var ar, ur;
(ur = (ar = y).__VUE_DEVTOOLS_KIT_RPC_CLIENT__) != null || (ar.__VUE_DEVTOOLS_KIT_RPC_CLIENT__ = null);
var lr, cr;
(cr = (lr = y).__VUE_DEVTOOLS_KIT_RPC_SERVER__) != null || (lr.__VUE_DEVTOOLS_KIT_RPC_SERVER__ = null);
var fr, dr;
(dr = (fr = y).__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__) != null || (fr.__VUE_DEVTOOLS_KIT_VITE_RPC_CLIENT__ = null);
var pr, hr;
(hr = (pr = y).__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__) != null || (pr.__VUE_DEVTOOLS_KIT_VITE_RPC_SERVER__ = null);
var _r, mr;
(mr = (_r = y).__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__) != null || (_r.__VUE_DEVTOOLS_KIT_BROADCAST_RPC_SERVER__ = null);
m();
m();
m();
m();
m();
m();
m();
function Gu(e, t) {
  const n = `▲ ■ ●${e}`;
  typeof gr == "function" ? gr(n, t) : console.log(n);
}
function gr(e, t) {
  throw new Error(e + t);
}
function Bt(e) {
  let t = 0;
  return e.traverse((n) => {
    if ($e(n) && n.type !== "HightlightMesh") {
      const r = n.geometry, o = r.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, i = r.index ? r.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, s = r.attributes.normal ? r.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = r.attributes.uv ? r.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, u = o + i + s + a;
      t += u;
    }
  }), t;
}
function Er(e, t, n) {
  e.push(t), e.length > n && e.shift();
}
function Yu(e) {
  return (e / 1024).toFixed(2);
}
function qu(e) {
  if (!e)
    return;
  typeof window < "u" && !window.__TRES__DEVTOOLS__ && (window.__TRES__DEVTOOLS__ = new Hs());
  const t = {
    maxFrames: 160,
    fps: {
      value: 0,
      accumulator: []
    },
    memory: {
      currentMem: 0,
      allocatedMem: 0,
      accumulator: []
    }
  }, n = 100, r = di({ every: n }), { isSupported: o, memory: i } = pi({ interval: n }), s = 160;
  let a = performance.now(), u = 0;
  const l = 1, c = ({ timestamp: h }) => {
    e.scene.value && (t.memory.allocatedMem = Bt(e.scene.value)), h - a >= n && (a = h, Er(t.fps.accumulator, r.value, s), t.fps.value = r.value, o.value && i.value?.usedJSHeapSize && (Er(t.memory.accumulator, i.value.usedJSHeapSize / 1024 / 1024, s), t.memory.accumulator.length > 0 && (t.memory.currentMem = t.memory.accumulator.reduce((d, _) => d + _, 0) / t.memory.accumulator.length)));
  }, { pause: f } = Tr(({ delta: h }) => {
    window.__TRES__DEVTOOLS__ && (c({ timestamp: performance.now() }), u += h, u >= l && (window.__TRES__DEVTOOLS__.send("context", e), window.__TRES__DEVTOOLS__.send("performance", t), u = 0));
  }, { immediate: !0 });
  ie(() => {
    f();
  });
}
const To = (e, t) => {
  if (e.uuid === t)
    return e;
  for (const n of e.children) {
    const r = To(n, t);
    if (r)
      return r;
  }
};
class Xu extends vr.Mesh {
  type = "HightlightMesh";
  createTime;
  constructor(...t) {
    super(...t), this.createTime = Date.now();
  }
  onBeforeRender() {
    const n = (Date.now() - this.createTime) / 1e3, i = 1 + 0.07 * Math.sin(2.5 * n);
    this.scale.set(i, i, i);
  }
}
const Oo = (e) => {
  const t = {
    id: `scene-${e.uuid}`,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && t.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const n = Bt(e);
  return n > 0 && t.tags.push({
    label: `${Yu(n)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (Rr(e) && t.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), t.tags.push({
    label: `#${new xe(e.color).getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (t.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), t.tags.push({
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), t;
};
function Qu(e, t, n = "") {
  const r = n ? `${n}.${e}` : e;
  return {
    id: `context-${t}-${r}`,
    label: e,
    children: [],
    tags: []
  };
}
function So(e, t, n = "") {
  e.children.forEach((r) => {
    if (r.type === "HightlightMesh" || n && !r.type.includes(n) && !r.name.includes(n))
      return;
    const o = Oo(r);
    t.children.push(o), So(r, o, n);
  });
}
function wt(e, t, n = /* @__PURE__ */ new WeakSet(), r = 0, o = 4, i, s = "") {
  if (r >= o || !e || n.has(e))
    return;
  const a = r === 0 ? e?.scene?.value?.uuid || Math.random().toString(36).slice(2, 11) : i;
  n.add(e), Object.entries(e).forEach(([u, l]) => {
    if (u.startsWith("_") || typeof l == "function")
      return;
    const c = s ? `${s}.${u}` : u, f = Qu(u, a, s);
    u !== "scene" && (me(l) ? (f.tags.push({
      label: `Ref<${typeof l.value}>`,
      textColor: 4372611,
      backgroundColor: 15793395
    }), l.value && typeof l.value == "object" ? wt(l.value, f, n, r + 1, o, a, c) : f.label = `${u}: ${JSON.stringify(l.value)}`) : l && typeof l == "object" && !Array.isArray(l) ? Object.keys(l).length > 0 ? n.has(l) ? f.tags.push({
      label: "Circular",
      textColor: 16711680,
      backgroundColor: 16773360
    }) : wt(l, f, n, r + 1, o, a, c) : f.label = `${u}: {}` : Array.isArray(l) ? (f.label = `${u}: Array(${l.length})`, f.tags.push({
      label: `length: ${l.length}`,
      textColor: 9738662,
      backgroundColor: 16316922
    })) : f.label = `${u}: ${JSON.stringify(l)}`, t.children.push(f));
  });
}
const Zu = (e) => (t) => {
  if (t.inspectorId === we) {
    const n = Oo(e.scene.value);
    So(e.scene.value, n, t.filter);
    const r = {
      id: "context-root",
      label: "Context",
      children: [],
      tags: []
    };
    wt(e, r), t.rootNodes = [n, r];
  }
}, Ju = (e, { highlightMesh: t, prevInstance: n }) => (r) => {
  if (r.inspectorId !== we)
    return;
  const o = new Ar({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: !0,
    opacity: 0.2,
    depthTest: !1,
    // So the highlight is always visible
    side: Wo
    // To ensure the highlight is visible from all angles
  });
  if (r.nodeId.includes("scene")) {
    const i = r.nodeId.match(/^scene-(.+)$/), s = i ? i[1] : null;
    if (!s)
      return;
    const [a] = e.scene.value.getObjectsByProperty("uuid", s);
    if (!a)
      return;
    if (n && t && t.parent && n.remove(t), $e(a)) {
      const u = new Xu(a.geometry.clone(), o);
      a.add(u), t = u, n = a;
    }
    if (r.state = {
      object: Object.entries(a).map(([u, l]) => u === "children" ? { key: u, value: l.filter((c) => c.type !== "HightlightMesh") } : { key: u, value: l, editable: !0 }).filter(({ key: u }) => u !== "parent")
    }, Fr(a)) {
      const u = {
        ...r.state,
        state: [
          {
            key: "Scene Info",
            value: {
              objects: a.children.length,
              memory: Bt(a),
              calls: e.renderer.instance.info.render.calls,
              triangles: e.renderer.instance.info.render.triangles,
              points: e.renderer.instance.info.render.points,
              lines: e.renderer.instance.info.render.lines
            }
          }
        ]
      };
      "programs" in e.renderer.instance.info && u.state.push({
        key: "Programs",
        value: e.renderer.instance.info.programs?.map((l) => ({
          ...l,
          programName: l.name
        }))
      }), r.state = u;
    }
  } else if (r.nodeId.includes("context")) {
    const i = r.nodeId.match(/^context-([^-]+(?:-[^-]+)*)-(.+)$/), s = i ? i[2] : "context";
    if (!s || s === "context") {
      r.state = {
        object: Object.entries(e).filter(([l]) => !l.startsWith("_") && l !== "parent").map(([l, c]) => ({
          key: l,
          value: me(c) ? c.value : c,
          editable: !1
        }))
      };
      return;
    }
    const a = s.split(".");
    let u = e;
    for (const l of a) {
      if (!u || typeof u != "object")
        break;
      u = me(u[l]) ? u[l].value : u[l];
    }
    u !== void 0 && (r.state = {
      object: Object.entries(u).filter(([l]) => !l.startsWith("_") && l !== "parent").map(([l, c]) => me(c) ? {
        key: l,
        value: c.value,
        editable: !1
      } : typeof c == "function" ? {
        key: l,
        value: "ƒ()",
        editable: !1
      } : c && typeof c == "object" ? {
        key: l,
        value: Array.isArray(c) ? `Array(${c.length})` : "Object",
        editable: !1
      } : {
        key: l,
        value: c,
        editable: !1
      })
    });
  }
}, el = (e, t, n, r) => {
  const o = To(e, t);
  if (!o) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let i = o;
  for (let a = 0; a < n.length - 1; a++)
    if (i[n[a]] !== void 0)
      i = i[n[a]];
    else {
      console.warn(`Property path is not valid: ${n.join(".")}`);
      return;
    }
  const s = n[n.length - 1];
  i[s] !== void 0 ? i[s] = r : console.warn(`Property path is not valid: ${n.join(".")}`);
}, tl = (e) => (t) => {
  if (t.inspectorId === we && t.nodeId.includes("scene")) {
    const n = t.nodeId.match(/^scene-(.+)$/), r = n ? n[1] : null;
    if (!r)
      return;
    el(e.scene.value, r, t.path, t.state.value);
  }
}, we = "tres:inspector";
function nl(e, t) {
  const n = {
    id: "dev.esm.tres",
    label: "TresJS 🪐",
    logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
    packageName: "tresjs",
    homepage: "https://docs.tresjs.org",
    app: e
  }, r = null, o = null;
  qu(t), cu(
    n,
    (i) => {
      typeof i.now != "function" && Gu(
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), i.addInspector({
        id: we,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        i.sendInspectorTree(we);
      }, 1e3), setInterval(() => {
        i.notifyComponentUpdate();
      }, 5e3), i.on.getInspectorTree(Zu(t)), i.on.getInspectorState(Ju(t, {
        highlightMesh: r,
        prevInstance: o
      })), i.on.editInspectorState(tl(t));
    }
  );
}
const rl = ["data-scene", "data-tres"], ol = /* @__PURE__ */ ot({
  __name: "TresCanvas",
  props: {
    camera: {},
    windowSize: { type: Boolean, default: void 0 },
    enableProvideBridge: { type: Boolean, default: !0 },
    antialias: { type: Boolean, default: !0 },
    stencil: { type: Boolean, default: void 0 },
    depth: { type: Boolean, default: void 0 },
    precision: {},
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 },
    clearColor: { default: "#000000" },
    clearAlpha: { default: 1 },
    shadows: { type: Boolean, default: void 0 },
    toneMapping: { default: Yo },
    shadowMapType: { default: Go },
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    renderMode: { default: "always" },
    dpr: {},
    renderer: {}
  },
  emits: ["ready", "pointermissed", "render", "beforeLoop", "loop", "click", "contextmenu", "pointermove", "pointerenter", "pointerleave", "pointerover", "pointerout", "dblclick", "pointerdown", "pointerup", "pointercancel", "lostpointercapture", "wheel"],
  setup(e, { expose: t, emit: n }) {
    const r = e, o = n, i = ko(), s = Ae(), a = it(new yr()), u = $t();
    pt(vr);
    const l = (_, v = !1) => ot({
      setup() {
        const p = $t()?.appContext;
        p && (p.app = u?.appContext.app);
        const g = {};
        function C(b) {
          b && (b.parent && C(b.parent), b.provides && Object.assign(g, b.provides));
        }
        return u?.parent && r.enableProvideBridge && (C(u.parent), Reflect.ownKeys(g).forEach((b) => {
          qe(b, g[b]);
        })), qe(xs, _), qe("extend", pt), typeof window < "u" && p?.app && nl(p?.app, _), () => Wt(No, null, v ? [] : i.default());
      }
    }), c = (_, v = !1) => {
      const p = l(_, v), { render: g } = Mo(Bs(_));
      g(Wt(p), a.value);
    }, f = (_, v = !1) => {
      Ne(_.scene.value), v && (_.renderer.instance.dispose(), _.renderer.instance instanceof Cr && (_.renderer.instance.renderLists.dispose(), _.renderer.instance.forceContextLoss())), a.value.__tres = {
        root: _
      };
    }, h = it(null);
    t({ context: h, dispose: () => f(h.value, !0) });
    const d = () => {
      f(h.value), c(h.value, !0);
    };
    return Kt(() => {
      const _ = s;
      h.value = Rs({
        scene: a.value,
        canvas: _,
        windowSize: r.windowSize ?? !1,
        rendererOptions: r
      });
      const { camera: v, renderer: p } = h.value, { registerCamera: g, cameras: C, activeCamera: b, deregisterCamera: P } = v;
      c(h.value);
      const M = () => {
        const A = new qo(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        A.position.set(3, 3, 3), A.lookAt(0, 0, 0), g(A);
        const O = $(() => {
          C.value.length >= 2 && (A.removeFromParent(), P(A), O?.());
        });
      };
      h.value.events.onPointerMissed((A) => {
        o("pointermissed", A);
      }), At(
        () => r.camera,
        (A, O) => {
          A && g(I(A), !0), O && (I(O).removeFromParent(), P(I(O)));
        },
        {
          immediate: !0
        }
      ), b.value || M(), p.onRender(() => {
        h.value && o("render", h.value);
      }), p.loop.onLoop((A) => {
        h.value && o("loop", { ...h.value, ...A });
      }), p.loop.onBeforeLoop((A) => {
        h.value && o("beforeLoop", { ...h.value, ...A });
      }), p.onReady(() => {
        o("ready", h.value);
      });
    }), Kt(async () => {
      await hi(3e3), h.value && (!h.value.sizes.width || !h.value.sizes.height.value) && console.warn("TresCanvas: The canvas has no area, so nothing can be rendered. Set it manually on the parent element or use the prop windowSize.");
    }), ie(d), (_, v) => (Ro(), xo("canvas", {
      ref_key: "canvasRef",
      ref: s,
      "data-scene": a.value.uuid,
      class: Fo(_.$attrs.class),
      "data-tres": `tresjs ${ke(Fi).version}`,
      style: Lo({
        display: "block",
        width: "100%",
        height: "100%",
        position: e.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ..._.$attrs.style
      })
    }, null, 14, rl));
  }
});
function ml(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof D ? [e.x, e.y, e.z] : e;
}
function gl(e) {
  return e instanceof xe ? e : Array.isArray(e) ? new xe(...e) : new xe(e);
}
const il = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
], El = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => (/^Tres[A-Z]/.test(e) || e.startsWith("tres-")) && !il.includes(e) || e === "primitive"
    }
  }
};
let q = null;
const vl = {
  updated: (e, t) => {
    const r = ((i) => {
      let s = i.value;
      return i.value && $e(i.value) && (s = i.value.position), Array.isArray(i.value) && (s = new D(...s)), s;
    })(t);
    if (!r) {
      Me(`v-distance-to: problem with binding value: ${t.value}`);
      return;
    }
    q && (q.dispose(), e.parent.remove(q));
    const o = r.clone().sub(e.position);
    o.normalize(), q = new Xo(o, e.position, e.position.distanceTo(r), 16776960), e.parent.add(q), console.table(
      [
        ["Distance:", e.position.distanceTo(r)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${e.position?.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${r.x}, y:${r.y}, z:${r?.z}`]
      ]
    );
  },
  unmounted: (e) => {
    q?.dispose(), e.parent && e.parent.remove(q);
  }
};
class Po extends Qo {
  constructor(t, n) {
    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Gt();
    o.setAttribute("position", new Yt(r, 3)), o.computeBoundingSphere();
    const i = new Zo({ fog: !1 });
    super(o, i), this.light = t, this.color = n, this.type = "RectAreaLightHelper";
    const s = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new Gt();
    a.setAttribute("position", new Yt(s, 3)), a.computeBoundingSphere(), this.add(new He(a, new Ar({ side: Jo, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const t = this.material.color, n = Math.max(t.r, t.g, t.b);
      n > 1 && t.multiplyScalar(1 / n), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
let De, W;
const sl = {
  DirectionalLight: ri,
  PointLight: ni,
  SpotLight: ti,
  HemisphereLight: ei,
  RectAreaLight: Po
}, yl = {
  mounted: (e) => {
    if (!Rr(e)) {
      Me(`${e.type} is not a light`);
      return;
    }
    De = sl[e.type], e.parent?.add(new De(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    W = e.parent.children.find((t) => t instanceof De), !(W instanceof Po) && W.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      Me(`${e.type} is not a light`);
      return;
    }
    W = e.parent.children.find((t) => t instanceof De), W && W.dispose && W.dispose(), e.parent && e.parent.remove(W);
  }
}, Cl = {
  mounted: (e, t) => {
    if (t.arg) {
      console.log(`v-log:${t.arg}`, e[t.arg]);
      return;
    }
    console.log("v-log", e);
  }
}, bl = {
  install(e) {
    e.component("TresCanvas", ol);
  }
};
export {
  Hs as DevtoolsMessenger,
  ol as TresCanvas,
  pl as UseLoader,
  es as buildGraph,
  dt as catalogue,
  bl as default,
  Ne as dispose,
  pt as extend,
  kr as isBufferGeometry,
  Pr as isCamera,
  $i as isClassInstance,
  Dr as isColor,
  ji as isColorRepresentation,
  zi as isCopyable,
  Lr as isFog,
  cl as isGroup,
  Zt as isLayers,
  Rr as isLight,
  xr as isMaterial,
  $e as isMesh,
  lt as isObject3D,
  Hi as isOrthographicCamera,
  Ir as isPerspectiveCamera,
  fl as isProd,
  Fr as isScene,
  re as isTresCamera,
  Gi as isTresInstance,
  Ki as isTresObject,
  Wi as isTresPrimitive,
  ct as isVectorLike,
  Jt as logError,
  dl as logMessage,
  Me as logWarning,
  gl as normalizeColor,
  ml as normalizeVectorFlexibleParam,
  nl as registerTresDevtools,
  El as templateCompilerOptions,
  Ji as useCameraManager,
  hl as useGraph,
  Zi as useLoader,
  _l as useLoop,
  rs as useRendererManager,
  Fs as useTres,
  zr as useTresContext,
  Rs as useTresContextProvider,
  vl as vDistanceTo,
  yl as vLightHelper,
  Cl as vLog
};
